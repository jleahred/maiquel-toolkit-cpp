//  code generated by fsm_gen
// generated automatically
// coded last modification:        $CODED_LAST_MODIF  desactivated, lots of false notifications
// pythonscript last modification: $SCRIPT_LAST_MODIF



namespace fsmgen_simple_dor {


class abstract_status;

// -----------------------------------------------------------------------
//      s t a t u s _ c o m m o n _ i n f o

struct  status_common_info
{
    status_common_info ( mtk::Signal<const std::string&   /*sess_id*/    >& _sig_login_ok, mtk::Signal<const std::string&   /*description*/  >& _sig_logout, mtk::Signal<>& _sig_reject_login, mtk::Signal<const std::string&   /*key*/        >& _sig_generated_key, mtk::Signal<const mtk::Alarm&   /*alarm*/      >& _sig_alarm)
        :  
        __session_id(""), 
        sig_login_ok (_sig_login_ok), 
        sig_logout (_sig_logout), 
        sig_reject_login (_sig_reject_login), 
        sig_generated_key (_sig_generated_key), 
        sig_alarm (_sig_alarm)
        {};
    virtual ~status_common_info(){};

    // PROPERTIES AND SIGNALS
    std::string  __session_id;
    virtual const std::string &  session_id() const {  return __session_id; };
    virtual void set_session_id(const std::string &  _prop) {  __session_id = _prop;  };
    mtk::Signal<const std::string&   /*sess_id*/    >& sig_login_ok;
    mtk::Signal<const std::string&   /*description*/  >& sig_logout;
    mtk::Signal<>& sig_reject_login;
    mtk::Signal<const std::string&   /*key*/        >& sig_generated_key;
    mtk::Signal<const mtk::Alarm&   /*alarm*/      >& sig_alarm;


    mtk::Signal<mtk::CountPtr<abstract_status> > signal_new_status;
    mtk::Signal<> signal_keep_temp_status;
    mtk::Signal<> signal_remove_temp_status;

};





// -----------------------------------------------------------------------
//      abstract_status
class abstract_status  : public mtk::SignalReceptor
{
    mtk::non_copyable  nc;

public:
    abstract_status (mtk::CountPtr<status_common_info> _ci)
        : ci (_ci) {};
    virtual ~abstract_status() {};
    
    mtk::CountPtr<status_common_info> ci;
    
    virtual std::string  GetStatusName() = 0;

    //  INPUTS
    virtual void rq_key ( )=0;
    virtual void rq_login ( const std::string&   user       , const std::string&   pass_coded   )=0;
    virtual void rq_logout ( )=0;


    //  ACCESS
    virtual const std::string  &  session_id (void) const { return ci->session_id(); }; 

};





// -----------------------------------------------------------------------
//      logout
class logout  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef logout  CLASS_NAME;

public:
    logout (mtk::CountPtr<status_common_info> _ci,  const std::string & _description)
        : 
        abstract_status(_ci),
        __description(_description)
        { 
            try
            {
                 ci->sig_logout.emit(description()); 
            }
            MTK_CATCH_RETHROW("logout_ctor", "rethrowed") };
    
    std::string  GetStatusName()  {  return "logout"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    std::string  __description;
    virtual const std::string &  description() const {  return __description; };
    virtual void set_description(const std::string &  _prop) {  __description = _prop;  };


    //  INPUTS
public:
    void rq_key ();
    void rq_login (const std::string&   user       , const std::string&   pass_coded   );
    void rq_logout ();


};



// -----------------------------------------------------------------------
//      login_ok
class login_ok  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef login_ok  CLASS_NAME;

public:
    login_ok (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci)

        { 
            try
            {
                 ci->sig_login_ok.emit(session_id()); 
            }
            MTK_CATCH_RETHROW("login_ok_ctor", "rethrowed") };
    
    std::string  GetStatusName()  {  return "login_ok"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)


    //  INPUTS
public:
    void rq_key ();
    void rq_login (const std::string&   user       , const std::string&   pass_coded   );
    void rq_logout ();


};



// -----------------------------------------------------------------------
//      w_rq_login
class w_rq_login  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef w_rq_login  CLASS_NAME;

public:
    w_rq_login (mtk::CountPtr<status_common_info> _ci,  const std::string & _key)
        : 
        abstract_status(_ci),
        __key(_key)
        {  };
    
    std::string  GetStatusName()  {  return "w_rq_login"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    std::string  __key;
    virtual const std::string &  key() const {  return __key; };
    virtual void set_key(const std::string &  _prop) {  __key = _prop;  };


    //  INPUTS
public:
    void rq_key ();
    void rq_login (const std::string&   user       , const std::string&   pass_coded   );
    void rq_logout ();


};






void logout::rq_key (  )
{
    //  remove unused warning
    
    
	static const char* method_name = "logout::rq_key";

    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
//  inserting macro: GEN_KEY
  
          std::string key = MTK_SS(mtk::rand());
          ci->sig_generated_key.emit(key);
      

            new_status = mtk::make_cptr(new w_rq_login (ci, (key)));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void logout::rq_login ( const std::string&   user       , const std::string&   pass_coded    )
{
    //  remove unused warning
    (void) user;
(void) pass_coded;

    
	static const char* method_name = "logout::rq_login";

    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
ci->sig_alarm(mtk::Alarm(MTK_HERE, "logic error", mtk::alPriorError));

            new_status = mtk::make_cptr(new logout (ci, ("rq_login on logout state. logic error")));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void logout::rq_logout (  )
{
    //  remove unused warning
    
    
	static const char* method_name = "logout::rq_logout";

    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
ci->sig_alarm(mtk::Alarm(MTK_HERE, "logic error", mtk::alPriorError));

            new_status = mtk::make_cptr(new logout (ci, ("rq_logout on logout state. logic error")));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void login_ok::rq_key (  )
{
    //  remove unused warning
    
    
	static const char* method_name = "login_ok::rq_key";

    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
ci->sig_alarm(mtk::Alarm(MTK_HERE, "logic error", mtk::alPriorError));

            new_status = mtk::make_cptr(new logout (ci, ("rq_key on login_ok state. logic error")));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void login_ok::rq_login ( const std::string&   user       , const std::string&   pass_coded    )
{
    //  remove unused warning
    (void) user;
(void) pass_coded;

    
	static const char* method_name = "login_ok::rq_login";

    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
ci->sig_alarm(mtk::Alarm(MTK_HERE, "logic error", mtk::alPriorError));

            new_status = mtk::make_cptr(new logout (ci, ("rq_login on login_ok state. logic error")));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void login_ok::rq_logout (  )
{
    //  remove unused warning
    
    
	static const char* method_name = "login_ok::rq_logout";

    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new logout (ci, ("requested by user")));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_rq_login::rq_key (  )
{
    //  remove unused warning
    
    
	static const char* method_name = "w_rq_login::rq_key";

    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
ci->sig_alarm(mtk::Alarm(MTK_HERE, "logic error", mtk::alPriorError));

            new_status = mtk::make_cptr(new logout (ci, ("rq_key on w_rq_login state. logic error")));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_rq_login::rq_login ( const std::string&   user       , const std::string&   pass_coded    )
{
    //  remove unused warning
    (void) user;
(void) pass_coded;

    
	static const char* method_name = "w_rq_login::rq_login";

    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: is_valid_pass

          ({
          bool result = false;
          std::cout << "is_valid_pas " << user << " " << pass_coded << "  " << key() << std::endl;
          
          std::string calculated_pass_coded = mtk::crc32_as_string(MTK_SS(user << "1111" << key()));
          if (user == "fulanito"  &&  pass_coded == calculated_pass_coded)
          {
              std::cout << "is_valid_pas   ok" << std::endl;
              result = true;
          }
          else
          {
              std::cout << "is_valid_pas   FALSE" << std::endl;
              result = false;
          }
          result;
          })
       ) {
//  inserting macro: GEN_SESS_ID

          static int counter=1;
          ci->set_session_id(MTK_SS(++counter));
      

            new_status = mtk::make_cptr(new login_ok (ci));
            ci->signal_new_status.emit(new_status);

        }
    else 
        if (true ) {
//  inserting macro: EMIT_LOG_REJ

          ci->sig_reject_login.emit();
      

            new_status = mtk::make_cptr(new logout (ci, ("invalid user/pass")));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_rq_login::rq_logout (  )
{
    //  remove unused warning
    
    
	static const char* method_name = "w_rq_login::rq_logout";

    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
ci->sig_alarm(mtk::Alarm(MTK_HERE, "logic error", mtk::alPriorError));

            new_status = mtk::make_cptr(new logout (ci, ("rq_logout on w_rq_login state. logic error")));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}


};  // end   namespace fsmgen_simple_dor {

testing::simple_dor::simple_dor()
{
    mtk::CountPtr<fsmgen_simple_dor::status_common_info> ci = mtk::make_cptr(
                            new fsmgen_simple_dor::status_common_info ( sig_login_ok,sig_logout,sig_reject_login,sig_generated_key,sig_alarm));

    current_status = mtk::make_cptr(new fsmgen_simple_dor::logout(ci , "initializing") );
    MTK_CONNECT_THIS(ci->signal_new_status, on_new_status)
    MTK_CONNECT_THIS(ci->signal_keep_temp_status, on_keep_temp_status)
    MTK_CONNECT_THIS(ci->signal_remove_temp_status, on_remove_temp_status)
}


testing::simple_dor::~simple_dor()
{
}

void testing::simple_dor::on_new_status (mtk::CountPtr<fsmgen_simple_dor::abstract_status>  new_status)
{
    current_status = new_status;
}

void testing::simple_dor::on_keep_temp_status (void)
{
    queue_temp_status.push_back(current_status);
}
void testing::simple_dor::on_remove_temp_status (void)
{
    queue_temp_status.pop_front();
}


void testing::simple_dor::rq_key ()
{
    mtk::CountPtr<fsmgen_simple_dor::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->rq_key();
}
void testing::simple_dor::rq_login (const std::string&   user       , const std::string&   pass_coded   )
{
    mtk::CountPtr<fsmgen_simple_dor::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->rq_login(user, pass_coded);
}
void testing::simple_dor::rq_logout ()
{
    mtk::CountPtr<fsmgen_simple_dor::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->rq_logout();
}
const std::string  & testing::simple_dor::session_id (void) const
{
    return current_status->session_id();
}
