//  code generated by fsm_gen
// generated automatically
// coded last modification:        $CODED_LAST_MODIF  desactivated, lots of false notifications
// pythonscript last modification: $SCRIPT_LAST_MODIF



namespace fsmgen_simple_dor {


class abstract_status;

// -----------------------------------------------------------------------
//      s t a t u s _ c o m m o n _ i n f o

struct  status_common_info
{
    status_common_info ( mtk::Signal<>& _sig_opened, mtk::Signal<>& _sig_closed, mtk::Signal<const std::string&   /*key*/        >& _sig_generated_key, mtk::Signal<const mtk::Alarm&   /*alarm*/      >& _sig_alarm)
        :  
        __log(), 
        sig_opened (_sig_opened), 
        sig_closed (_sig_closed), 
        sig_generated_key (_sig_generated_key), 
        sig_alarm (_sig_alarm)
        {};
    virtual ~status_common_info(){};

    // PROPERTIES AND SIGNALS
    std::list<std::string>  __log;
    virtual const std::list<std::string> &  log() const {  return __log; };
    virtual void set_log(const std::list<std::string> &  _prop) {  __log = _prop;  };
    mtk::Signal<>& sig_opened;
    mtk::Signal<>& sig_closed;
    mtk::Signal<const std::string&   /*key*/        >& sig_generated_key;
    mtk::Signal<const mtk::Alarm&   /*alarm*/      >& sig_alarm;


    mtk::Signal<mtk::CountPtr<abstract_status> > signal_new_status;
    mtk::Signal<> signal_keep_temp_status;
    mtk::Signal<> signal_remove_temp_status;

};





// -----------------------------------------------------------------------
//      abstract_status
class abstract_status  : public mtk::SignalReceptor
{
    mtk::non_copyable  nc;

public:
    abstract_status (mtk::CountPtr<status_common_info> _ci)
        : ci (_ci) {};
    virtual ~abstract_status() {};
    
    mtk::CountPtr<status_common_info> ci;
    
    virtual std::string  GetStatusName() = 0;

    //  INPUTS
    virtual void rq_key ( const std::string&   user         )=0;
    virtual void rq_open ( const std::string&   user       , const std::string&   pass_coded   )=0;
    virtual void rq_close ( const std::string&   user       , const std::string&   pass_coded   )=0;


    //  ACCESS
    virtual const std::list<std::string>  &  log (void) const { return ci->log(); }; 

};





// -----------------------------------------------------------------------
//      opened
class opened  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef opened  CLASS_NAME;

public:
    opened (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci),
        __opened_time(mtk::dtNowLocal() )
        {  };
    
    std::string  GetStatusName()  {  return "opened"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    mtk::DateTime  __opened_time;
    virtual const mtk::DateTime &  opened_time() const {  return __opened_time; };
    virtual void set_opened_time(const mtk::DateTime &  _prop) {  __opened_time = _prop;  };


    //  INPUTS
public:
    void rq_key (const std::string&   user         );
    void rq_open (const std::string&   user       , const std::string&   pass_coded   );
    void rq_close (const std::string&   user       , const std::string&   pass_coded   );


};



// -----------------------------------------------------------------------
//      closed
class closed  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef closed  CLASS_NAME;

public:
    closed (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci)

        {  };
    
    std::string  GetStatusName()  {  return "closed"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)


    //  INPUTS
public:
    void rq_key (const std::string&   user         );
    void rq_open (const std::string&   user       , const std::string&   pass_coded   );
    void rq_close (const std::string&   user       , const std::string&   pass_coded   );


};



// -----------------------------------------------------------------------
//      w_rq_open
class w_rq_open  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef w_rq_open  CLASS_NAME;

public:
    w_rq_open (mtk::CountPtr<status_common_info> _ci,  const std::string & _key)
        : 
        abstract_status(_ci),
        __key(_key)
        { 
            try
            {
                                            //  <5>
          std::cout << "w_rq_open"  << std::endl;  
          ci->sig_generated_key.emit(key());
      
            }
            MTK_CATCH_RETHROW("w_rq_open_ctor", "rethrowed") };
    
    std::string  GetStatusName()  {  return "w_rq_open"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    std::string  __key;
    virtual const std::string &  key() const {  return __key; };
    virtual void set_key(const std::string &  _prop) {  __key = _prop;  };


    //  INPUTS
public:
    void rq_key (const std::string&   user         );
    void rq_open (const std::string&   user       , const std::string&   pass_coded   );
    void rq_close (const std::string&   user       , const std::string&   pass_coded   );


};



// -----------------------------------------------------------------------
//      w_rq_close
class w_rq_close  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef w_rq_close  CLASS_NAME;

public:
    w_rq_close (mtk::CountPtr<status_common_info> _ci,  const std::string       & _key)
        : 
        abstract_status(_ci),
        __key(_key),
        __key_again(_key)
        { 
            try
            {
                 std::cout << "w_rq_close"  << std::endl;      
            }
            MTK_CATCH_RETHROW("w_rq_close_ctor", "rethrowed") };
    
    std::string  GetStatusName()  {  return "w_rq_close"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    std::string        __key;
    virtual const std::string       &  key() const {  return __key; };
    virtual void set_key(const std::string       &  _prop) {  __key = _prop;  };
    std::string  __key_again;
    virtual const std::string &  key_again() const {  return __key_again; };
    virtual void set_key_again(const std::string &  _prop) {  __key_again = _prop;  };


    //  INPUTS
public:
    void rq_key (const std::string&   user         );
    void rq_open (const std::string&   user       , const std::string&   pass_coded   );
    void rq_close (const std::string&   user       , const std::string&   pass_coded   );


};






void opened::rq_key ( const std::string&   user          )
{
    //  remove unused warning
    (void) user;

    
	static const char* method_name = "opened::rq_key";

    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
//  inserting macro: COUT_RQK

        std::cout << "COUT_RQK" << std::endl;
    

            new_status = mtk::make_cptr(new w_rq_close (ci, (generate_key(user))));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void opened::rq_open ( const std::string&   user       , const std::string&   pass_coded    )
{
    //  remove unused warning
    (void) user;
(void) pass_coded;

    
	static const char* method_name = "opened::rq_open";

    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
ci->sig_alarm(mtk::Alarm(MTK_HERE, "logic error", mtk::alPriorError));

            new_status = mtk::make_cptr(new opened (ci));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void opened::rq_close ( const std::string&   user       , const std::string&   pass_coded    )
{
    //  remove unused warning
    (void) user;
(void) pass_coded;

    
	static const char* method_name = "opened::rq_close";

    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
ci->sig_alarm(mtk::Alarm(MTK_HERE, "logic error", mtk::alPriorError));

            new_status = mtk::make_cptr(new opened (ci));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void closed::rq_key ( const std::string&   user          )
{
    //  remove unused warning
    (void) user;

    
	static const char* method_name = "closed::rq_key";

    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_rq_open (ci, (generate_key(user))  ));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void closed::rq_open ( const std::string&   user       , const std::string&   pass_coded    )
{
    //  remove unused warning
    (void) user;
(void) pass_coded;

    
	static const char* method_name = "closed::rq_open";

    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
ci->sig_alarm(mtk::Alarm(MTK_HERE, "logic error", mtk::alPriorError));

            new_status = mtk::make_cptr(new closed (ci));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void closed::rq_close ( const std::string&   user       , const std::string&   pass_coded    )
{
    //  remove unused warning
    (void) user;
(void) pass_coded;

    
	static const char* method_name = "closed::rq_close";

    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
ci->sig_alarm(mtk::Alarm(MTK_HERE, "logic error", mtk::alPriorError));

            new_status = mtk::make_cptr(new closed (ci));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_rq_open::rq_key ( const std::string&   user          )
{
    //  remove unused warning
    (void) user;

    
	static const char* method_name = "w_rq_open::rq_key";

    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
ci->sig_alarm(mtk::Alarm(MTK_HERE, "logic error", mtk::alPriorError));

            new_status = mtk::make_cptr(new closed (ci));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_rq_open::rq_open ( const std::string&   user       , const std::string&   pass_coded    )
{
    //  remove unused warning
    (void) user;
(void) pass_coded;

    
	static const char* method_name = "w_rq_open::rq_open";

    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: valid_key

         key() == "1111"
      ) {
//  inserting macro: open_dor

        std::cout << "opening dor" << std::endl;
        ci->__log.push_back( MTK_SS("open_door" << std::endl) );
    

            new_status = mtk::make_cptr(new opened (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: sig_opened

        std::cout << "post action opened" << std::endl;
        ci->sig_opened.emit();
     

        }
    else 
        if (true ) {
//  inserting macro: cout_invalid_key

        std::cout << "invalid key " << key()  << std::endl;
    

            new_status = mtk::make_cptr(new closed (ci));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_rq_open::rq_close ( const std::string&   user       , const std::string&   pass_coded    )
{
    //  remove unused warning
    (void) user;
(void) pass_coded;

    
	static const char* method_name = "w_rq_open::rq_close";

    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
ci->sig_alarm(mtk::Alarm(MTK_HERE, "logic error", mtk::alPriorError));

            new_status = mtk::make_cptr(new closed (ci));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_rq_close::rq_key ( const std::string&   user          )
{
    //  remove unused warning
    (void) user;

    
	static const char* method_name = "w_rq_close::rq_key";

    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
ci->sig_alarm(mtk::Alarm(MTK_HERE, "logic error", mtk::alPriorError));

            new_status = mtk::make_cptr(new opened (ci));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_rq_close::rq_open ( const std::string&   user       , const std::string&   pass_coded    )
{
    //  remove unused warning
    (void) user;
(void) pass_coded;

    
	static const char* method_name = "w_rq_close::rq_open";

    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
ci->sig_alarm(mtk::Alarm(MTK_HERE, "logic error", mtk::alPriorError));

            new_status = mtk::make_cptr(new opened (ci));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_rq_close::rq_close ( const std::string&   user       , const std::string&   pass_coded    )
{
    //  remove unused warning
    (void) user;
(void) pass_coded;

    
	static const char* method_name = "w_rq_close::rq_close";

    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: valid_key

         key() == "1111"
      ) {
//  inserting macro: close_dor

        std::cout << "closing dor" << std::endl;
        ci->__log.push_back( MTK_SS("close_dor" << std::endl) );
    

            new_status = mtk::make_cptr(new closed (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: sig_closed

        std::cout << "post action closeded" << std::endl;
        ci->sig_closed.emit();
     

        }
    else 
        if (true ) {
//  inserting macro: cout_invalid_key

        std::cout << "invalid key " << key()  << std::endl;
    

            new_status = mtk::make_cptr(new opened (ci));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}


};  // end   namespace fsmgen_simple_dor {

testing::simple_dor::simple_dor()
{
    mtk::CountPtr<fsmgen_simple_dor::status_common_info> ci = mtk::make_cptr(
                            new fsmgen_simple_dor::status_common_info ( sig_opened,sig_closed,sig_generated_key,sig_alarm));

    current_status = mtk::make_cptr(new fsmgen_simple_dor::closed(ci ) );
    MTK_CONNECT_THIS(ci->signal_new_status, on_new_status)
    MTK_CONNECT_THIS(ci->signal_keep_temp_status, on_keep_temp_status)
    MTK_CONNECT_THIS(ci->signal_remove_temp_status, on_remove_temp_status)
}


testing::simple_dor::~simple_dor()
{
}

void testing::simple_dor::on_new_status (mtk::CountPtr<fsmgen_simple_dor::abstract_status>  new_status)
{
    current_status = new_status;
}

void testing::simple_dor::on_keep_temp_status (void)
{
    queue_temp_status.push_back(current_status);
}
void testing::simple_dor::on_remove_temp_status (void)
{
    queue_temp_status.pop_front();
}


void testing::simple_dor::rq_key (const std::string&   user         )
{
    mtk::CountPtr<fsmgen_simple_dor::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->rq_key(user);
}
void testing::simple_dor::rq_open (const std::string&   user       , const std::string&   pass_coded   )
{
    mtk::CountPtr<fsmgen_simple_dor::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->rq_open(user, pass_coded);
}
void testing::simple_dor::rq_close (const std::string&   user       , const std::string&   pass_coded   )
{
    mtk::CountPtr<fsmgen_simple_dor::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->rq_close(user, pass_coded);
}
const std::list<std::string>  & testing::simple_dor::log (void) const
{
    return current_status->log();
}
