//  code generated by fsm_gen
// generated automatically
// coded last modification:        $CODED_LAST_MODIF  desactivated, lots of false notifications
// pythonscript last modification: $SCRIPT_LAST_MODIF



namespace fsmgen_simple_dor {


class abstract_status;

// -----------------------------------------------------------------------
//      s t a t u s _ c o m m o n _ i n f o

struct  status_common_info
{
    status_common_info ( mtk::Signal<>& _sig_opened, mtk::Signal<>& _sig_closed)
        :  
        sig_opened (_sig_opened), 
        sig_closed (_sig_closed)
        {};
    virtual ~status_common_info(){};

    // PROPERTIES AND SIGNALS
    mtk::Signal<>& sig_opened;
    mtk::Signal<>& sig_closed;


    mtk::Signal<mtk::CountPtr<abstract_status> > signal_new_status;
    mtk::Signal<> signal_keep_temp_status;
    mtk::Signal<> signal_remove_temp_status;

};





// -----------------------------------------------------------------------
//      abstract_status
class abstract_status  : public mtk::SignalReceptor
{
    mtk::non_copyable  nc;

public:
    abstract_status (mtk::CountPtr<status_common_info> _ci)
        : ci (_ci) {};
    virtual ~abstract_status() {};
    
    mtk::CountPtr<status_common_info> ci;
    
    virtual std::string  GetStatusName() = 0;

    //  INPUTS
    virtual void open ( const int&          key          )=0;
    virtual void close ( const int&          key          )=0;


    //  ACCESS

};





// -----------------------------------------------------------------------
//      opened
class opened  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef opened  CLASS_NAME;

public:
    opened (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci)

        {  };
    
    std::string  GetStatusName()  {  return "opened"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)


    //  INPUTS
public:
    void open (const int&          key          );
    void close (const int&          key          );


};



// -----------------------------------------------------------------------
//      closed
class closed  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef closed  CLASS_NAME;

public:
    closed (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci)

        {  };
    
    std::string  GetStatusName()  {  return "closed"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)


    //  INPUTS
public:
    void open (const int&          key          );
    void close (const int&          key          );


};






void opened::open ( const int&          key           )
{
    //  remove unused warning
    (void) key;

    
	static const char* method_name = "opened::open";

    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new opened (ci));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void opened::close ( const int&          key           )
{
    //  remove unused warning
    (void) key;

    
	static const char* method_name = "opened::close";

    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: valid_key

        key == 1111
     ) {
//  inserting macro: close_dor

        std::cout << "closing dor" << std::endl;
        ci->sig_closed.emit();
    

            new_status = mtk::make_cptr(new closed (ci));
            ci->signal_new_status.emit(new_status);

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new opened (ci));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void closed::open ( const int&          key           )
{
    //  remove unused warning
    (void) key;

    
	static const char* method_name = "closed::open";

    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: valid_key

        key == 1111
     ) {
//  inserting macro: open_dor

        std::cout << "opening dor" << std::endl;
        ci->sig_opened.emit();
    

            new_status = mtk::make_cptr(new opened (ci));
            ci->signal_new_status.emit(new_status);

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new closed (ci));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void closed::close ( const int&          key           )
{
    //  remove unused warning
    (void) key;

    
	static const char* method_name = "closed::close";

    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new closed (ci));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}


};  // end   namespace fsmgen_simple_dor {

testing::simple_dor::simple_dor()
{
    mtk::CountPtr<fsmgen_simple_dor::status_common_info> ci = mtk::make_cptr(
                            new fsmgen_simple_dor::status_common_info ( sig_opened,sig_closed));

    current_status = mtk::make_cptr(new fsmgen_simple_dor::closed(ci ) );
    MTK_CONNECT_THIS(ci->signal_new_status, on_new_status)
    MTK_CONNECT_THIS(ci->signal_keep_temp_status, on_keep_temp_status)
    MTK_CONNECT_THIS(ci->signal_remove_temp_status, on_remove_temp_status)
}


testing::simple_dor::~simple_dor()
{
}

void testing::simple_dor::on_new_status (mtk::CountPtr<fsmgen_simple_dor::abstract_status>  new_status)
{
    current_status = new_status;
}

void testing::simple_dor::on_keep_temp_status (void)
{
    queue_temp_status.push_back(current_status);
}
void testing::simple_dor::on_remove_temp_status (void)
{
    queue_temp_status.pop_front();
}


void testing::simple_dor::open (const int&          key          )
{
    mtk::CountPtr<fsmgen_simple_dor::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->open(key);
}
void testing::simple_dor::close (const int&          key          )
{
    mtk::CountPtr<fsmgen_simple_dor::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->close(key);
}
