== mtk_qpid

:cpp: {basebackend@docbook:c++:cpp}


* +qpid+ is a implementation from redhat and apache foundation of +AMQP+
* On +mtk+ we have a small wrapper to work with it
* Messages generated with +mtk build messages+ can be used with +qpid+ easily
** They can define the working subject for each message

[NOTE]
In order to run examples, you have to run and configure qpidd +
+qpidd +
export PYTHONPATH=/home/maiquel/Downloads/qpid-0.6/python/ +
./qpid-config add exchange topic testing+


=== mtk_qpid small example1
[source,{cpp}]
-----
include::../../examples/onefile/qpid/ex_qpid1.cpp[]
-----
<1> Suscribing directly (not common)

=== mtk_qpid small example2
* Now the system connects with a class
[source,{cpp}]
-----
include::../../examples/onefile/qpid/ex_qpid2.cpp[]
-----


=== mtk_qpid direct message example

[source,{cpp}]
-----
include::../../examples/onefile/qpid/ex_qpid_direct_msg.cpp[]
-----
<1> creating codding and sending the message


=== mtk_qpid sending and receving with parsing (recommended)

[source,{cpp}]
-----
include::../../examples/onefile/qpid/ex_qpid_msg_parsing.cpp[]
-----
<1> Header file with message definition. It was created with +build_message+
<2> Normal subscription, parsing and considering message type
<3> Manual subscription no parsing

Look we are making a double subscription with two messages types on same address, therefore, we will receive messages twice

The message used on this testing is defined on 

.tools/src/build_msg/doc/examples/ex1/test_messages.msg
[source,{cpp}]
----
include::../../tools/src/build_msg/doc/examples/ex1/test_messages.msg[]
----
////////
<1> Initialization (pending to put at end and hide on documents)
<2> Creating a message with version 0
<3> Optional field
<4> Defining subject on message
<5> External nested submessage
<6> External NOT nested submessage
<7> Group of fields not nested on wired message
<8> Group of fields nested on wired message
<9> If visibility is not especified, it's mandatory
<10> Inheritance example
//////////



=== Control Fields

* All messages _autoparsed_ (and all messages generated by +msg_build.py+) will have an extra sub_message called +sub_control_fields+
+
.tools/src/build_msg/doc/examples/ex1/test_messages.msg
[source,{cpp}]
----
include::../../src/mtk_qpid/msg_control_fields.msg[]
----
+
* Here is defined the message type and info to control flucts between servers
* +mtk_qpid.hpp+ will require the control fields key calling to +mtk::set_control_fluct_key+, +admin+ will do it for us
* The +control_fluct_key+ is filled on +qpidmsg_codded_as_qpid_message+ from +build_msg.py+ script
* When using control fields and automatic parsing, the main program (if not using +admin+) has to implement:
+
----
    //  to be defined externally
    void check_control_flields_flucts    (const std::string&  key, const mtk::DateTime&  dt);
----
+
* It will also inform from flucts using another signal
* +components/admin/+ trap these signals and deal with this information, generating stats and alarms
