== Support


:cpp: {basebackend@docbook:c++:cpp}


Section names will be the filename or classname


=== version
  support/version.hpp

* Define the +MTK_VERSION+ variable
* The value is loaded from +VERSION+ file as in documentation
+
.version.hpp
[source,{cpp}]
----
include::../../src/support/version.hpp[]
----


=== platform
  support/platform.hpp

* Here we have the precompiler variables to compile on windows or Linux
* Small and easy file
+
.platform.hpp
[source,{cpp}]
----
include::../../src/support/platform.hpp[]
----



=== misc
  support/misc.h  support/misc.cpp

* Here we have some functions of general purpouse
* A simple rand function, GetMachineCode, Sleep, div0 control...
* You don't need to initialize the random function before calling mtk::rand
+
.misc.h
[source,{cpp}]
----
include::../../src/support/misc.h[]
----


=== base35
  support/misc.h  support/misc.cpp

* A couple of functions for base 35 conversion
* It will use digits from 0 to 9 and letters uppercase from A to Z except the letter O
+
.test_base35.cpp
[source,{cpp}]
----
include::../../examples/onefile/support/test_base35.cpp[]
----

=== Int Div0 control
  support/misc.h  support/misc.cpp

* In C/C++ es frecuent an anormal program stop due to a integer division by 0
* With float number is not a problem because return +#inf+ or +#nan+
* Macros  MTK_HANDLE_DIV0_INIT and MTK_HANDLE_DIV0_END will trap the int div zero and will throw +std::runtime_error("SIGNAL FPE probably int div0");+
* It's necessary to avoid int div zero, but in case of, the library will try continues working
* You can nest these macros (try don't do it) +
  If so, you have to add _A and a unique identifier per nesting
+
.test_div0_control.cpp
[source,{cpp}]
----
include::../../examples/onefile/support/test_div0_control.cpp[]
----




=== release_on_exit
  support/release_on_exit.hpp

* Using +static+ or +singleton+ vars, can produce a non deterministic deleting order (or even not deleting)
* In some cases is mandatory to control the order deletion
* In all cases, we want to help _valgrind_ to do his job
* When necessary, we will create a compiler directive to release on exit
* We will order those release resources in this file
+
.release_on_exit.hpp
[source,{cpp}]
----
include::../../src/support/release_on_exit.hpp[]
----




=== crc32
 support/crc32.h

* Two small and easy functions to calculate +crc32+
* Very usefull as non reversible function
* In the future, I'll add other functions like +md5+
+
.Example crc32
[source,{cpp}]
----
include::../../examples/onefile/support/ex_crc32.cpp[]
----
+
.crc32.h
[source,{cpp}]
----
include::../../src/support/crc32.h[]
----



=== basic_types
  support/basic_types.hpp

* Define common types like +non_copiable+ or +__int64+
+
.basic_types.hpp
[source,{cpp}]
----
include::../../src/support/basic_types.hpp[]
----


=== CountPtr
  support/count_ptr.hpp

* This is a template to work with pointers without pointers inconvenients and +RAII+
* An important diference with solutions like _boost_ or _c++0x_ is...
** If you try to access the pointer and it is not valid (not initialized or already deleted), the library will throw a exception
* This exception will be of type std::exception or any son on std
* It's not good idea to throw an mtk::Alarm exception as +CountPtr+ is a very basic part of library
* To create an instance of +CountPtr+, use +mtk::make_cptr(...)+
+
.Small example CountPtr
[source,{cpp}]
----
include::../../examples/onefile/support/ex_count_ptr.cpp[]
----



=== Bool
  support/bool.hpp

* Here is declared a boolean type with autoinitialization
* I wrote this when I needed it.
* At the end it wasn't necessary but I keep it just in case
* Probably never will be usefull
+
.mtk_bool.hpp
[source,{cpp}]
----
include::../../src/support/mtk_bool.hpp[]
----
+
.Example mtk_bool
[source,{cpp}]
----
include::../../examples/onefile/support/ex_bool.cpp[]
----


=== Tuples
  support/tuples.hpp

* Small and easy tuples
* Don't forget +make_tuple+
* Elements inside tuples has to be copiables
* You can use +<+ and +<<+ operator if elements support them
+
.Example Tuples
[source,{cpp}]
----
include::../../examples/onefile/support/ex_tuples.cpp[]
----


=== Nullable
  support/nullable.hpp

* A template to warp types that cannot represent no value or invalid value (+int+, +mtk::DateTime+, ...)
* Using this warper, you can represent this situation and you can also use them in all +std+ and +mtk+ containers
* There are two warpers
nullable::
Requieres copy constructor and copy assignation operator
Nullable::
This one is more eficient, but requieres empty constructor

* Example
+
.Example nullable
[source,{cpp}]
----
include::../../examples/onefile/support/ex_nullable.cpp[]
----




=== Double
  support/mtk_double.h

* This is a small class to work as a double except...
** It's easy to represent not valid value for all plattforms
** Comparation operators can be used. +
   If diference between doubles are very small, +mtk::double+ will identify as equal
* The performance compared with native double is very low, use with caution
* To initialize a +mtk::Double+ with no value, you have to use +mtk::Double::InvalidValue+
+
.mtk_double.hpp
[source,{cpp}]
----
include::../../src/support/mtk_double.h[]
----


=== DateTime
  support/date_time.h

* All classes and functions has de prefix +dt+
* There are two classes here to manage dates and times
DateTime::
** This class is used to represent a specific moment on time
** Composed by year, month, day, hour, minuts, seconds, milliseconds
** Internally coded in a double
** [red]#pending localtime#
TimeQuantity::
** This one is used to deal with time intervals
** Composed by days, hour, minuts, seconds, milliseconds
** Internally coded in a double
* Adding and substrating
** You can substract two +DateTime+ and you will get a +TimeQuantity+
** You cannot add two +DateTime+ (it's not logical)
** You can add or substact two +TimeQuantity+ and you will get another +TimeQuantity+
* To avoid problems with params order, instead of using +int+, it's defined +dtMonth+, +dtHour+, ...
* You can write in stream with << operator (therefore, you can also write to string with +MTK_SS+ macro)
* On +mtk_string+ you have functions to convert from string to +DateTime+ or +TimeQuantity+
* dtMachineGetTotalMillisecs
** Return the milliseconds since machine is on
** On windows, this function is not sensitive to time modifications by user or any program
** This funcion uses a trick in order to work with 64bits and remove the problem of 49.7 days limit on 32bits
* Examples
+
.Example DateTime1
[source,{cpp}]
----
include::../../examples/onefile/support/ex_date_time.cpp[]
----
+
.Example DateTime2
[source,{cpp}]
----
include::../../examples/onefile/support/ex_date_time2.cpp[]
----
+
.date_time.h
[source,{cpp}]
----
include::../../src/support/date_time.h[]
----
+
* Testing test_dtMachineGetTotalMillisecs.cpp
.test_dtMachineGetTotalMillisecs.cpp
+
[source,{cpp}]
----
include::../../examples/onefile/support/test_dtMachineGetTotalMillisecs.cpp[]
----


=== exec_max_frec
  support/exec_max_frec.h

* Here we have a set of macros to control the max frecuence execution of a block of code
MTK_EXEC_MAX_FREC::
** This is the most common used macro
** Use it inside object methods
MTK_EXEC_MAX_FREC_S::
** This has a better performance thand +MTK_EXEC_MAX_FREC+
** Can be used only in functions or static methods
MTK_EXEC_MAX_FREC_OBJ::
** This is weird used
** This one lets you use a contol for several blocks of code
[WARNING]
You can write +MTK_EXEC_MAX_FREC_S+ inside a object method +
If so, probably the program doesn't work as you spected and will be dificult to detect this issue

* There is a family +MTK_EXEC_MAX_FREC_NO_FIRST+ with same behaviour except (as the name says) the first call, will not be executed
* You can nest them using the family +MTK_EXEC_MAX_FREC_A+
* This macros are very usefull to avoid excesive messages on motinoring or logs
+
.Example ex_exec_max_frec.cpp
[source,{cpp}]
----
include::../../examples/onefile/support/ex_exec_max_frec.cpp[]
----



=== Alarm
  support/alarm.h

* +mtk::Alarm+ is the class used to throw exceptions or send notifications on this library
* You can stack alarms
* You have a couple of macros to reduce and get more readable code
** +MTK_CATCH_RETHROW+
** +MTK_CACTH_CALLFUNCTION+
* It's very convenient to use +MTK_HERE+ on alarm creation on field +source+
* Example
+
.ex_alarm.cpp
[source,{cpp}]
----
include::../../examples/onefile/support/ex_alarm.cpp[]
----


[[mtk_containers,mtk_containers]]
=== Containers
  support/container_support.h
  support/vector.hpp
  support/list.hpp
  support/map.hpp
  support/set.hpp

* We have a small warper of main STL containers
** vector
** map
** list
** set
* At the moment there is no implementation of adapters
* This warper is almost compatible with STL
** Most of code can be adapted to mtk::containers just modifying std::list for mkt::list (or the specific container type)
* There is not fully implemented all the STL interfaz
* Iterators aren't in STL hierarchy, therefore, it's not possible to use STL algorithms
* There are not iterators on mtk::vectors (at the moment)
STL iterators::
** They try to look as pointers
*** They have pointer arithmetic
*** They can point to no place
*** They can point to wrong place
*** There haven't any kind of check
** This is not good for critical aplications [red]#pending link#
** There are not verification on _deref_
** The value could be gone
*** Cleared container
*** Container out of scope
** Iterartor end() doen't check anything and you can get a beatifull verse
** You can do ++end()
** How to change beatifull verses using iterators by execptions?
*** When a iterator is created, it will save a reference to the container, a reference to the last iterator and a reference code of last modification on container (not modification of values)
*** Before increment an iterator, it checks is a valid iterator and is not an end iterator
*** Before desref an iterator, it checks is valid and not end
*** An iterator is not valid when timestamp last cointainer modification is diferent to timestamp saved on iterator
** Risk managed
*** Get a value from a not initialized iterator
*** Next iterator with not initilized iterator
*** Get value from iterator of empty container
*** Get value iterator of deleted container
*** Next iterator of deleted container
*** Try get value of deleted element
*** Next iterator over end()
* Test
+
.test_containers.cpp
[source,{cpp}]
----
include::../../examples/onefile/support/test_containers.cpp[]
----


=== FixedNumber
  support/fixednumber.h

* Fix precision numbers
* Safe comparation
* Save operations
* +fnExt+ is a support class wich manage number of decimals and increment
* You can add or substract ticks to a +FixedNumber+
+
.Creating and comparing +fnExt+
[source,{cpp}]
----
        assert (        mkt::fnExt(mkt::fnDec(5), mkt::fnInc(5)   )
                        !=
                        mkt::fnExt(mkt::fnDec(2), mkt::fnInc(5)    )
            );

        assert (        mkt::fnExt(mkt::fnDec(2), mkt::fnInc(10)   )
                        !=
                        mkt::fnExt(mkt::fnDec(1), mkt::fnInc(1)    )
            );
----
+
* fnDouble
+
.fnDouble
[source,{cpp}]
----
        mkt::fnDouble d1 (3.4);
        mkt::fnDouble d2 (3.4, mkt::fnRoundArithmetic   );

        mkt::fnDouble d3 (3.4, mkt::fnRoundFloor        );
        mkt::fnDouble d4 (3.4, mkt::fnRoundCeil         );
        mkt::fnDouble d5 (3.4, mkt::fnRoundNotAllowed   );
----
* constructors
+
.constructors
[source,{cpp}]
----
        //  double
        assert  (
                    mkt::FixedNumber(
                        mkt::fnDouble   (3.1415926535          ),
                        mkt::fnDec      (4                     ),
                        mkt::fnInc      (1                     )
                    )
                    ==
                    mkt::FixedNumber(
                        mkt::fnDouble   (3.1415926535            ,
                                         mkt::fnRoundArithmetic ),
                        mkt::fnDec      (4                      ),
                        mkt::fnInc      (1                      )
                    )
            );

        assert  (
                    mkt::FixedNumber(
                        mkt::fnDouble   (3.1415926535        ,
                                         mkt::fnRoundCeil   ),
                        mkt::fnDec      (4                  ),
                        mkt::fnInc      (1                  )
                    )
                    ==
                    mkt::fn(        //  nombre abreviado
                        mkt::fnDouble   (3.1415926535        ,
                                         mkt::fnRoundCeil   ),
                        mkt::fnDec      (4                  ),
                        mkt::fnInc      (1                  )
                    )

                );

        //  integer
        assert  (
                    mkt::FixedNumber(
                        mkt::fnIntCode  (31416                 ),
                        mkt::fnDec      (4                     ),
                        mkt::fnInc      (1                     )
                    )
                    ==
                    mkt::FixedNumber(
                        mkt::fnDouble   (3.1415926535            ,
                                         mkt::fnRoundArithmetic ),
                        mkt::fnDec      (4                      ),
                        mkt::fnInc      (1                      )
                    )

                );



                //  error en tiempo de ejecución
                //  redondeo por defecto para enteros...   notallowed
                    mkt::FixedNumber(
                        mkt::fnIntCode  (31416              ),
                        mkt::fnDec      (4                  ),
                        mkt::fnInc      (5                  )
                    );


        assert  (
                    mkt::FixedNumber(
                        mkt::fnIntCode  (31415                 ),
                        mkt::fnDec      (4                     ),
                        mkt::fnInc      (5                     )
                    )
                    ==
                    mkt::FixedNumber(
                        mkt::fnIntCode   (31416                  ,
                                         mkt::fnRoundArithmetic ),
                        mkt::fnDec      (4                      ),
                        mkt::fnInc      (5                      )
                    )

                );






        //  fnExt
        assert  (
                    mkt::FixedNumber(
                        mkt::fnIntCode  (31416                 ),
                        mkt::fnExt (
                                    mkt::fnDec      (4         ),
                                    mkt::fnInc      (1         )
                                   )
                    )
                    ==
                    mkt::FixedNumber(
                        mkt::fnDouble   (3.1415926535            ,
                                         mkt::fnRoundArithmetic ),
                        mkt::fnExt (
                                    mkt::fnDec      (4          ),
                                    mkt::fnInc      (1          )
                                   )
                    )

                );
----
+
* Access methods
+
.access methods
[source,{cpp}]
----
            //  lectura
        assert  (
                    mkt::fn(mkt::fnDouble(3.14), mkt::fnDec(2), mkt::fnInc(5))
                    .GetDouble()
                    > 3.14
                    //  == 3.15
                );


        mkt::fn fn1 (mkt::fnDouble(3.14), mkt::fnDec(2), mkt::fnInc(5));

        assert (    fn1.GetExt().GetDec()       ==  2              );
        assert (    fn1.GetDouble()             >   3.14           );
        assert (    fn1.d()                     >   3.14           );
        assert (    fn1.GetExt().GetAdicionalFormat()    ==  mkt::fnAfNormal);



            //  escritura
        fn1.SetDouble(3.11);
        assert (    fn1.GetIntCode()            ==  310 );
        assert (    fn1.GetDouble ()            <   3.11);

        fn1.SetIntCode(39);
        assert (    fn1.GetIntCode()            ==  40 );
        assert (    fn1.GetDouble ()            >   0.39);


        mkt::fn fn2 =  fn1;
        assert (    fn1.SetDouble(3.10)         ==  fn2.SetIntCode(310)  );


        assert  (
                    mkt::FixedNumber(
                        mkt::fnIntCode  (0                      ),
                        mkt::fnDec      (4                      ),
                        mkt::fnInc      (5                      )
                    ).SetIntCode (31415)
                    ==
                    mkt::FixedNumber(
                        mkt::fnIntCode  (0                      ),
                        mkt::fnDec      (4                      ),
                        mkt::fnInc      (5                      )
                    ).SetIntCode (31416, mkt::fnRoundArithmetic )

                );


                //  error en tiempo de ejecución,
                //  default round for integers, not allowed
                    mkt::FixedNumber fnp = mkt::FixedNumber(
                                mkt::fnIntCode  (0                  ),
                                mkt::fnDec      (4                  ),
                                mkt::fnInc      (5                  )
                        ).SetIntCode (31416);

                    mkt::FixedNumber fnp2(
                                mkt::fnIntCode  (0                  ),
                                mkt::fnDec      (4                  ),
                                mkt::fnInc      (5                  )
                        );
                    fnp2.SetIntCode (31416);
----
+
* Relational and arithmetics operators
+
.operators
[source,{cpp}]
----
                //  relacionales
        assert  (
                    mkt::fn(mkt::fnDouble(3.14), mkt::fnDec(2), mkt::fnInc(5))
                    >=
                    mkt::fn(mkt::fnDouble(3.14), mkt::fnDec(2), mkt::fnInc(5))
                    &&
                    mkt::fn(mkt::fnDouble(3.14), mkt::fnDec(2), mkt::fnInc(5))
                    >
                    mkt::fn(mkt::fnDouble(3.0) , mkt::fnDec(2), mkt::fnInc(5))
                    &&
                    mkt::fn(mkt::fnDouble(3.0) , mkt::fnDec(2), mkt::fnInc(5))
                    !=
                    mkt::fn(mkt::fnDouble(3.14) , mkt::fnDec(2), mkt::fnInc(5))
                    &&
                    mkt::fn(mkt::fnDouble(3.14) , mkt::fnDec(2), mkt::fnInc(5))
                    <
                    mkt::fn(mkt::fnDouble(20.0) , mkt::fnDec(2), mkt::fnInc(5))
                );


                    //  error en tiempo de ejecución, no son comparables
        assert  (
                    mkt::fn(mkt::fnDouble(3.14), mkt::fnDec(2), mkt::fnInc(1))
                    >=
                    mkt::fn(mkt::fnDouble(3.14), mkt::fnDec(2), mkt::fnInc(5))
                );
        assert  (
                    mkt::fn(mkt::fnDouble(3.14), mkt::fnDec(1), mkt::fnInc(5))
                    >=
                    mkt::fn(mkt::fnDouble(3.14), mkt::fnDec(2), mkt::fnInc(5))
                );






                //  aritméticos

        mkt::fn fna (mkt::fnDouble(3.20), mkt::fnDec(2), mkt::fnInc(1));
        assert  (
                    ++mkt::fn(mkt::fnDouble(3.14), mkt::fnDec(2), mkt::fnInc(1))
                    ==
                    mkt::fn  (mkt::fnDouble(3.15), mkt::fnDec(2), mkt::fnInc(1))

                    &&

                    mkt::fn  (mkt::fnDouble(3.15), mkt::fnDec(2), mkt::fnInc(1))
                    ==
                    --mkt::fn(mkt::fnDouble(3.16), mkt::fnDec(2), mkt::fnInc(1))

                    &&

                    --mkt::fn(mkt::fnDouble(3.16), mkt::fnDec(2), mkt::fnInc(1))
                    ==
                    mkt::fn  (mkt::fnDouble(3.10), mkt::fnDec(2), mkt::fnInc(1))
                    +mkt::fnTicks(5)

                    &&

                    mkt::fn  (mkt::fnDouble(3.10), mkt::fnDec(2), mkt::fnInc(1))
                    +mkt::fnTicks(5)
                    ==
                    (fna-=mkt::fnTicks(5))
                );
----
+
* Example1
+
.Example FixedNumber 1
[source,{cpp}]
----
include::../../examples/onefile/support/ex_fixed_number.cpp[]
----
+
* Example2
+
.Example FixedNumber 2
[source,{cpp}]
----
include::../../examples/onefile/support/ex_fixed_number2.cpp[]
----


=== Property
  support/property.h

* This is a kind of simple and easy +variant+
+
.property.h
[source,{cpp}]
----
include::../../src/support/property.h[]
----


=== SignalSlot
  support/signal_slot.hpp

* At the moment it's supported till 4 parameters
* It's allowed to connect one signal to one slot several times
** Calling disconect will disconnect only one of them
** It's possible to remove this behavior in the future
* It's very frecuent to connect a signal with a method on current object. You can do it using +MTK_CONNECT_THIS+  see <<ex_mtk_connect_this, ex_mtk_connect_this>>
* You can connect one signal to another signal see <<ex_signal2signal,ex_signal2signal>>
* You can also connect one signal to a function <<ex_signal2function, ex_signal2function>>
* It's possible to disconnect a slot while processing a signal on this slot
* You can disconnect all slots while processing a signal on one of them
+
.Small example with SignalSlot
[source,{cpp}]
----
include::../../examples/onefile/support/ex_signal_slot.cpp[]
----
+
[[ex_mtk_connect_this, ex_mtk_connect_this]]
* In order to use +MTK_CONNECT_THIS+ you have to write in your class +typedef <classname> CLASSNAME;+
+
.Example MTK_CONNECT_THIS
[source,{cpp}]
----
include::../../examples/onefile/support/ex_mtk_connect_this.cpp[]
----
+
[[ex_signal2signal, ex_signal2signal]]
* Connecting a signal to another signal...
+
.Example ex_signal2signal
[source,{cpp}]
----
include::../../examples/onefile/support/ex_signal2signal.cpp[]
----
+
[[ex_signal2function, ex_signal2function]]
* Connecting a signal to a function
+
.Example ex_signal2function
[source,{cpp}]
----
include::../../examples/onefile/support/ex_signal2function.cpp[]
----
* Small test
+
.test SignalSlot
[source,{cpp}]
----
include::../../examples/onefile/support/test_signal_slot.cpp[]
----
+
.test PERFORMANCE SignalSlot
[source,{cpp}]
----
include::../../examples/onefile/support/test_performance_signal_slot.cpp[]
----
+
.test resources SignalSlot
[source,{cpp}]
----
include::../../examples/onefile/support/test_resources_signal_slot.cpp[]
----




=== Asyncrhonous signaling
  support/asynch_signal.hpp

* It has a emit method as +mtk::Signal+
* It also has a signal in the interface and you can use it to connect
* You can call emit (or connect a signal to it) method, and it will throw the signal asynchronously
* You can configure the maximum time to receive the events

--
async_signal_last::
* It will throw last signal


async_signal_all::
* It will rethrow all signals with the maximum speed configured on constructor
--

.Example ex_asynch_signal
[source,{cpp}]
----
include::../../examples/onefile/support/ex_asynch_signal.cpp[]
----





=== mtk_string
  support/mtk_string.h

[[MTK_SS,MTK_SS]]
Concatenating  MTK_SS::
* Using operator + to concatenate string is a bad idea
** ++"concatenating" + var++ will work if var is +std::string+, but you will get wrong results (even beatifull verses) if var is a number or char* or any other pointer
* The proposal is to write... +MTK_SS("concatenating" << var)+
* It will work allways as spected without problems or surprises

Converting to string  MTK_SS::
* Having several functions to convert to string is not confortable and tedius
* The proposal is to use... +
  +std::string s2 = MTK_SS("this is a const char*);+ +
  +std::string s2 = MTK_SS(8);+ +
  +std::string s2 = MTK_SS(mtk::dtNowLocal());+ +

Converting to string and concatenating  MTK_SS::
  +std::string s1 = MTK_SS("const char*" << std::string("std::string") << 88 << 99.8 << std::endl);+  +

* To work with +MTK_SS+ is necessary to work with types with operator +<<+ overloaded for std streaming (not very dificult requerement)
+
[WARNING]
If +MTK_SS+ is used recursivily, you have to add a literal param in order to remove a gcc warning +
+MTK_SS(5 << "lkjlkj" << MTK_SS("hkjhkjh" << std::endl, A))+


Converting from std::string to datatype  s_try_stoxxx::
* This set of functions will convert from string to a specific type
* You will provide a default value en case the conversion fail
* The function will return a +tuple+ of two elements
** If conversion fail, first element will have the default value and second false
** If conversion works, first elemente will be converted and second element true

Utilities::
* +s_trim+
** You will give the string to remove chars, and the char to remove or a set of chars to remove +
  First option has a better performance
* +s_split+
** This function will return a +vector<string>+ spliting the string with the specified char
* +s_toLower  s_toUpper+
* +s_AlignLeft s_AlignRight+
* +s_normalizeUTF8+
--
* Examples and test...
+
.mtk_string.h
[source,{cpp}]
----
include::../../src/support/mtk_string.h[]
----
+
* Example try conversions functions
+
.ex_string_try.cpp
[source,{cpp}]
----
include::../../examples/onefile/support/ex_string_try.cpp[]
----
+
* Test string_trim
+
.test_string_trim.cpp
[source,{cpp}]
----
include::../../examples/onefile/support/test_string_trim.cpp[]
----
--


=== stringCodec
  support/string_codec.h

There are two diferent ways to codec/decodec
--
CodecStringList::
* This one lets you to join a list in a string and split the string in the original list
* You can define the separator or use the default one
* In case of having a string with separator chars, stringCodec will use a scape character

CodecStringProperties::
* This lets you to join in a string couples of (name,value)
* You can split this pairs getting the original set (name, value)
--
* You can combine both and code list and property with names recursivily as many times you want
* Example with stringCodec
+
.ex_string_codec.cpp
[source,{cpp}]
----
include::../../examples/onefile/support/ex_string_codec.cpp[]
----
+
* Header file
+
.string_codec.h
[source,{cpp}]
----
include::../../src/support/string_codec.h[]
----


=== ConfigINI
  support/configini.h

* This class is manteined for compatibility with config files +.ini+ of windows
* Is better to use <<ConfigFile,ConfigFile>>
* Lines starting with +;+ or +#+ are comments
* The file will be saved on file when calling +Write+ or object is out of scope
+
.configini.h
[source,{cpp}]
----
include::../../src/support/configini.h[]
----
+
* You have to give the file name on constructor
* It's possible
** To get all sections
** Get a value
** Modify a value
** Get all properties for a section
** Delete a value
* Example file
+
.ex_configini.cpp
[source,{cpp}]
----
include::../../examples/onefile/support/ex_configini.cpp[]
----



[[ConfigFile,ConfigFile]]
=== ConfigFile
  support/configfile.h

It uses +hp+ and +re+  [red]#link pending#

IMPORTANT::
*Configuration files has to be small* +
* This is not to save large datas
* The parser doesn't work in stream mode, it will load all the file, will create de AST, will cut branches...
* To save huge datas, use a database or +yaml+ [red]#link pending#
* Access to config files has not been frecuent

AIM::
* Saving couple property value in a file
* There is also supported list
* Hierarchy structure
* Easy and direct access to a value to read or write without knowing the full document structure
* Keep the manual coments and carry returns
* Keep +nodes+ and +properties+ order
* On save, the system will format the file
** Brakes alone in one line and properly idented
** It will remove spaces between properties and values
* This class works only with strings
* Reading will retrurn +nullable+ type to make a diference between is emtpy and there is no value
* There is supported substitution
** A susbtitution is defined by +$(<property_to_replace>)+
** The system will look for +property_to_replace+ on same config file to replace in value string (see example below)

File structure::
* Property-value will be in a line
* The property will be separated of value by +:+
* Comments can be on one line or at end of line
* Comments starts by +#+ till end of line
* Nodes (sections) will have property-values and/or other nodes
* Node content is limited by brackets +{ }+
* Node name and node property has to match... ++^([a-zA-Z0-9\\-\\.]+)$++
** leters +a-z+ upper or lower case
** Numbers
** +-+  (minus)
** +_+  (underscore)
* Values cannot have carry return (+\n+ or +\r+) neither +' #'+ (look there is a space before # symbol)
* Symbol '~' means no value +
  In this case, the system will return a empty string
* If a property is writted empty, this property will be deleted
* If a property doesn't exist, a null nullable will be returned
* *Variables*
** When the value of a property has a text closed by +$( )+, this text will be replaced by the value of the property writted inside
** If it's not possible, an exception will be throwed
** A property can have several variables to expand
** There is not supported nested variables
** Variables expansion is limited in order to avoid infinite loops

* *LISTS*
** A list is a property but values are closed with +[ ]+ and each element is in a diferent line
** Inside a list, you cannot write line comments neither end of line comments
** Empty lines are part of list (empty element)
** List elements will not have spaces at the beginig (all left spaces are removed on reading)

File example::
+
.config_saved.cfg
----
include::../../examples/onefile/support/config_saved.cfg[]
----
+
* The original file, with bad identation is...
.config.cfg
+
----
include::../../examples/onefile/support/config.cfg[]
----


Header file::
+
.configfile.h
[source,{cpp}]
----
include::../../src/support/configfile.h[]
----



File example 2::
+
.config_saved2.cfg
----
include::../../examples/onefile/support/config_saved.cfg[]
----
+
* The original file, with bad identation is...
.config2.cfg
+
----
include::../../examples/onefile/support/config2.cfg[]
----


Program example::
+
.ex_configfile.cpp
[source,{cpp}]
----
include::../../examples/onefile/support/ex_configfile.cpp[]
----


Program testing::
You can see the testing program...
+
-------
examples/onefile/support/test_configfile.cpp
-------
//+
//.test_configfile.cpp
//[source,{cpp}]
//----
//include::../../examples/onefile/support/test_configfile.cpp[]
//----



=== ControlFluctuaciones
  support/controlfluctuaciones.h

--
ControlFluctuacionesSingle::
* +CheckFluctuation (dtTimeQuantity tqSender);+

ControlFLuctuacionesMulti::
* +CheckFluctuation (T id, dtTimeQuantity tqSender);+
--
* It will check fluctuations between two consecutive messages and five minuts interval (with dinamyc adjustment)
* Check fluctuation will return a tuple with both kind fluctuations
--
Header::
+
.controlfluctuaciones.h
[source,{cpp}]
----
include::../../src/support/controlfluctuaciones.h[]
----

--
Example::
+
.Example control fluctuaciones
[source,{cpp}]
----
include::../../examples/onefile/support/ex_controlfluctuaciones.cpp[]
----



=== Timer
  support/timer.cpp

--
* There are three timers with diferent frecuencies (10, 100, 1000 milliseconds)
* Each one will emit a signal
* You can connect your funcion or method to the apropiate signal
* If you need the execution of a method each 6 seconds for example, you will connect timer on second and you will write +MTK_EXEC_MAX_FREC(dtSeconds(6))+
* If a exception hapen processing a timer, the library will catch it and will call to +mtk::AlarmMesssage+
--
Start and stop timer::
+
[source,{cpp}]
-------------
void start_timer_wait_till_end(void);
void stop_timer(void);
------------

Example::
+
.Example timer
[source,{cpp}]
----
include::../../examples/onefile/support/ex_timer.cpp[]
----

Macros::
+
[cols="," , options=""]
|============================
| MTK_TIMER_1S +
(__METHOD_NAME1__)  | Connecting timer 1sec to a method (instance object)

| MTK_TIMER_1S_STOP +
(__METHOD_NAME1__) | Stop timer 1 sec to a method

| MTK_TIMER_1C +
(__METHOD_NAME1__) | Connect timer 100 millisecs to a method

| MTK_TIMER_1C_STOP +
(__METHOD_NAME1__) | 

| MTK_TIMER_1D +
(__METHOD_NAME1__) |  Connect timer 10 milliseconds to a method

| MTK_TIMER_1D_STOP +
(__METHOD_NAME1__) |

| MTK_TIMER_1SF +
(__FUNCTION__) |   Connect timer 1000 millisecs function 

| MTK_TIMER_1SF_STOP +
(__FUNCTION__) |

| MTK_TIMER_1CF +
(__FUNCTION__) |

| MTK_TIMER_1CF_STOP +
(__FUNCTION__) |

| MTK_TIMER_1DF +
(__FUNCTION__) |

| MTK_TIMER_1DF_STOP +
(__FUNCTION__) |

|============================



[[MTK_CALL_LATER,MTK_CALL_LATER]]
=== CallLater
  support/call_later.h

--
* Used to program a call to a method or function afetr x time
* It will produce only one call
* You can specify the frecuency and precission of the call
* You don't have to use it to produce asyncronous calls, for that, try with +AsyncDelayedCall+
* The function/method called 
** Has to return a void
** Has to receive a param as a const reference +
   If you don't need it, declare a +int+ param and configure with 0
** The param type, has to be copiable
--

Macro name description::
* Calling to a object method...
+
-----
  MTK_CALL_LATER1S_THIS(mtk::dtSeconds(5), 11, CallAfter5s)
-----
+
[cols="," , options=""]
|============================
| MTK_CALL_LATER**1S**_THIS +
(mtk::dtSeconds(5), 11, CallAfter5s)  |  1 sec precision

| MTK_CALL_LATER1S_**THIS** +
(mtk::dtSeconds(5), 11, CallAfter5s)  | calling to a object method using +CLASS_NAME*

| MTK_CALL_LATER1S_THIS +
(**mtk::dtSeconds(5)**, 11, CallAfter5s)  |  Call after 5 seconds

| MTK_CALL_LATER1S_THIS +
(mtk::dtSeconds(5), **11**, CallAfter5s)  |  Send param 11 in call

| MTK_CALL_LATER1S_THIS +
(mtk::dtSeconds(5), 11, **CallAfter5s**)  |  Call to function  +CallAfter5s+

|============================
+
* Calling to a object function...
+
-----
  MTK_CALL_LATER1S_F(mtk::dtSeconds(5), 11, CallAfter5s)
-----


Connect with no macro::
+
-----
idt::CallLaterFactory1S(idt::dtSeconds(6), 3.1415926535).connect(this, &TestCallLater::CallAfter6stwice);
-----
+
* Using MTK_CONNECT_THIS
+
-----
MTK_CONNECT_THIS(idt::CallLaterFactory1S(idt::dtSeconds(6), 1.42),  CallAfter6stwice)
-----
+
* Connectig to a function
+
-----
idt::CallLaterFactory1S(idt::dtSeconds(2), 11).connect(callLaterInt);
-----

Example::
+
.Example MTK_CALL_LATER
[source,{cpp}]
----
include::../../examples/onefile/support/ex_call_later.cpp[]
----





=== AsyncDelayedCall
  support/async_delayed_call.h

--
* It converts a method or function to work in asyncronous and delayed way 
* The method to transform has to:
** Return a void
** Receive only one parameter
** The param, has to be copiable
** If you need to receive more params, try with tuples
* The transformed method, will return inmediatly without doing his job at this moment (syncronous vs asyncronous)
* The pendings work will be done at configured speed
* Obiously, exceptions cannot be catched by caller
* Instead of, those exceptions will be sent to mtk::AlarmMsg
* On field +sourceCode+ from +mtk::Alarm+ will be writted the method converted name
* All will be executed on same thread
* It uses +mtk::Timer+ with precission of 100 miliseconds
* It could be applied in...
** Writting on db
** Sending alarms by network
** Sending responses to monitoring system
** Writting in log
** In general, in any case when is not critical an inmediate response and we don't want to stop others activities more criticals
* There are macros to combine declaration and implementation or doing it separatly
** If you split declaration and implementation and parameters doesn't match, it will not compile (and I'm not resposible of error messages from compiler)
--
Params::
+
-----
ASYNC_DELAYED_CALL_DI(METHOD_NAME, PARAM_TYPE, QTY, TIME_INTERVAL, MAX_QUEUE_SIZE)
-----

TODO::
* Having a way to request for descarted or error messages, exceptions, overflows
* Configure a maximun frecuency of error notifications. This speed has to bee lower than processing messages and it will help to avoid infinites loops
* The call created by macro (wicth will be call asynchronously to do the work) would have to be constant. +
  For that, +mtk::SignalSlot+ has to work with +const+ methods
* Extend the macros to support funcions
* Checking parameters to detect an cancel too agresives ones

Restrictions::
* It's not possible to use types with commas (templates i.e.)
* In those cases, you have to use a +typedef+
+
----
 typedef idt::tuple<std::string, std::string> t_asdcpar_Sufix_Message;
 ASYNC_DELAYED_CALL_D(InternalSendCommandResponse, t_asdcpar_Sufix_Message, 3, idt::dtMilliseconds(1000), 500);
----
+
* Params on methods, cannot be constants references
* The param type has to be copiable


==== Examples
* Transforming a program

Original syncronous program::
+
[source,{cpp}]
----
    #include <iostream>


    class Pr
    {
        public:

            void MandaNumero(int p)
            {

                std::cout << std::endl << p;
            }

    };




    int main()
    {
        Pr pr1;


        //  EJECUCIÓN SÍNCRONA  ("NORMAL")
        for(int i=0; i<205; ++i)
        {
            std::cout << std::endl << "Que lo mandoooo..."  << i;
            pr1.MandaNumero(i);
        }


    }
----



Async program::
+
.ex_asyn_call_delay.cpp
[source,{cpp}]
----
include::../../examples/onefile/support/ex_asyn_call_delay.cpp[]
----
<1> Header
<2> This class will receive signals
<3> +CLASS_NAME+ definition for some macros
<4> This method will trap async errors
<5> Here is protetted the original or normal method name (as documentation)
<6> Here is the same transformed to work asynchronously
<7> End implementation of async method
<8> Here we call several times very fast +
    Look that we call more than maximun configured


Separating implementation and definition::
+
[source,{cpp}]
----
    class Pr  : public idt::SignalReceptor
    {
        ...

        #if NO_COMPILAR
        void MandaNumero(int p)
        #endif
        ASYNC_DELAYED_CALL_D(MandaNumero, int, 5, idt::dtMilliseconds(100), 200);


    };




    void Pr::ASYNC_DELAYED_CALL_I(MandaNumero, int, 5, idt::dtMilliseconds(100), 200)

        std::cout << std::endl << p;

    ASYNC_DELAYED_CALL_END_I
-----


