= Messages

Here we have the messages definitions (and in some cases the state diagrams) from component messages.



[width="75%", cols="1, 2" , options=""]
|==========================================================
| lib version |  **
include::../../../VERSION[]
**

| Writter   |   Jos√© Luis Esteban

| Creation date |   2011-05-16

| Generated |   {docdate} {doctime}

| Doc name | {docname}

| Doc dir | {docdir}

| Doc file | {docfile}


|========================================================

<<<





//////////////
[jle_temp_and_run]
++++++++++++++++++++++++
run=[('python generate_messages_doc.py', 'generate_messages_doc.txt', 'wt')]

print ''

file_name='generate_messages_doc.py'


# this is our testing script
import os
import re



def process_path(path) :
    dirList=os.listdir(path)
    for fname in dirList:
        full_name = os.path.join(path, fname)
        if os.path.isdir(full_name)  and  fname != 'tools':
            process_path (full_name)
        else :
            if os.path.splitext(fname)[1] == '.msg' :
                file_msg = re.match('.*/components/(.*)', full_name)
                print '== ' + file_msg.group(1) + '\n'
                ##print full_name +'\n'
                print '---------'
                print 'include::' + full_name + '[]'
                print '---------\n\n'
    
    
    
   
process_path('{docdir}/../../../src/components')


+++++++++++++++++++++++++

include::/tmp/adoc/generate_messages_doc.txt[]

//////////////



== General INFO


=== Levels

--
. *SYS* Servers with logic
.. *MK* Market servers
.. *GS*  General servesr
. *CLI* Terminals and servers for them
.. *TS*, *CS*, *CTS*  Terminal servers, client servers, client terminal servers
. *TERMINALS*
--

=== QUEUES/EXCHANGES

See topology later

Production::
* ALL_GS
* CLI_MK
* PRICES.<market>
* LOCAL

Testing::
Same as production ended with TESTING



=== Addresses/routing-keys

ALL_GS::
Messages between +GS+ and +ALL+  in any direction. +
In some cases, in order to avoid creation of an aditional addresses, a +MK+ or +SYS+ can send a message to itself with this address
+
[cols="1, 1, 3" , options=""]
|=====================
| ALL.<broker_code>.#  |  GS->ALL | This messages will be sent to all servers (included TS) +
                                <gs_name> is the +GS+ generator of message +
                                Necessary to filter to avoid duplicated paths
| SYS.<broker_code>.#            |  GS->SYS |  Internal messages to spread on +SYS+ level

| CLI.<cli_code>.# |  GS->CLI | confirmations, responses, ...
| GS.<cli_code>.#  |  CLI->GS | request from client (password, grants, ...) +
                                This format is for client request +
                                The <cli_code> is used to filter on +CS+
| GS.<broler_code>.#             |  ALL->GS  |  comunication to +GS+ from other servers

| MK.<market>.#    |  GS->MK | Market is used to filter for specific server +
                                ps_conf, ps_req, ... +
|=====================

CLI_MK::
+
[cols="1, 1, 3" , options=""]
|=====================
| CLI.<client_code>.#    |  MK->CLI |   Messages to client and +GS+ +
                                      client will be filtered con +CS+ +
                                      trading confs, cli res, ...
| CLI.ALL.#              |  MK->CLI |   Messages to all clients and +GS+  generated from +MK+ 
| MK.<client_code>.#     |  CLI->MK |   Messages from clients and +GS+  generated +
                                      <client_code> will be filtered con +CS+
| MK.(OMS\|PS).<market># | SYS->MK |   Messages to market servers generated on +SYS+

|=====================


PRICES.<market>::
+
[cols="1, 1, 3" , options=""]
|=====================
| #  |  MK->(CLI\|GS) |   prices broadcast
|=====================




// * +PUB+ will be used on messages sent to many. Broadcast with no response and therefore no end response
// * +CONF+ to send messages to many but they depend from any request or previus suscription information and the suscription is  _permanent_. +
//   Orders confirmation for example
// * +REQ+ is for request responses and request confirmation patterns
// * +REP+ responses of request response pattern. _Non permanent_ suscriptions


=== Message name convention
|=====================
| req_...   |    request (not necessarily request response, could be a request confirmation)
| res_...   |    responses (from request responses)
| conf_...  |    confirmations (as order confirmations)
| pub_...   |    publications (as prices, keepalives, etc...)
| |
| oms_ ...  |    oms prefix means internal Order Management System message (not client)
| ps_ ...   |    ps prefix means internal price system message (not client)
|=====================


=== QUEUES/Exchanges Topology


* Names are defined as path from point to point
* This doesn't mean, the message has to be initiated and received on both path extremes
* The message can be initiated on an intermediate point and can be consumed before the end point

[TIP]
Dotted lines mean filtered routes

PRICES.<market>::
* This is a one direccion *dynamic* exchange route
* This is a special case with LVQ queues
* Information starts on market connections and is distribuited to terminals
* i.e. prices
["graphviz", "queue_topology_prices.png"]
-----------
digraph queue_topology_prices
{
	// rankdir = LR;
node [shape=box];  T1; T2, T3, Tn, Tn2, TCA1, TCA2, TCB1, TCB2, TCB3, TCC1
node [shape=ellipse];  
subgraph cluster_cimd {

   subgraph cluster_system {
           label = "system";
           EU     ->  {SG1, SG2}

   }

   subgraph cluster_terminal_servers {
           label = "";
           style=filled;
	color=lightgrey;
           ST1, ST2, STC1, STC2
           EU     ->  { ST1, ST2, STC1, STC2 }

   }


    ST1 ->  { T1, T3, Tn }

    ST2 ->  { T2, Tn2 }

    STC1 -> { STC_A, STC_B }

    STC2 -> STC_C

    label = "cimd";
}

  STC_A  ->  { TCA1, TCA2 }

  STC_B  ->  STC2_B

  STC2_B->  { TCB1, TCB2, TCB3 }

  STC_C->  TCC1
}
------------




ALL_GS::

ALL.<broker_code>.#;;
* Messages generated on +GS+ to all clients and servers
+
["graphviz", "queue_topology_all_gs__all.png"]
-----------
graph queue_topology_prices
{
	// rankdir = LR;
	
subgraph cluster_cimd {

   subgraph cluster_system {
           label = "system";
           MK GS1 GS2

          GS1 -- GS2 [ dir= both, color=red, style=dotted ]

          MK -- { GS1, GS2 }    [dir=back, style=dotted];

   }
      subgraph cluster_terminal_servers {
           label = "";
           style=filled;
	color=lightgrey;

           {GS1, GS2} -- { TS, CS } [dir=forward, style=dotted]

      }

    CS -- CTSx  [dir=forward]

    label = "cimd";
}


}
------------


SYS.<broker_code>#;;
* Messages generated on +GS+ or servers to +SYS+
+
["graphviz", "queue_topology_all_gs__sys.png"]
-----------
graph queue_topology_prices
{
	// rankdir = LR;
	
subgraph cluster_cimd {

   subgraph cluster_system {
           label = "system";
           MK GS1 GS2

          MK -- { GS1, GS2 }    [dir=back];
          GS1 -- GS2   [dir=back, style=dotted];
          GS2 -- GS1   [dir=back, style=dotted];
   }
      subgraph cluster_terminal_servers {
           label = "";
           style=filled;
	color=lightgrey;

           {GS1, GS2} -- { TS, CS } [dir=back, style=invis]

      }

    CS -- CTSx [dir=back, style=dotted, style=invis]

    label = "cimd";
}


}
------------






CLI.<cli_code>.#;;
* Messages generated on +GS+ to clients
+
["graphviz", "queue_topology_all_gs__cli.png"]
-----------
graph queue_topology_prices
{
	// rankdir = LR;
	
subgraph cluster_cimd {

   subgraph cluster_system {
           label = "system";
           MK GS1 GS2

          MK -- { GS1, GS2 }    [dir=back, style=invis];

   }
      subgraph cluster_terminal_servers {
           label = "";
           style=filled;
	color=lightgrey;

           {GS1, GS2} -- { TS, CS } [dir=forward]

      }

    CS -- CTSx [dir=forward]

    label = "cimd";
}


}
------------



GS.#;;
* Messages generated on clients, servers or gs processes to +GS+
+
["graphviz", "queue_topology_all_gs__gs.png"]
-----------
graph queue_topology_prices
{
	// rankdir = LR;
	
subgraph cluster_cimd {

   subgraph cluster_system {
           label = "system";
           MK GS1 GS2

          MK -- { GS1, GS2 }    [dir=forward];
          GS1 -- GS2   [dir=back, style=dotted];
          GS2 -- GS1   [dir=back, style=dotted];

   }
      subgraph cluster_terminal_servers {
           label = "";
           style=filled;
	color=lightgrey;

           {GS1, GS2} -- { TS, CS } [dir=back]

      }

    CS -- CTSx [dir=back, style=dotted]

    label = "cimd";
}


}
------------





MK.<market>.#;;
* Messages generated on +GS+ or servers to +MK+
+
["graphviz", "queue_topology_all_gs__mk.png"]
-----------
graph queue_topology_prices
{
	// rankdir = LR;
	
subgraph cluster_cimd {

   subgraph cluster_system {
           label = "system";
           MK GS1 GS2

          MK -- { GS1, GS2 }    [dir=back, style=dotted];

   }
      subgraph cluster_terminal_servers {
           label = "";
           style=filled;
	color=lightgrey;

           {GS1, GS2} -- { TS, CS } [dir=back, style=invis]

      }

    CS -- CTSx [dir=back, style=dotted, style=invis]

    label = "cimd";
}


}
------------









CLI_MK::

CLI.<cli_code>|ALL.#;;
* Messages generated on +MK+ to clients and +GS+
+
["graphviz", "queue_topology_cli_mk__cli.png"]
-----------
graph queue_topology_prices
{
	// rankdir = LR;
	
subgraph cluster_cimd {

   subgraph cluster_system {
           label = "system";
           MK GS1 GS2

          MK -- { GS1, GS2 }    [dir=forward];

   }
      subgraph cluster_terminal_servers {
           label = "";
           style=filled;
	color=lightgrey;

          MK -- { CS, TS }    [dir=forward];
      }

    CS -- CTSx  [dir=forward, style=dotted]

    label = "cimd";
}


}
------------





MK.<client_code>|PS|OMS.<market>.#;;
* Messages generated on +CLI+ to a market and +GS+
+
["graphviz", "queue_topology_cli_mk__mkcc.png"]
-----------
graph queue_topology_prices
{
	// rankdir = LR;
	
subgraph cluster_cimd {

   subgraph cluster_system {
           label = "system";
           MK GS1 GS2

          MK -- { GS1, GS2 }    [dir=forward];

   }
      subgraph cluster_terminal_servers {
           label = "";
           style=filled;
	color=lightgrey;

          MK -- { CS, TS }    [dir=back, style=dotted];
      }

    CS -- CTSx  [dir=back, style=dotted]

    label = "cimd";
}


}
------------


MK.<client_code>.ALL.#;;
* Messages generated on +CLI+ to all market and +GS+
+
["graphviz", "queue_topology_cli_mk__mkcc.png"]
-----------
graph queue_topology_prices
{
	// rankdir = LR;
	
subgraph cluster_cimd {

   subgraph cluster_system {
           label = "system";
           MK GS1 GS2

          MK -- { GS1, GS2 }    [dir=forward];

   }
      subgraph cluster_terminal_servers {
           label = "";
           style=filled;
	color=lightgrey;

          MK -- { CS, TS }    [dir=back];
      }

    CS -- CTSx  [dir=back, style=dotted]

    label = "cimd";
}


}
------------











=== YAML support
* All generated messages and submessages overload operators +>>+ and +<<+ with +YAML+ classes





include::request_response_pattern.adoc[]


== Common

.Common submessages for several kind of components
-----
include::../../../src/components/msg_common.msg[]
-----

.Support code for common messages
-----
include::../../../src/components/msg_common_support.h[]
-----


== Admin

.components/admin/msg_admin.msg
-----
include::../../../src/components/admin/msg_admin.msg[]
-----



== ACS

* Access Control System


=== Client side

.Orders LS status diagram
["graphviz", "fsm_cli_acs.png"]
-----------
include::../../../src/components/acs/cli/fsm_cli_acs.dot[]
------------

.components/acs/msg_acs.msg
-----
include::../../../src/components/acs/msg_acs.msg[]
-----



== Tree server (product list)

* There is no reject message or code
* If not configured or not granted, there will not be response
* This behaivor lets to configure several +tree_servers+ for diferent users, having the posibility to show diferent trees to diferent users
+
.components/gen/msg_tree_server.msg
[source,{cpp}]
----
include::../../../src/components/gen/msg_tree_server.msg[]
----




== Trading

=== Common

* Inheritance diagram with some messages

["graphviz", "trading_inheritance_diagram0.png"]
-----------
digraph trading_inheritance  {
    rankdir=LR;
    node [shape = circle, fontsize=10, fixedsize=true width=0.8];

    RQ_XX
    CF_XX  ->  RJ_XX
}
-----------

["graphviz", "trading_inheritance_diagram1.png"]
-----------
digraph trading_inheritance {
    rankdir=LR;

    node [shape = circle, fontsize=10, fixedsize=true width=0.8];

    RQ_XX  ->  RQ_XX_LS
    RQ_XX_LS  ->  RQ_NW_LS  
    RQ_XX_LS  ->  RQ_MD_LS
    RQ_XX_LS  ->  RQ_CC_LS

    RQ_XX  ->  RQ_XX_MK
    RQ_XX_MK  ->  RQ_NW_MK
    RQ_XX_MK  ->  RQ_MD_MK
    RQ_XX_MK  ->  RQ_EX_MK

    RQ_XX  ->  RQ_XX_SL
    RQ_XX  ->  RQ_XX_SM

}
-----------

["graphviz", "trading_inheritance_diagram2.png"]
-----------
digraph trading_inheritance {
    rankdir=LR;

    node [shape = circle, fontsize=10, fixedsize=true width=0.8];

    CF_XX  ->  CF_XX_LS
    CF_XX_LS  ->  CF_NW_LS  
    CF_XX_LS  ->  CF_MD_LS
    CF_XX_LS  ->  CF_EX_LS

    CF_XX  ->  CF_XX_MK
    CF_XX_MK  ->  CF_NW_MK
    CF_XX_MK  ->  CF_MD_MK
    CF_XX_MK  ->  CF_EX_MK

    CF_XX  ->  CF_XX_SL
    CF_XX  ->  CF_XX_SM

    CF_XX_LS  ->  RJ_NW_LS  
    CF_XX_LS  ->  RJ_MD_LS
}
-----------



* Common submessages for trading
+
.src/components/trading/msg_trd_common.msg
-----
include::../../../src/components/trading/msg_trd_common.msg[]
-----


* Support code for trading client messages
+
.src/components/trading/msg_trd_common_support.h
-----
include::../../../src/components/trading/msg_trd_common_support.h[]
-----

=== Account manager
.mtk/src/components/trading/accounts/msg_account_manager.msg
[source,{cpp}]
----
include::../../../src/components/trading/accounts/msg_account_manager.msg[]
----


=== Limit orders

* Online trading Limit Orders client messages
+
.msg_trd_cli_ls.msg
-----
include::../../../src/components/trading/msg_trd_cli_ls.msg[]
-----


* Orders LS status diagram
+
["graphviz", "components_trading_o_ls.png"]
-----------
include::../../../src/components/trading/trd_cli_ls.dot[]
------------


=== Market orders

* Online trading +market+ Orders client messages
+
.msg_trd_cli_mk.msg
-----
include::../../../src/components/trading/msg_trd_cli_mk.msg[]
-----


* Orders MK status diagram
+
["graphviz", "components_trading_o_mk.png"]
-----------
include::../../../src/components/trading/trd_cli_mk.dot[]
------------




=== OMS

* Trading Limit Orders OMS messages (added permision filter fields)
. msg_trd_oms_rq.msg
+
-----
include::../../../src/components/trading/msg_trd_oms_rq.msg[]
-----



//:leveloffset: 1
//include::../../../src/doc.adoc/components/prices_system.adoc[]
//:leveloffset: 0

== Prices System


This is a general idea of organization of prices and products publishing



=== General diagram

.DFD
["graphviz", "tree_items_dfd0.png"]
-----------
digraph dfd0_graph {
 rankdir=LR;
 nodesep=0.3
 ranksep = 1.5
 // Nodos
 node [fontsize=16];
 CLIENT [label="\n\nC\n\nL\n\nI\n\nE\n\nN\n\nT\n\n" shape=box height=4];
 price_system [label=" price_system " shape=circle height=3]
 MARKET [label="\n\nM\n\nA\n\nR\n\nK\n\nE\n\nT\n\n" shape=box height=4];
 // Conectores
 edge [fontsize=12];

 CLIENT -> price_system [label = "req_tree_items" ];
 price_system -> CLIENT [label = "res_tree_items" ];
 price_system -> CLIENT [label = "pub_tree_colapse_branch" ];


 CLIENT -> price_system [label = "req_prod_info" ];
 price_system -> CLIENT  [label = "res_prod_info" ];
 price_system -> CLIENT  [label = "pub_(marg,depth,trades...)" ];
 price_system -> CLIENT  [label = "pub_product_stopped" ];
 price_system -> CLIENT  [label = "pub_market_stopped" ];
 price_system -> CLIENT  [label = "pub_new_products" ];


 price_system -> MARKET  [label = "ps_req_init_prod_info_fp" ];
 MARKET  ->  price_system   [label = "ps_pub_prod_info_mtk_ready_fp" ];
 MARKET  ->  price_system   [label = "ps_conf_full_product_info_init_fp" ];
 MARKET  ->  price_system   [label = "ps_conf_full_product_info_fp" ];
 MARKET  ->  price_system   [label = "(cli) pub_(marg,depth,trades...)" ];
 MARKET  ->  price_system   [label = "(cli) pub_product_stopped" ];
 MARKET  ->  price_system   [label = "(cli) pub_market_stopped" ];

}
-----


=== ProductInfoGrants

* This process will receive the process info request and will check if request has grants
* It will receive message +mtk::prices::msg::req_product_info+ and it will send +mtk::prices::msg::ps_req_product_info+ if there are grants

=== Tree Servers

* +tree_servers+ will receive the +rq_tree_items+ and they will send response to client
* +tree_servers+ will check permisions for +rq_tree_items+ and +rq_prod_info+
* If the request is not configurated on +tree_server+ or the user has no permision, the tree server will not reject the message
* This behavior gives the oportunity to a diferent +tree_server+ instance, to check and send response (if so). In this case, +tree_servers+ will work in parallalel
* A +tree_server+ could verify the request, and if it's ok, it could send this request to another +tree_server+ with the information to send the response. Working in pipeline
* The easiest case is when tree_server on level 1 send response directly
* When a +tree_server+ detects new products on tree, it will send a colapse brach (where new products were inserted)
+
.DFD  rq_tree_items  res_tree_items  option A
["graphviz", "tree_items_dfdA.png"]
-----------
digraph dfd0_graph {

node [shape=box width=1.7] CLIENT;
node [shape=circle, width=1.5] tree_server1;

CLIENT ->  tree_server1  [label = rq_tree_items ]
tree_server1  ->  CLIENT   [label = res_tree_items ]

}
-----

* This diagram shows +tree_servers+ working in pipe line
+
.DFD  rq_tree_items  res_tree_items  option B
["graphviz", "tree_items_dfdB.png"]
-----------
digraph dfd0_graph {

node [shape=box width=1.7] CLIENT;
node [shape=circle, width=1.5] tree_server1 tree_server2;

CLIENT ->  tree_server1  [label = rq_tree_items ]
tree_server1 ->  tree_server2  [label = rq_tree_items ]
tree_server2 ->  CLIENT  [label = rs_tree_items ]

}
-----


=== Product Loader

* +product_loader+ will keep products info in order to send a snapshot of an specific product
* They will work after +prodinfo_grants+. The +prodinfo_grants+ will check the permisions for each product info request.
* +product_loader+ will listen on client_side the messages +pub_(marg,depth,trades...)+ to build the status info per product
* It will listen on server side, messages +pub_full_product_info+ and +pub_end_product_info_init+ for a initialization
* When the process starts, it will send +req_init_prod_info+
** This message gives the oportunity to market price server, to start sendind initialization (i.e.)
* This process will listen to +pub_market_pubisher_ready+, to send +req_init_prod_info+ to publisher
+
.DFD  resquest response product info
["graphviz", "product_loaderA.png"]
-----------
digraph dfd0_graph {

node [shape=box width=1.7] CLIENT;
node [shape=circle, width=1.5] prodinfo_grants product_loader;

CLIENT ->  prodinfo_grants  [label = req_prod_info ]
prodinfo_grants ->  product_loader  [label = req_prod_info ]
product_loader ->  CLIENT  [label = res_prod_info ]

}
-----

=== DFD0

.DFD
["graphviz", "tree_items_dfd0a.png"]
-----------
digraph dfd0_graph {
 //rankdir=LR;
 nodesep=0.3
 ranksep = 1.5
 // Nodos
 node [fontsize=16];
 CLIENT [label="CLIENT" shape=box height=0.1];
 tree_server [label="tree\nserver" shape=circle height=1]
 prodinfo_grants [label="prodinf\ngrants" shape=circle height=1]
 product_loader [label="product\nloader" shape=circle height=1]



 conect_market_2_all [shape=circle,style=filled,label="ts pl\ncli",height=1]

 MARKET [label="MARKET" shape=box height=0.1];
 // Conectores
 edge [fontsize=12];



 CLIENT -> tree_server [label = "req_tree_items" ];
 CLIENT -> prodinfo_grants [label = "req_prod_info" ];

 tree_server -> CLIENT [label = "res_tree_items" ];
 tree_server -> CLIENT [label = "pub_tree_colapse_branch" ];
 tree_server -> product_loader  [label = "req_init_prod_info" color=red];
 prodinfo_grants -> product_loader [label = "req_prod_info\n(cli)" ];

 product_loader -> tree_server   [label = "ps_pub_prod_info_mtk_ready" color=red];
 product_loader -> tree_server   [label = "ps_conf_full_product_info_init\nps_conf_full_product_info" color=red];

 product_loader -> CLIENT  [label = "res_prod_info" ];

 product_loader -> MARKET  [label = "ps_req_init_prod_info" ];

 MARKET  ->  product_loader   [label = "ps_pub_prod_info_mtk_ready_fp" ];

 MARKET  ->  product_loader   [label = "ps_conf_full_product_info_init_fp\nps_conf_full_product_info_fp" ];

 MARKET  ->  conect_market_2_all   [label = "(cli) pub_(marg,depth,trades...)" ];
 MARKET  ->  conect_market_2_all   [label = "(cli) pub_product_stopped" ];
 MARKET  ->  conect_market_2_all   [label = "(cli) pub_market_stopped" ];
 MARKET  ->  conect_market_2_all   [label = "(cli) pub_new_products" ];

}
-----


=== Initialization

* Sequence
.. +product_loader+ starts
.. +market+  starts
+
["graphviz", "prices_system_init0.png"]
-----------
digraph dfd0_graph {
    prod_load0 [label ="prod\nload\nstart" shape=circle height=1];
    none0  [label ="" shape=circle height=1];
    market0    [label ="market\nstart" shape=circle height=1];
    prod_load1 [label ="prod\nload" shape=circle height=1];
    market1    [label ="market" shape=circle height=1];
    all  [label ="all" shape=circle height=1];


    prod_load0 ->  none0  [label = req_init_prod_info];
    none0  ->  market0 ;
    market0 -> prod_load1 [label = pub_market_loader_ready];
    prod_load1 ->  market1  [label = req_init_prod_info];
    market1  -> all [label = "pub_full_product_info\npub_(*)"];
}
-----------
* Same initialization between +product_loader+ and +tree_server+
** +product_loader+ will start sending a ready message
** +product_loader+ will start sending +pub_full_prod_info+ as soon as it receives a +req_init_prod_info+
** +tree_server+ will send a +req_price_recept+ on starting (just in case), and it will also send this message (if necessary) when receiving +pub_market_publisher_ready+
** And same with other pieces as +product2db+


=== Messages

.TreeServer messages
-----
include::../../../src/components/gen/msg_tree_server.msg[]
-----


.Product info
-----
include::../../../src/components/prices/msg_prices.msg[]
-----

.Product info internal to +priceSystem+
-----
include::../../../src/components/prices/msg_ps_prices.msg[]
-----






== Messages analysis

include::msg_analysis.msg[]

