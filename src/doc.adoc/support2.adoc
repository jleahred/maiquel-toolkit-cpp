:cpp: {basebackend@docbook:c++:cpp}


=== Factory
* This is a tool to create repositories of shared objects in diferent parts of program
* You will request with a +key+
* This key has to have defined the operator +<+
* The system will look if there are a previus instance of this object for the given +key+
** If so, it will return this instance.
** If not, it will create a new one.
* This tool returns a +mtk::CountPtr<xxx>+
** When no one is interested on this pointer, the +mtk::CountPtr+ will delete the instance
** On +factory+ will continue having the +mtk::CountPtr+, for the deleted +key+, but this pointer will be invalid
** Time to time, the +factory+ will remove the deleted pointers from index
* It's very easy to use +
  In order to create a new one, you only need to define the method +create_instance_for_factory+ as bellow

==== Example factory

[source,{cpp}]
----
include::../../examples/onefile/support/ex_factory.cpp[]
----
<1> An example class to test with factory
<2> Defining the factory create instance +
    That's all we need to do to work with factories
<3> A second example
<4> Creator instances for second example
<5> We request several instances of first object, but it will be instanciated just one
<6> Creating an instance for class 2

[IMPORTANT]
Getting references with factory is not cheap (it uses a map inside). +
You must avoid to use it on intensive executed code


=== HumbleParser
  support/hp/*

* This is a dinamyc descendent recursive parser +LL(n)+
* There are documentation on [red]#pending#
* On +tools/qt+ there are an application to write, test and view the generated +AST+ or the transformed code call +hpgui+
* You have examples in +examples/hp+

=== CheckScopeTime
  support/debug/checkscopetime

--
* This is a class to look for optimitations and wich part of code is consuming more time
* This tool can be combined with +cachegrind+
* The counter will stop automaticaly when the instance is out of scope
* You can also stop an restart the timer on a specific scope
* It will detect recursivity and will care of it doesn't add time in recursivity
* It will generate a minireport with all variables watched
--

Header::
+
.checkscopetime.h
[source,{cpp}]
----
include::../../src/support/debug/checkscopetime.h[]
----


Example::
+
.Example check_scope_time
[source,{cpp}]
----
include::../../examples/onefile/support/debug/ex_check_scope_time.cpp[]
----



=== Regular expresions
  support/re/*

* Library +PCRE+ (perl compatible regular expresions)
* There are a couple of modifications to compile directly (removed all compiler variables and we are using a table generated by +Ultimate+++
* This is not the official warpert for c++ developed by Google. We are using an adaptation from +Ultimate+++
+
Very basic example::
+
[source,{cpp}]
----
    //---------------------------------------------------------------------------
    #include <iostream>
    #include "support/re/RegExp.h"
    #include "support/mtk_string.h"



    int main(int argc, char* argv[])
    {
        mtk::RegExp re ("^(\\S+) +(.*)$");

        if (re.Match("mabe    ver"))
        {
            std::cout << std::endl << re.GetString(0);
            std::cout << std::endl << re.GetString(1);
        }
        else
            std::cout << std::endl << "no casa";

        std::cout << std::endl << "";


        return 0;
    }
    //---------------------------------------------------------------------------
----
+
Example separating a string with +;+::
+
[source,{cpp}]
----
    #include <iostream>
    #include "support/re/RegExp.h"
    #include "support/mtk_string.h"



    int main(int argc, char* argv[])
    {
        mtk::RegExp re ("([^;]+)");

        while (re.GlobalMatch("mabe;help;nivel;5"))
        {
            std::cout << std::endl << re[0];
        }

        std::cout << std::endl << "";


        return 0;
    }
    //-------------------------------------------------------------------------------
----


=== Integer compactor
  support/integer_compactor.h

* Generate and parse a buffer of integers compacting them
* Each element, can be saved with 1, 2, 3 or 4 bytes
* The number of bytes will depend on value of integer

Header::
+
.integer_compactor.h
[source,{cpp}]
----
include::../../src/support/integer_compactor.h[]
----


Example and unit test::
+
.Example integer compactor
[source,{cpp}]
----
include::../../examples/onefile/support/test_integer_compactor.cpp[]
----


=== bhvm  Basic Humble Virtual Machine
  support/re/*

==== What is it?
* This is a very simple and small virtual machine
* It has very few lines of code
* Perhaps is not a virtual machine, because it doesn't have arithmetic operations neither conditionals
* It's very easily extensible
* It works only with one data type +string+
* It doesn't have registers, only stack
* Due to reduced size (two file with 200 and 100 lines of code) it is added to support (probably will not be used very frecuent)

==== Machine instructions
*********
In the future, could be added a +end of program+ instruction
*********
push::
* This instruction has a parameter
* The parameter, is de string to add into statck

pop::
* Remove one element from stack

nop::
* Do nothing

jump::
* Get the stack top, and jump to the lablel contained on it

calle::
* Call external
* Read and remove the statck top element
* Verify that has been registered an element with same name
* Throw a signal joined to this command to execute external code

==== Program
* The program is introduced with...
+
-------
    void insert_push   (const std::string& data);

    void insert_pop    (void);
    void insert_nop    (void);
    void insert_calle  (void);
    void insert_jump   (void);

    void insert_instruction (const std::string& instruction);
-------
+
* Those instructions will be added to program memory on machine. +
  This memory is independent to stack and data memory
* When +execute_program+ is called, the machine will start by first line and will continue to last line

==== Jump labels
* They are defined with +define_label+
* +define_label+ will mach the label with the instruction
* Labels will be defined while program is loading

==== Output information
* Log on below signals
+
---------
    //  S A L I D A
    idt::Signal<const idt::Alarma&>        signal_error;
    idt::Signal<const idt::Alarma&>        signal_warning;
    idt::Signal<const idt::Alarma&>        signal_debug;
---------

==== Machine addings
* This is the most important behaviour of this machine
* Registering a external command to be call with +calle+
+
---------
    CountPtr< Signal<bhvm*> >
    register_external_command (const std::string& command);
---------
+
* To do it easier to write and read, you can use MTK_DVM_REGISTER_COMMAND
** Parameters:
*** Reference to the virtual machine
*** Internal command name
*** Command literal, the one will work on machine
*** Function to be called
+
------------
 IDT_HVM_REGISTER_COMMAND(machine, cmd_add       , "cmd:+"        , process_add            );
------------
+
* Execute commands
** It's possible to execute commands from outside machine
** This is unsecure but flexible
** The machine aim is not protection, is flexibility
* The typical commands to execute from outside program are:
** Get from stack
** Insert to stack
** Both are necessary to extend the machine
* Full commands execution from outside:
+
---------
    //  E J E C U C I Ã“ N   D E   I N S T R U C C I O N E S
    void exec_push   (const std::string& data);

    void exec_pop    (void);
    void exec_nop    (void);
    void exec_calle  (void);
    void exec_jump   (void);

    void exec_instruction (const std::string& instruction);
---------
+
* Next command will return the machine status (program address, stack values, etc...)
+
------------
   std::string  get_status     (void) const;
------------
+
* And next program will return stack size:
+
-------------
int          get_stack_size (void) const;
-------------


=== Example extending virtual machine
[red]#pending to generate dinamically results and compilations#

* To look and investigate look on folder +examples/bhvm/+
* On next example program, it will read standard input
* On +examples/bhvm/+ you also have a grammar which used with +dhp+ will generate our machine compiled code  +hellt_compiler.rules+
* There are also a link to +dhp+
* The makefile on this folder, will compile the program and will execute...
  cat program.hellt  | ./dhp hellt_compiler.rules | ./bhvmt.exec
* +dhp+ will receive the source code from program.hellt and will generate the compiled code for our machine. This code will be passed to +./bhvmt.exec+ who will execute it
* If you run +make play+ it will generate the virtual machine witout deleting it at end of execution (just in case you will be interested to play with it)

==== Running examples
Small expresion evaluation::
* Evaluation of math expresion with assignament  +def x as int; x := 1+2-9;+
* You can modify the program or introduce it directly from console or sending it with +echo+
+
-----------
$ echo 'def x as double; x:=1+2-9;' | ./dhp hellt_compiler.rules | ./bhvmt.exec
16:55:13.252 debug Unkown # end of program.
status
==========
program_counter:15
stack:

 @execute_program

status
==========
program_counter:15
stack:


vars
==========
x ==  double:-6
-----------
+
* At end, it will give information about end of program, machine status
* Look the stack is empty (in other case, there are problems)
* At end, var x has the value -6  (fantastic)
+
Compiled code::
+
--------------
$ echo 'def x as double; x:=1+2-9;' | ./dhp hellt_compiler.rules
push double:
push var:x
push cmd:defvar
calle
push double:1
push double:2
push cmd:+
calle
push double:9
push cmd:-
calle

push var:x
push cmd:write2var
calle

pop
--------------
+
Example with loop::
+
.Example extending virtual machine
[source,{cpp}]
----
include::../../examples/bhvm/program.hellt[]
----
+
* Output...
+
----
$ cat program.hellt | ./dhp hellt_compiler.rules | ./bhvmt.exec
17:02:34.754 debug Unkown # end of program.
status
==========
program_counter:54
stack:

 @execute_program

status
==========
program_counter:54
stack:


vars
==========
i ==  double:101
result ==  double:5050
----
+
* Program compiled
+
-----------
$ cat program.hellt | ./dhp hellt_compiler.rules
push double:
push var:i
push cmd:defvar
calle
push double:
push var:result
push cmd:defvar
calle
push double:0

push var:i
push cmd:write2var
calle

pop
push double:0

push var:result
push cmd:write2var
calle

pop
define_label:label:beginwhile
push label:endwhile
push label:whilesentence
push var:i
push cmd:read4var
calle


push double:101

push cmd:!=
calle

push cmd:if
calle
jump
define_label:label:whilesentence
push var:result
push cmd:read4var
calle

push var:i
push cmd:read4var
calle

push cmd:+
calle

push var:result
push cmd:write2var
calle

pop
push var:i
push cmd:read4var
calle

push double:1
push cmd:+
calle

push var:i
push cmd:write2var
calle

pop
push label:beginwhile
jump
define_label:label:endwhile
nop
-----------
+
* Example extending virtual machine
+
.examples/bhvm/bhvmt.cpp
[source,{cpp}]
----
include::../../examples/bhvm/bhvmt.cpp[]
----

