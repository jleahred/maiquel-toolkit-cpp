//  code generated by fsm_gen
// generated automatically
// coded last modification:        $CODED_LAST_MODIF  desactivated, lots of false notifications
// pythonscript last modification: $SCRIPT_LAST_MODIF



namespace fsmgen_trd_cli_mk {


class abstract_status;

// -----------------------------------------------------------------------
//      s t a t u s _ c o m m o n _ i n f o

struct  status_common_info
{
    status_common_info ( mtk::Signal<const mtk::trd::msg::RQ_NW_MK&   /*rq*/         >& _sig_rq_nw, mtk::Signal<const mtk::trd::msg::RQ_MD_MK&   /*rq*/         >& _sig_rq_md, mtk::Signal<const mtk::trd::msg::RQ_CC_MK&   /*rq*/         >& _sig_rq_cc, mtk::Signal<const mtk::trd::msg::RJ_NW_MK&   /*rj*/         >& _sig_rj_nw, mtk::Signal<const mtk::trd::msg::RJ_MD_MK&   /*rj*/         >& _sig_rj_md, mtk::Signal<const mtk::trd::msg::RJ_CC_MK&   /*rj*/         >& _sig_rj_cc, mtk::Signal<const mtk::trd::msg::CF_NW_MK&   /*cf*/         >& _sig_cf_nw, mtk::Signal<const mtk::trd::msg::CF_MD_MK&   /*cf*/         >& _sig_cf_md, mtk::Signal<const mtk::trd::msg::CF_CC_MK&   /*cf*/         >& _sig_cf_cc, mtk::Signal<const mtk::trd::msg::CF_EX_MK&   /*ex*/         >& _sig_cf_ex)
        :  
        __last_confirmation(mtk::nullable<mtk::trd::msg::CF_XX_MK>() ),
        __last_request(mtk::nullable<mtk::trd::msg::RQ_XX_MK>() ),
        __serrors(""), 
        sig_rq_nw (_sig_rq_nw), 
        sig_rq_md (_sig_rq_md), 
        sig_rq_cc (_sig_rq_cc), 
        sig_rj_nw (_sig_rj_nw), 
        sig_rj_md (_sig_rj_md), 
        sig_rj_cc (_sig_rj_cc), 
        sig_cf_nw (_sig_cf_nw), 
        sig_cf_md (_sig_cf_md), 
        sig_cf_cc (_sig_cf_cc), 
        sig_cf_ex (_sig_cf_ex)
        {};
    virtual ~status_common_info(){};

    // PROPERTIES AND SIGNALS
    mtk::nullable<mtk::trd::msg::CF_XX_MK>       __last_confirmation;
    virtual const mtk::nullable<mtk::trd::msg::CF_XX_MK>      &  last_confirmation() const {  return __last_confirmation; };
    virtual void set_last_confirmation(const mtk::nullable<mtk::trd::msg::CF_XX_MK>      &  _prop) {  __last_confirmation = _prop;  };
    mtk::nullable<mtk::trd::msg::RQ_XX_MK>       __last_request;
    virtual const mtk::nullable<mtk::trd::msg::RQ_XX_MK>      &  last_request() const {  return __last_request; };
    virtual void set_last_request(const mtk::nullable<mtk::trd::msg::RQ_XX_MK>      &  _prop) {  __last_request = _prop;  };
    virtual const bool                                         &  in_market() const {  static bool                                         result(false);   return result; };
    virtual void set_in_market(const bool                                        & ) {  throw mtk::Alarm(MTK_HERE, "fsm_gen.set_property", "property not valid in current status", mtk::alPriorError);  };
    virtual const bool                                         &  is_canceled() const {  static bool                                         result(false);   return result; };
    virtual void set_is_canceled(const bool                                        & ) {  throw mtk::Alarm(MTK_HERE, "fsm_gen.set_property", "property not valid in current status", mtk::alPriorError);  };
    virtual const bool                                         &  is_full_executed() const {  static bool                                         result(false);   return result; };
    virtual void set_is_full_executed(const bool                                        & ) {  throw mtk::Alarm(MTK_HERE, "fsm_gen.set_property", "property not valid in current status", mtk::alPriorError);  };
    virtual const bool                                         &  has_pending_rq() const {  static bool                                         result(false);   return result; };
    virtual void set_has_pending_rq(const bool                                        & ) {  throw mtk::Alarm(MTK_HERE, "fsm_gen.set_property", "property not valid in current status", mtk::alPriorError);  };
    std::string                                  __serrors;
    virtual const std::string                                 &  serrors() const {  return __serrors; };
    virtual void set_serrors(const std::string                                 &  _prop) {  __serrors = _prop;  };
    mtk::Signal<const mtk::trd::msg::RQ_NW_MK&   /*rq*/         >& sig_rq_nw;
    mtk::Signal<const mtk::trd::msg::RQ_MD_MK&   /*rq*/         >& sig_rq_md;
    mtk::Signal<const mtk::trd::msg::RQ_CC_MK&   /*rq*/         >& sig_rq_cc;
    mtk::Signal<const mtk::trd::msg::RJ_NW_MK&   /*rj*/         >& sig_rj_nw;
    mtk::Signal<const mtk::trd::msg::RJ_MD_MK&   /*rj*/         >& sig_rj_md;
    mtk::Signal<const mtk::trd::msg::RJ_CC_MK&   /*rj*/         >& sig_rj_cc;
    mtk::Signal<const mtk::trd::msg::CF_NW_MK&   /*cf*/         >& sig_cf_nw;
    mtk::Signal<const mtk::trd::msg::CF_MD_MK&   /*cf*/         >& sig_cf_md;
    mtk::Signal<const mtk::trd::msg::CF_CC_MK&   /*cf*/         >& sig_cf_cc;
    mtk::Signal<const mtk::trd::msg::CF_EX_MK&   /*ex*/         >& sig_cf_ex;


    mtk::Signal<mtk::CountPtr<abstract_status> > signal_new_status;
    mtk::Signal<> signal_keep_temp_status;
    mtk::Signal<> signal_remove_temp_status;

};





// -----------------------------------------------------------------------
//      abstract_status
class abstract_status  : public mtk::SignalReceptor
{
    mtk::non_copyable  nc;

public:
    abstract_status (mtk::CountPtr<status_common_info> _ci)
        : ci (_ci) {};
    virtual ~abstract_status() {};
    
    mtk::CountPtr<status_common_info> ci;
    
    virtual std::string  GetStatusName() = 0;

    //  INPUTS
    virtual void rq_nw ( const mtk::trd::msg::RQ_NW_MK&   rq           )=0;
    virtual void rq_md ( const mtk::trd::msg::RQ_MD_MK&   rq           )=0;
    virtual void rq_cc ( const mtk::trd::msg::RQ_CC_MK&   rq           )=0;
    virtual void cf_nw ( const mtk::trd::msg::CF_NW_MK&   cf           )=0;
    virtual void cf_md ( const mtk::trd::msg::CF_MD_MK&   cf           )=0;
    virtual void cf_cc ( const mtk::trd::msg::CF_CC_MK&   cf           )=0;
    virtual void rj_nw ( const mtk::trd::msg::RJ_NW_MK&   rj           )=0;
    virtual void rj_md ( const mtk::trd::msg::RJ_MD_MK&   rj           )=0;
    virtual void rj_cc ( const mtk::trd::msg::RJ_CC_MK&   rj           )=0;
    virtual void cf_ex ( const mtk::trd::msg::CF_EX_MK&   ex           )=0;


    //  ACCESS
    virtual const mtk::nullable<mtk::trd::msg::CF_XX_MK>       &  last_confirmation (void) const { return ci->last_confirmation(); }; 
    virtual const mtk::nullable<mtk::trd::msg::RQ_XX_MK>       &  last_request (void) const { return ci->last_request(); }; 
    virtual const bool                                         &  in_market (void) const { return ci->in_market(); }; 
    virtual const bool                                         &  is_canceled (void) const { return ci->is_canceled(); }; 
    virtual const bool                                         &  is_full_executed (void) const { return ci->is_full_executed(); }; 
    virtual const bool                                         &  has_pending_rq (void) const { return ci->has_pending_rq(); }; 
    virtual const std::string                                  &  serrors (void) const { return ci->serrors(); }; 

};





// -----------------------------------------------------------------------
//      init
class init  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef init  CLASS_NAME;

public:
    init (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci)

        {  };
    
    std::string  GetStatusName()  {  return "init"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_MK&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_MK&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_MK&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_MK&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_MK&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_MK&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_MK&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_MK&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_MK&   rj           );
    void cf_ex (const mtk::trd::msg::CF_EX_MK&   ex           );


};



// -----------------------------------------------------------------------
//      w_cfnw
class w_cfnw  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef w_cfnw  CLASS_NAME;

public:
    w_cfnw (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci),
        __has_pending_rq(true)
        {  };
    
    std::string  GetStatusName()  {  return "w_cfnw"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    bool                                         __has_pending_rq;
    virtual const bool                                        &  has_pending_rq() const {  return __has_pending_rq; };
    virtual void set_has_pending_rq(const bool                                        &  _prop) {  __has_pending_rq = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_MK&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_MK&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_MK&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_MK&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_MK&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_MK&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_MK&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_MK&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_MK&   rj           );
    void cf_ex (const mtk::trd::msg::CF_EX_MK&   ex           );


};



// -----------------------------------------------------------------------
//      market
class market  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef market  CLASS_NAME;

public:
    market (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci),
        __in_market(true)
        {  };
    
    std::string  GetStatusName()  {  return "market"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    bool                                              __in_market;
    virtual const bool                                             &  in_market() const {  return __in_market; };
    virtual void set_in_market(const bool                                             &  _prop) {  __in_market = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_MK&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_MK&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_MK&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_MK&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_MK&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_MK&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_MK&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_MK&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_MK&   rj           );
    void cf_ex (const mtk::trd::msg::CF_EX_MK&   ex           );


};



// -----------------------------------------------------------------------
//      w_cfmd
class w_cfmd  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef w_cfmd  CLASS_NAME;

public:
    w_cfmd (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci),
        __has_pending_rq(true)
        {  };
    
    std::string  GetStatusName()  {  return "w_cfmd"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    bool                                         __has_pending_rq;
    virtual const bool                                        &  has_pending_rq() const {  return __has_pending_rq; };
    virtual void set_has_pending_rq(const bool                                        &  _prop) {  __has_pending_rq = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_MK&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_MK&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_MK&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_MK&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_MK&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_MK&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_MK&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_MK&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_MK&   rj           );
    void cf_ex (const mtk::trd::msg::CF_EX_MK&   ex           );


};



// -----------------------------------------------------------------------
//      w_cfcc
class w_cfcc  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef w_cfcc  CLASS_NAME;

public:
    w_cfcc (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci),
        __has_pending_rq(true)
        {  };
    
    std::string  GetStatusName()  {  return "w_cfcc"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    bool                                         __has_pending_rq;
    virtual const bool                                        &  has_pending_rq() const {  return __has_pending_rq; };
    virtual void set_has_pending_rq(const bool                                        &  _prop) {  __has_pending_rq = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_MK&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_MK&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_MK&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_MK&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_MK&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_MK&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_MK&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_MK&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_MK&   rj           );
    void cf_ex (const mtk::trd::msg::CF_EX_MK&   ex           );


};



// -----------------------------------------------------------------------
//      w_cfmdcc
class w_cfmdcc  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef w_cfmdcc  CLASS_NAME;

public:
    w_cfmdcc (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci),
        __has_pending_rq(true)
        {  };
    
    std::string  GetStatusName()  {  return "w_cfmdcc"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    bool                                         __has_pending_rq;
    virtual const bool                                        &  has_pending_rq() const {  return __has_pending_rq; };
    virtual void set_has_pending_rq(const bool                                        &  _prop) {  __has_pending_rq = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_MK&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_MK&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_MK&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_MK&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_MK&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_MK&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_MK&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_MK&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_MK&   rj           );
    void cf_ex (const mtk::trd::msg::CF_EX_MK&   ex           );


};



// -----------------------------------------------------------------------
//      w_cfnwmd
class w_cfnwmd  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef w_cfnwmd  CLASS_NAME;

public:
    w_cfnwmd (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci),
        __has_pending_rq(true)
        {  };
    
    std::string  GetStatusName()  {  return "w_cfnwmd"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    bool                                         __has_pending_rq;
    virtual const bool                                        &  has_pending_rq() const {  return __has_pending_rq; };
    virtual void set_has_pending_rq(const bool                                        &  _prop) {  __has_pending_rq = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_MK&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_MK&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_MK&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_MK&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_MK&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_MK&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_MK&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_MK&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_MK&   rj           );
    void cf_ex (const mtk::trd::msg::CF_EX_MK&   ex           );


};



// -----------------------------------------------------------------------
//      w_cfnwcc
class w_cfnwcc  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef w_cfnwcc  CLASS_NAME;

public:
    w_cfnwcc (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci),
        __has_pending_rq(true)
        {  };
    
    std::string  GetStatusName()  {  return "w_cfnwcc"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    bool                                         __has_pending_rq;
    virtual const bool                                        &  has_pending_rq() const {  return __has_pending_rq; };
    virtual void set_has_pending_rq(const bool                                        &  _prop) {  __has_pending_rq = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_MK&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_MK&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_MK&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_MK&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_MK&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_MK&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_MK&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_MK&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_MK&   rj           );
    void cf_ex (const mtk::trd::msg::CF_EX_MK&   ex           );


};



// -----------------------------------------------------------------------
//      canceled
class canceled  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef canceled  CLASS_NAME;

public:
    canceled (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci),
        __is_canceled(true)
        {  };
    
    std::string  GetStatusName()  {  return "canceled"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    bool                                              __is_canceled;
    virtual const bool                                             &  is_canceled() const {  return __is_canceled; };
    virtual void set_is_canceled(const bool                                             &  _prop) {  __is_canceled = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_MK&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_MK&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_MK&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_MK&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_MK&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_MK&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_MK&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_MK&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_MK&   rj           );
    void cf_ex (const mtk::trd::msg::CF_EX_MK&   ex           );


};



// -----------------------------------------------------------------------
//      executed
class executed  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef executed  CLASS_NAME;

public:
    executed (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci),
        __is_full_executed(true)
        {  };
    
    std::string  GetStatusName()  {  return "executed"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    bool                                         __is_full_executed;
    virtual const bool                                        &  is_full_executed() const {  return __is_full_executed; };
    virtual void set_is_full_executed(const bool                                        &  _prop) {  __is_full_executed = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_MK&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_MK&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_MK&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_MK&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_MK&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_MK&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_MK&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_MK&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_MK&   rj           );
    void cf_ex (const mtk::trd::msg::CF_EX_MK&   ex           );


};



// -----------------------------------------------------------------------
//      error
class error  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef error  CLASS_NAME;

public:
    error (mtk::CountPtr<status_common_info> _ci,  const std::string                                 & _description)
        : 
        abstract_status(_ci),
        __description(_description)
        { 
            try
            {
                  
            ci->__serrors += std::string(", ") + description();   
            mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", description(), mtk::alPriorCritic, mtk::alTypeNoPermisions));  
      
            }
            MTK_CATCH_RETHROW("error_ctor", "rethrowed") };
    
    std::string  GetStatusName()  {  return "error"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    std::string                                  __description;
    virtual const std::string                                 &  description() const {  return __description; };
    virtual void set_description(const std::string                                 &  _prop) {  __description = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_MK&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_MK&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_MK&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_MK&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_MK&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_MK&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_MK&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_MK&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_MK&   rj           );
    void cf_ex (const mtk::trd::msg::CF_EX_MK&   ex           );


};






void init::rq_nw ( const mtk::trd::msg::RQ_NW_MK&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "init::rq_nw";

      CHECK_REQUEST       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_rq

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid rqnw ")       ));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 SEND_REJECT(sig_rj_nw, RJ_NW_MK)  

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnw (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_rqnw
  ci->sig_rq_nw(rq);  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::rq_md ( const mtk::trd::msg::RQ_MD_MK&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "init::rq_md";

      CHECK_REQUEST_MOD   

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 SEND_REJECT(sig_rj_md, RJ_MD_MK)  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::rq_cc ( const mtk::trd::msg::RQ_CC_MK&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "init::rq_cc";

      CHECK_REQUEST       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqcc
 SEND_REJECT(sig_rj_cc, RJ_CC_MK)  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::cf_nw ( const mtk::trd::msg::CF_NW_MK&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "init::cf_nw";

      CHECK_CONFIRM       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ci->sig_cf_nw(cf);  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::cf_md ( const mtk::trd::msg::CF_MD_MK&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "init::cf_md";

      CHECK_CONFIRM       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ci->sig_cf_md(cf);  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::cf_cc ( const mtk::trd::msg::CF_CC_MK&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "init::cf_cc";

      CHECK_CONFIRM       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc
  ci->sig_cf_cc(cf);  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::rj_nw ( const mtk::trd::msg::RJ_NW_MK&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "init::rj_nw";

      CHECK_REJECT        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::rj_md ( const mtk::trd::msg::RJ_MD_MK&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "init::rj_md";

      CHECK_REJECT        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::rj_cc ( const mtk::trd::msg::RJ_CC_MK&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "init::rj_cc";

      CHECK_REJECT        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::cf_ex ( const mtk::trd::msg::CF_EX_MK&   ex            )
{
    //  remove unused warning
    (void) ex;

    
	static const char* method_name = "init::cf_ex";

          
                                const mtk::trd::msg::CF_XX_MK& cf(ex); 
                                CHECK_CONFIRM  
                                CHECK_EXEC  
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: full_exec

                    last_confirmation().HasValue() == true
                    &&  last_confirmation().Get().total_execs.quantity  
                        == last_confirmation().Get().market_pos.quantity
                 ) {

            new_status = mtk::make_cptr(new executed (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ci->sig_cf_ex(ex);  

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ci->sig_cf_ex(ex);  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::rq_nw ( const mtk::trd::msg::RQ_NW_MK&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfnw::rq_nw";

      CHECK_REQUEST       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 SEND_REJECT(sig_rj_nw, RJ_NW_MK)  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::rq_md ( const mtk::trd::msg::RQ_MD_MK&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfnw::rq_md";

      CHECK_REQUEST_MOD   

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_rq

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new w_cfnwcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 SEND_REJECT(sig_rj_md, RJ_MD_MK)  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnwmd (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_rqmd
  ci->sig_rq_md(rq);  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::rq_cc ( const mtk::trd::msg::RQ_CC_MK&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfnw::rq_cc";

      CHECK_REQUEST       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnwcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::cf_nw ( const mtk::trd::msg::CF_NW_MK&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfnw::cf_nw";

      CHECK_CONFIRM       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_cf

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid cfnw ")       ));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ci->sig_cf_nw(cf);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ci->sig_cf_nw(cf);  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::cf_md ( const mtk::trd::msg::CF_MD_MK&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfnw::cf_md";

      CHECK_CONFIRM       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ci->sig_cf_md(cf);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::cf_cc ( const mtk::trd::msg::CF_CC_MK&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfnw::cf_cc";

      CHECK_CONFIRM       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc
  ci->sig_cf_cc(cf);  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::rj_nw ( const mtk::trd::msg::RJ_NW_MK&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfnw::rj_nw";

      CHECK_REJECT        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ci->sig_rj_nw(rj);  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::rj_md ( const mtk::trd::msg::RJ_MD_MK&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfnw::rj_md";

      CHECK_REJECT        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ci->sig_rj_md(rj);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::rj_cc ( const mtk::trd::msg::RJ_CC_MK&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfnw::rj_cc";

      CHECK_REJECT        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ci->sig_rj_cc(rj);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::cf_ex ( const mtk::trd::msg::CF_EX_MK&   ex            )
{
    //  remove unused warning
    (void) ex;

    
	static const char* method_name = "w_cfnw::cf_ex";

          
                                const mtk::trd::msg::CF_XX_MK& cf(ex); 
                                CHECK_CONFIRM  
                                CHECK_EXEC  
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ci->sig_cf_ex(ex);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::rq_nw ( const mtk::trd::msg::RQ_NW_MK&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "market::rq_nw";

      CHECK_REQUEST       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 SEND_REJECT(sig_rj_nw, RJ_NW_MK)  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::rq_md ( const mtk::trd::msg::RQ_MD_MK&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "market::rq_md";

      CHECK_REQUEST_MOD   

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_rq

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new w_cfcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 SEND_REJECT(sig_rj_md, RJ_MD_MK)  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmd (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_rqmd
  ci->sig_rq_md(rq);  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::rq_cc ( const mtk::trd::msg::RQ_CC_MK&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "market::rq_cc";

      CHECK_REQUEST       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::cf_nw ( const mtk::trd::msg::CF_NW_MK&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "market::cf_nw";

      CHECK_CONFIRM       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ci->sig_cf_nw(cf);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::cf_md ( const mtk::trd::msg::CF_MD_MK&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "market::cf_md";

      CHECK_CONFIRM       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd_nr
  ci->sig_cf_md(cf);  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::cf_cc ( const mtk::trd::msg::CF_CC_MK&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "market::cf_cc";

      CHECK_CONFIRM       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_cf

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid cfcc")   ));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc_nr
  ci->sig_cf_cc(cf);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc_nr
  ci->sig_cf_cc(cf);  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::rj_nw ( const mtk::trd::msg::RJ_NW_MK&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "market::rj_nw";

      CHECK_REJECT        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ci->sig_rj_nw(rj);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::rj_md ( const mtk::trd::msg::RJ_MD_MK&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "market::rj_md";

      CHECK_REJECT        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ci->sig_rj_md(rj);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::rj_cc ( const mtk::trd::msg::RJ_CC_MK&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "market::rj_cc";

      CHECK_REJECT        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ci->sig_rj_cc(rj);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::cf_ex ( const mtk::trd::msg::CF_EX_MK&   ex            )
{
    //  remove unused warning
    (void) ex;

    
	static const char* method_name = "market::cf_ex";

          
                                const mtk::trd::msg::CF_XX_MK& cf(ex); 
                                CHECK_CONFIRM  
                                CHECK_EXEC  
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: full_exec

                    last_confirmation().HasValue() == true
                    &&  last_confirmation().Get().total_execs.quantity  
                        == last_confirmation().Get().market_pos.quantity
                 ) {

            new_status = mtk::make_cptr(new executed (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ci->sig_cf_ex(ex);  

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ci->sig_cf_ex(ex);  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::rq_nw ( const mtk::trd::msg::RQ_NW_MK&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfmd::rq_nw";

      CHECK_REQUEST       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 SEND_REJECT(sig_rj_nw, RJ_NW_MK)  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::rq_md ( const mtk::trd::msg::RQ_MD_MK&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfmd::rq_md";

      CHECK_REQUEST_MOD   

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_rq

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid rqmd")));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 SEND_REJECT(sig_rj_md, RJ_MD_MK)  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmd (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_rqmd
  ci->sig_rq_md(rq);  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::rq_cc ( const mtk::trd::msg::RQ_CC_MK&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfmd::rq_cc";

      CHECK_REQUEST       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmdcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::cf_nw ( const mtk::trd::msg::CF_NW_MK&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfmd::cf_nw";

      CHECK_CONFIRM       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ci->sig_cf_nw(cf);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::cf_md ( const mtk::trd::msg::CF_MD_MK&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfmd::cf_md";

      CHECK_CONFIRM       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_cf

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid cfmd")));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ci->sig_cf_md(cf);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (//  inserting macro: is_conf_last_rqmd

                    ({  bool result = false;
                        if (ci->last_request().HasValue())
                            result = cf.req_info == ci->last_request().Get().req_info;
                        else
                            result = false;
                        result;
                    })
                 ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ci->sig_cf_md(cf);  

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmd (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd_pend
  ci->sig_cf_md(cf);  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::cf_cc ( const mtk::trd::msg::CF_CC_MK&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfmd::cf_cc";

      CHECK_CONFIRM       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_cf

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid cfcc")  ));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc_nr
  ci->sig_cf_cc(cf);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc_nr
  ci->sig_cf_cc(cf);  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::rj_nw ( const mtk::trd::msg::RJ_NW_MK&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfmd::rj_nw";

      CHECK_REJECT        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ci->sig_rj_nw(rj);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::rj_md ( const mtk::trd::msg::RJ_MD_MK&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfmd::rj_md";

      CHECK_REJECT        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ci->sig_rj_md(rj);  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::rj_cc ( const mtk::trd::msg::RJ_CC_MK&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfmd::rj_cc";

      CHECK_REJECT        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ci->sig_rj_cc(rj);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::cf_ex ( const mtk::trd::msg::CF_EX_MK&   ex            )
{
    //  remove unused warning
    (void) ex;

    
	static const char* method_name = "w_cfmd::cf_ex";

          
                                const mtk::trd::msg::CF_XX_MK& cf(ex); 
                                CHECK_CONFIRM  
                                CHECK_EXEC  
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: full_exec

                    last_confirmation().HasValue() == true
                    &&  last_confirmation().Get().total_execs.quantity  
                        == last_confirmation().Get().market_pos.quantity
                 ) {

            new_status = mtk::make_cptr(new executed (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ci->sig_cf_ex(ex);  

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmd (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ci->sig_cf_ex(ex);  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::rq_nw ( const mtk::trd::msg::RQ_NW_MK&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfcc::rq_nw";

      CHECK_REQUEST       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 SEND_REJECT(sig_rj_nw, RJ_NW_MK)  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::rq_md ( const mtk::trd::msg::RQ_MD_MK&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfcc::rq_md";

      CHECK_REQUEST_MOD   

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 SEND_REJECT(sig_rj_md, RJ_MD_MK)  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::rq_cc ( const mtk::trd::msg::RQ_CC_MK&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfcc::rq_cc";

      CHECK_REQUEST       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::cf_nw ( const mtk::trd::msg::CF_NW_MK&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfcc::cf_nw";

      CHECK_CONFIRM       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ci->sig_cf_nw(cf);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::cf_md ( const mtk::trd::msg::CF_MD_MK&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfcc::cf_md";

      CHECK_CONFIRM       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ci->sig_cf_md(cf);  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::cf_cc ( const mtk::trd::msg::CF_CC_MK&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfcc::cf_cc";

      CHECK_CONFIRM       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_cf

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid cfcc")  ));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc_nr
  ci->sig_cf_cc(cf);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc
  ci->sig_cf_cc(cf);  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::rj_nw ( const mtk::trd::msg::RJ_NW_MK&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfcc::rj_nw";

      CHECK_REJECT        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ci->sig_rj_nw(rj);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::rj_md ( const mtk::trd::msg::RJ_MD_MK&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfcc::rj_md";

      CHECK_REJECT        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ci->sig_rj_md(rj);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::rj_cc ( const mtk::trd::msg::RJ_CC_MK&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfcc::rj_cc";

      CHECK_REJECT        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ci->sig_rj_cc(rj);  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::cf_ex ( const mtk::trd::msg::CF_EX_MK&   ex            )
{
    //  remove unused warning
    (void) ex;

    
	static const char* method_name = "w_cfcc::cf_ex";

          
                                const mtk::trd::msg::CF_XX_MK& cf(ex); 
                                CHECK_CONFIRM  
                                CHECK_EXEC  
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: full_exec

                    last_confirmation().HasValue() == true
                    &&  last_confirmation().Get().total_execs.quantity  
                        == last_confirmation().Get().market_pos.quantity
                 ) {

            new_status = mtk::make_cptr(new executed (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ci->sig_cf_ex(ex);  

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ci->sig_cf_ex(ex);  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::rq_nw ( const mtk::trd::msg::RQ_NW_MK&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfmdcc::rq_nw";

      CHECK_REQUEST       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 SEND_REJECT(sig_rj_nw, RJ_NW_MK)  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::rq_md ( const mtk::trd::msg::RQ_MD_MK&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfmdcc::rq_md";

      CHECK_REQUEST_MOD   

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_rq

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new w_cfmdcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 SEND_REJECT(sig_rj_md, RJ_MD_MK)  

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmdcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 SEND_REJECT(sig_rj_md, RJ_MD_MK)  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::rq_cc ( const mtk::trd::msg::RQ_CC_MK&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfmdcc::rq_cc";

      CHECK_REQUEST       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmdcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::cf_nw ( const mtk::trd::msg::CF_NW_MK&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfmdcc::cf_nw";

      CHECK_CONFIRM       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ci->sig_cf_nw(cf);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::cf_md ( const mtk::trd::msg::CF_MD_MK&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfmdcc::cf_md";

      CHECK_CONFIRM       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_cf

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid cfmd")));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ci->sig_cf_md(cf);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (//  inserting macro: is_conf_last_rqmd

                    ({  bool result = false;
                        if (ci->last_request().HasValue())
                            result = cf.req_info == ci->last_request().Get().req_info;
                        else
                            result = false;
                        result;
                    })
                 ) {

            new_status = mtk::make_cptr(new w_cfcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ci->sig_cf_md(cf);  

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmdcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd_pend
  ci->sig_cf_md(cf);  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::cf_cc ( const mtk::trd::msg::CF_CC_MK&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfmdcc::cf_cc";

      CHECK_CONFIRM       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_cf

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid cfcc")  ));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc_nr
  ci->sig_cf_cc(cf);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc
  ci->sig_cf_cc(cf);  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::rj_nw ( const mtk::trd::msg::RJ_NW_MK&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfmdcc::rj_nw";

      CHECK_REJECT        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ci->sig_rj_nw(rj);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::rj_md ( const mtk::trd::msg::RJ_MD_MK&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfmdcc::rj_md";

      CHECK_REJECT        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ci->sig_rj_md(rj);  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::rj_cc ( const mtk::trd::msg::RJ_CC_MK&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfmdcc::rj_cc";

      CHECK_REJECT        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmd (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ci->sig_rj_cc(rj);  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::cf_ex ( const mtk::trd::msg::CF_EX_MK&   ex            )
{
    //  remove unused warning
    (void) ex;

    
	static const char* method_name = "w_cfmdcc::cf_ex";

          
                                const mtk::trd::msg::CF_XX_MK& cf(ex); 
                                CHECK_CONFIRM  
                                CHECK_EXEC  
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: full_exec

                    last_confirmation().HasValue() == true
                    &&  last_confirmation().Get().total_execs.quantity  
                        == last_confirmation().Get().market_pos.quantity
                 ) {

            new_status = mtk::make_cptr(new executed (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ci->sig_cf_ex(ex);  

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmdcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ci->sig_cf_ex(ex);  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::rq_nw ( const mtk::trd::msg::RQ_NW_MK&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfnwmd::rq_nw";

      CHECK_REQUEST       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 SEND_REJECT(sig_rj_nw, RJ_NW_MK)  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::rq_md ( const mtk::trd::msg::RQ_MD_MK&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfnwmd::rq_md";

      CHECK_REQUEST_MOD   

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_rq

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new w_cfnwcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 SEND_REJECT(sig_rj_md, RJ_MD_MK)  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnwmd (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_rqmd
  ci->sig_rq_md(rq);  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::rq_cc ( const mtk::trd::msg::RQ_CC_MK&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfnwmd::rq_cc";

      CHECK_REQUEST       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnwcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::cf_nw ( const mtk::trd::msg::CF_NW_MK&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfnwmd::cf_nw";

      CHECK_CONFIRM       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_cf

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid cfnw")));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ci->sig_cf_nw(cf);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmd (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ci->sig_cf_nw(cf);  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::cf_md ( const mtk::trd::msg::CF_MD_MK&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfnwmd::cf_md";

      CHECK_CONFIRM       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ci->sig_cf_md(cf);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::cf_cc ( const mtk::trd::msg::CF_CC_MK&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfnwmd::cf_cc";

      CHECK_CONFIRM       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc
  ci->sig_cf_cc(cf);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::rj_nw ( const mtk::trd::msg::RJ_NW_MK&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfnwmd::rj_nw";

      CHECK_REJECT        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ci->sig_rj_nw(rj);  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::rj_md ( const mtk::trd::msg::RJ_MD_MK&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfnwmd::rj_md";

      CHECK_REJECT        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ci->sig_rj_md(rj);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::rj_cc ( const mtk::trd::msg::RJ_CC_MK&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfnwmd::rj_cc";

      CHECK_REJECT        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ci->sig_rj_cc(rj);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::cf_ex ( const mtk::trd::msg::CF_EX_MK&   ex            )
{
    //  remove unused warning
    (void) ex;

    
	static const char* method_name = "w_cfnwmd::cf_ex";

          
                                const mtk::trd::msg::CF_XX_MK& cf(ex); 
                                CHECK_CONFIRM  
                                CHECK_EXEC  
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ci->sig_cf_ex(ex);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::rq_nw ( const mtk::trd::msg::RQ_NW_MK&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfnwcc::rq_nw";

      CHECK_REQUEST       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 SEND_REJECT(sig_rj_nw, RJ_NW_MK)  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::rq_md ( const mtk::trd::msg::RQ_MD_MK&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfnwcc::rq_md";

      CHECK_REQUEST_MOD   

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnwcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_rqmd
  ci->sig_rq_md(rq);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::rq_cc ( const mtk::trd::msg::RQ_CC_MK&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfnwcc::rq_cc";

      CHECK_REQUEST       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnwcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::cf_nw ( const mtk::trd::msg::CF_NW_MK&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfnwcc::cf_nw";

      CHECK_CONFIRM       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_cf

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid cfnw")));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ci->sig_cf_nw(cf);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ci->sig_cf_nw(cf);  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::cf_md ( const mtk::trd::msg::CF_MD_MK&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfnwcc::cf_md";

      CHECK_CONFIRM       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ci->sig_cf_md(cf);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::cf_cc ( const mtk::trd::msg::CF_CC_MK&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfnwcc::cf_cc";

      CHECK_CONFIRM       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc
  ci->sig_cf_cc(cf);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::rj_nw ( const mtk::trd::msg::RJ_NW_MK&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfnwcc::rj_nw";

      CHECK_REJECT        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ci->sig_rj_nw(rj);  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::rj_md ( const mtk::trd::msg::RJ_MD_MK&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfnwcc::rj_md";

      CHECK_REJECT        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ci->sig_rj_md(rj);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::rj_cc ( const mtk::trd::msg::RJ_CC_MK&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfnwcc::rj_cc";

      CHECK_REJECT        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ci->sig_rj_cc(rj);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::cf_ex ( const mtk::trd::msg::CF_EX_MK&   ex            )
{
    //  remove unused warning
    (void) ex;

    
	static const char* method_name = "w_cfnwcc::cf_ex";

          
                                const mtk::trd::msg::CF_XX_MK& cf(ex); 
                                CHECK_CONFIRM  
                                CHECK_EXEC  
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ci->sig_cf_ex(ex);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::rq_nw ( const mtk::trd::msg::RQ_NW_MK&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "canceled::rq_nw";

      CHECK_REQUEST       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 SEND_REJECT(sig_rj_nw, RJ_NW_MK)  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::rq_md ( const mtk::trd::msg::RQ_MD_MK&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "canceled::rq_md";

      CHECK_REQUEST_MOD   

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 SEND_REJECT(sig_rj_md, RJ_MD_MK)  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::rq_cc ( const mtk::trd::msg::RQ_CC_MK&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "canceled::rq_cc";

      CHECK_REQUEST       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqcc
 SEND_REJECT(sig_rj_cc, RJ_CC_MK)  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::cf_nw ( const mtk::trd::msg::CF_NW_MK&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "canceled::cf_nw";

      CHECK_CONFIRM       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ci->sig_cf_nw(cf);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::cf_md ( const mtk::trd::msg::CF_MD_MK&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "canceled::cf_md";

      CHECK_CONFIRM       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ci->sig_cf_md(cf);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::cf_cc ( const mtk::trd::msg::CF_CC_MK&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "canceled::cf_cc";

      CHECK_CONFIRM       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc
  ci->sig_cf_cc(cf);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::rj_nw ( const mtk::trd::msg::RJ_NW_MK&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "canceled::rj_nw";

      CHECK_REJECT        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ci->sig_rj_nw(rj);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::rj_md ( const mtk::trd::msg::RJ_MD_MK&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "canceled::rj_md";

      CHECK_REJECT        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ci->sig_rj_md(rj);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::rj_cc ( const mtk::trd::msg::RJ_CC_MK&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "canceled::rj_cc";

      CHECK_REJECT        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ci->sig_rj_cc(rj);  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::cf_ex ( const mtk::trd::msg::CF_EX_MK&   ex            )
{
    //  remove unused warning
    (void) ex;

    
	static const char* method_name = "canceled::cf_ex";

          
                                const mtk::trd::msg::CF_XX_MK& cf(ex); 
                                CHECK_CONFIRM  
                                CHECK_EXEC  
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ci->sig_cf_ex(ex);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void executed::rq_nw ( const mtk::trd::msg::RQ_NW_MK&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "executed::rq_nw";

      CHECK_REQUEST       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 SEND_REJECT(sig_rj_nw, RJ_NW_MK)  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void executed::rq_md ( const mtk::trd::msg::RQ_MD_MK&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "executed::rq_md";

      CHECK_REQUEST_MOD   

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new executed (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 SEND_REJECT(sig_rj_md, RJ_MD_MK)  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void executed::rq_cc ( const mtk::trd::msg::RQ_CC_MK&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "executed::rq_cc";

      CHECK_REQUEST       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new executed (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqcc
 SEND_REJECT(sig_rj_cc, RJ_CC_MK)  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void executed::cf_nw ( const mtk::trd::msg::CF_NW_MK&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "executed::cf_nw";

      CHECK_CONFIRM       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ci->sig_cf_nw(cf);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void executed::cf_md ( const mtk::trd::msg::CF_MD_MK&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "executed::cf_md";

      CHECK_CONFIRM       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ci->sig_cf_md(cf);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void executed::cf_cc ( const mtk::trd::msg::CF_CC_MK&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "executed::cf_cc";

      CHECK_CONFIRM       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc
  ci->sig_cf_cc(cf);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void executed::rj_nw ( const mtk::trd::msg::RJ_NW_MK&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "executed::rj_nw";

      CHECK_REJECT        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ci->sig_rj_nw(rj);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void executed::rj_md ( const mtk::trd::msg::RJ_MD_MK&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "executed::rj_md";

      CHECK_REJECT        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ci->sig_rj_md(rj);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void executed::rj_cc ( const mtk::trd::msg::RJ_CC_MK&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "executed::rj_cc";

      CHECK_REJECT        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ci->sig_rj_cc(rj);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void executed::cf_ex ( const mtk::trd::msg::CF_EX_MK&   ex            )
{
    //  remove unused warning
    (void) ex;

    
	static const char* method_name = "executed::cf_ex";

          
                                const mtk::trd::msg::CF_XX_MK& cf(ex); 
                                CHECK_CONFIRM  
                                CHECK_EXEC  
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ci->sig_cf_ex(ex);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::rq_nw ( const mtk::trd::msg::RQ_NW_MK&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "error::rq_nw";

      CHECK_REQUEST       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 SEND_REJECT(sig_rj_nw, RJ_NW_MK)  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::rq_md ( const mtk::trd::msg::RQ_MD_MK&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "error::rq_md";

      CHECK_REQUEST_MOD   

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 SEND_REJECT(sig_rj_md, RJ_MD_MK)  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::rq_cc ( const mtk::trd::msg::RQ_CC_MK&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "error::rq_cc";

      CHECK_REQUEST       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::cf_nw ( const mtk::trd::msg::CF_NW_MK&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "error::cf_nw";

      CHECK_CONFIRM       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ci->sig_cf_nw(cf);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::cf_md ( const mtk::trd::msg::CF_MD_MK&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "error::cf_md";

      CHECK_CONFIRM       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ci->sig_cf_md(cf);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::cf_cc ( const mtk::trd::msg::CF_CC_MK&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "error::cf_cc";

      CHECK_CONFIRM       

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc
  ci->sig_cf_cc(cf);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::rj_nw ( const mtk::trd::msg::RJ_NW_MK&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "error::rj_nw";

      CHECK_REJECT        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ci->sig_rj_nw(rj);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::rj_md ( const mtk::trd::msg::RJ_MD_MK&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "error::rj_md";

      CHECK_REJECT        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ci->sig_rj_md(rj);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::rj_cc ( const mtk::trd::msg::RJ_CC_MK&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "error::rj_cc";

      CHECK_REJECT        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ci->sig_rj_cc(rj);  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::cf_ex ( const mtk::trd::msg::CF_EX_MK&   ex            )
{
    //  remove unused warning
    (void) ex;

    
	static const char* method_name = "error::cf_ex";

          
                                const mtk::trd::msg::CF_XX_MK& cf(ex); 
                                CHECK_CONFIRM  
                                CHECK_EXEC  
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ci->sig_cf_ex(ex);  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK  rqxxmk(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_MK  rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_MK rqxxmk(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_MK rqccmk(rqxxmk);
                        ci->sig_rq_cc(rqccmk);
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_mk.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}


};  // end   namespace fsmgen_trd_cli_mk {

mtk::trd::trd_cli_mk::trd_cli_mk()
{
    mtk::CountPtr<fsmgen_trd_cli_mk::status_common_info> ci = mtk::make_cptr(
                            new fsmgen_trd_cli_mk::status_common_info ( sig_rq_nw,sig_rq_md,sig_rq_cc,sig_rj_nw,sig_rj_md,sig_rj_cc,sig_cf_nw,sig_cf_md,sig_cf_cc,sig_cf_ex));

    current_status = mtk::make_cptr(new fsmgen_trd_cli_mk::init(ci ) );
    MTK_CONNECT_THIS(ci->signal_new_status, on_new_status)
    MTK_CONNECT_THIS(ci->signal_keep_temp_status, on_keep_temp_status)
    MTK_CONNECT_THIS(ci->signal_remove_temp_status, on_remove_temp_status)
}


mtk::trd::trd_cli_mk::~trd_cli_mk()
{
}

void mtk::trd::trd_cli_mk::on_new_status (mtk::CountPtr<fsmgen_trd_cli_mk::abstract_status>  new_status)
{
    current_status = new_status;
}

void mtk::trd::trd_cli_mk::on_keep_temp_status (void)
{
    queue_temp_status.push_back(current_status);
}
void mtk::trd::trd_cli_mk::on_remove_temp_status (void)
{
    queue_temp_status.pop_front();
}


void mtk::trd::trd_cli_mk::rq_nw (const mtk::trd::msg::RQ_NW_MK&   rq           )
{
    mtk::CountPtr<fsmgen_trd_cli_mk::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->rq_nw(rq);
}
void mtk::trd::trd_cli_mk::rq_md (const mtk::trd::msg::RQ_MD_MK&   rq           )
{
    mtk::CountPtr<fsmgen_trd_cli_mk::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->rq_md(rq);
}
void mtk::trd::trd_cli_mk::rq_cc (const mtk::trd::msg::RQ_CC_MK&   rq           )
{
    mtk::CountPtr<fsmgen_trd_cli_mk::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->rq_cc(rq);
}
void mtk::trd::trd_cli_mk::cf_nw (const mtk::trd::msg::CF_NW_MK&   cf           )
{
    mtk::CountPtr<fsmgen_trd_cli_mk::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->cf_nw(cf);
}
void mtk::trd::trd_cli_mk::cf_md (const mtk::trd::msg::CF_MD_MK&   cf           )
{
    mtk::CountPtr<fsmgen_trd_cli_mk::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->cf_md(cf);
}
void mtk::trd::trd_cli_mk::cf_cc (const mtk::trd::msg::CF_CC_MK&   cf           )
{
    mtk::CountPtr<fsmgen_trd_cli_mk::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->cf_cc(cf);
}
void mtk::trd::trd_cli_mk::rj_nw (const mtk::trd::msg::RJ_NW_MK&   rj           )
{
    mtk::CountPtr<fsmgen_trd_cli_mk::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->rj_nw(rj);
}
void mtk::trd::trd_cli_mk::rj_md (const mtk::trd::msg::RJ_MD_MK&   rj           )
{
    mtk::CountPtr<fsmgen_trd_cli_mk::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->rj_md(rj);
}
void mtk::trd::trd_cli_mk::rj_cc (const mtk::trd::msg::RJ_CC_MK&   rj           )
{
    mtk::CountPtr<fsmgen_trd_cli_mk::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->rj_cc(rj);
}
void mtk::trd::trd_cli_mk::cf_ex (const mtk::trd::msg::CF_EX_MK&   ex           )
{
    mtk::CountPtr<fsmgen_trd_cli_mk::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->cf_ex(ex);
}
const mtk::nullable<mtk::trd::msg::CF_XX_MK>       & mtk::trd::trd_cli_mk::last_confirmation (void) const
{
    return current_status->last_confirmation();
}
const mtk::nullable<mtk::trd::msg::RQ_XX_MK>       & mtk::trd::trd_cli_mk::last_request (void) const
{
    return current_status->last_request();
}
const bool                                         & mtk::trd::trd_cli_mk::in_market (void) const
{
    return current_status->in_market();
}
const bool                                         & mtk::trd::trd_cli_mk::is_canceled (void) const
{
    return current_status->is_canceled();
}
const bool                                         & mtk::trd::trd_cli_mk::is_full_executed (void) const
{
    return current_status->is_full_executed();
}
const bool                                         & mtk::trd::trd_cli_mk::has_pending_rq (void) const
{
    return current_status->has_pending_rq();
}
const std::string                                  & mtk::trd::trd_cli_mk::serrors (void) const
{
    return current_status->serrors();
}
