//  code generated by fsm_gen
// generated automatically
// coded last modification:        $CODED_LAST_MODIF  desactivated, lots of false notifications
// pythonscript last modification: $SCRIPT_LAST_MODIF

#include "support/mtk_string.h"




namespace fsmgen_trd_cli_ls {


class abstract_status;


// -----------------------------------------------------------------------
//      c o v e r a g e
struct   scoverage
{
    scoverage(void) :

          init__rq_nw (0)
        , init__rq_md (0)
        , init__rq_cc (0)
        , init__cf_nw (0)
        , init__cf_md (0)
        , init__cf_cc (0)
        , init__rj_nw (0)
        , init__rj_md (0)
        , init__rj_cc (0)
        , init__cf_ex (0)
        , init__cf_exLK (0)
        , init__cf_st (0)
        , w_cfnw__rq_nw (0)
        , w_cfnw__rq_md (0)
        , w_cfnw__rq_cc (0)
        , w_cfnw__cf_nw (0)
        , w_cfnw__cf_md (0)
        , w_cfnw__cf_cc (0)
        , w_cfnw__rj_nw (0)
        , w_cfnw__rj_md (0)
        , w_cfnw__rj_cc (0)
        , w_cfnw__cf_ex (0)
        , w_cfnw__cf_exLK (0)
        , w_cfnw__cf_st (0)
        , market__rq_nw (0)
        , market__rq_md (0)
        , market__rq_cc (0)
        , market__cf_nw (0)
        , market__cf_md (0)
        , market__cf_cc (0)
        , market__rj_nw (0)
        , market__rj_md (0)
        , market__rj_cc (0)
        , market__cf_ex (0)
        , market__cf_exLK (0)
        , market__cf_st (0)
        , w_cfmd__rq_nw (0)
        , w_cfmd__rq_md (0)
        , w_cfmd__rq_cc (0)
        , w_cfmd__cf_nw (0)
        , w_cfmd__cf_md (0)
        , w_cfmd__cf_cc (0)
        , w_cfmd__rj_nw (0)
        , w_cfmd__rj_md (0)
        , w_cfmd__rj_cc (0)
        , w_cfmd__cf_ex (0)
        , w_cfmd__cf_exLK (0)
        , w_cfmd__cf_st (0)
        , w_cfcc__rq_nw (0)
        , w_cfcc__rq_md (0)
        , w_cfcc__rq_cc (0)
        , w_cfcc__cf_nw (0)
        , w_cfcc__cf_md (0)
        , w_cfcc__cf_cc (0)
        , w_cfcc__rj_nw (0)
        , w_cfcc__rj_md (0)
        , w_cfcc__rj_cc (0)
        , w_cfcc__cf_ex (0)
        , w_cfcc__cf_exLK (0)
        , w_cfcc__cf_st (0)
        , w_cfmdcc__rq_nw (0)
        , w_cfmdcc__rq_md (0)
        , w_cfmdcc__rq_cc (0)
        , w_cfmdcc__cf_nw (0)
        , w_cfmdcc__cf_md (0)
        , w_cfmdcc__cf_cc (0)
        , w_cfmdcc__rj_nw (0)
        , w_cfmdcc__rj_md (0)
        , w_cfmdcc__rj_cc (0)
        , w_cfmdcc__cf_ex (0)
        , w_cfmdcc__cf_exLK (0)
        , w_cfmdcc__cf_st (0)
        , w_cfnwmd__rq_nw (0)
        , w_cfnwmd__rq_md (0)
        , w_cfnwmd__rq_cc (0)
        , w_cfnwmd__cf_nw (0)
        , w_cfnwmd__cf_md (0)
        , w_cfnwmd__cf_cc (0)
        , w_cfnwmd__rj_nw (0)
        , w_cfnwmd__rj_md (0)
        , w_cfnwmd__rj_cc (0)
        , w_cfnwmd__cf_ex (0)
        , w_cfnwmd__cf_exLK (0)
        , w_cfnwmd__cf_st (0)
        , w_cfnwcc__rq_nw (0)
        , w_cfnwcc__rq_md (0)
        , w_cfnwcc__rq_cc (0)
        , w_cfnwcc__cf_nw (0)
        , w_cfnwcc__cf_md (0)
        , w_cfnwcc__cf_cc (0)
        , w_cfnwcc__rj_nw (0)
        , w_cfnwcc__rj_md (0)
        , w_cfnwcc__rj_cc (0)
        , w_cfnwcc__cf_ex (0)
        , w_cfnwcc__cf_exLK (0)
        , w_cfnwcc__cf_st (0)
        , canceled__rq_nw (0)
        , canceled__rq_md (0)
        , canceled__rq_cc (0)
        , canceled__cf_nw (0)
        , canceled__cf_md (0)
        , canceled__cf_cc (0)
        , canceled__rj_nw (0)
        , canceled__rj_md (0)
        , canceled__rj_cc (0)
        , canceled__cf_ex (0)
        , canceled__cf_exLK (0)
        , canceled__cf_st (0)
        , executed__rq_nw (0)
        , executed__rq_md (0)
        , executed__rq_cc (0)
        , executed__cf_nw (0)
        , executed__cf_md (0)
        , executed__cf_cc (0)
        , executed__rj_nw (0)
        , executed__rj_md (0)
        , executed__rj_cc (0)
        , executed__cf_ex (0)
        , executed__cf_exLK (0)
        , executed__cf_st (0)
        , error__rq_nw (0)
        , error__rq_md (0)
        , error__rq_cc (0)
        , error__cf_nw (0)
        , error__cf_md (0)
        , error__cf_cc (0)
        , error__rj_nw (0)
        , error__rj_md (0)
        , error__rj_cc (0)
        , error__cf_ex (0)
        , error__cf_exLK (0)
        , error__cf_st (0)
    {}

    int   init__rq_nw;
    int   init__rq_md;
    int   init__rq_cc;
    int   init__cf_nw;
    int   init__cf_md;
    int   init__cf_cc;
    int   init__rj_nw;
    int   init__rj_md;
    int   init__rj_cc;
    int   init__cf_ex;
    int   init__cf_exLK;
    int   init__cf_st;
    int   w_cfnw__rq_nw;
    int   w_cfnw__rq_md;
    int   w_cfnw__rq_cc;
    int   w_cfnw__cf_nw;
    int   w_cfnw__cf_md;
    int   w_cfnw__cf_cc;
    int   w_cfnw__rj_nw;
    int   w_cfnw__rj_md;
    int   w_cfnw__rj_cc;
    int   w_cfnw__cf_ex;
    int   w_cfnw__cf_exLK;
    int   w_cfnw__cf_st;
    int   market__rq_nw;
    int   market__rq_md;
    int   market__rq_cc;
    int   market__cf_nw;
    int   market__cf_md;
    int   market__cf_cc;
    int   market__rj_nw;
    int   market__rj_md;
    int   market__rj_cc;
    int   market__cf_ex;
    int   market__cf_exLK;
    int   market__cf_st;
    int   w_cfmd__rq_nw;
    int   w_cfmd__rq_md;
    int   w_cfmd__rq_cc;
    int   w_cfmd__cf_nw;
    int   w_cfmd__cf_md;
    int   w_cfmd__cf_cc;
    int   w_cfmd__rj_nw;
    int   w_cfmd__rj_md;
    int   w_cfmd__rj_cc;
    int   w_cfmd__cf_ex;
    int   w_cfmd__cf_exLK;
    int   w_cfmd__cf_st;
    int   w_cfcc__rq_nw;
    int   w_cfcc__rq_md;
    int   w_cfcc__rq_cc;
    int   w_cfcc__cf_nw;
    int   w_cfcc__cf_md;
    int   w_cfcc__cf_cc;
    int   w_cfcc__rj_nw;
    int   w_cfcc__rj_md;
    int   w_cfcc__rj_cc;
    int   w_cfcc__cf_ex;
    int   w_cfcc__cf_exLK;
    int   w_cfcc__cf_st;
    int   w_cfmdcc__rq_nw;
    int   w_cfmdcc__rq_md;
    int   w_cfmdcc__rq_cc;
    int   w_cfmdcc__cf_nw;
    int   w_cfmdcc__cf_md;
    int   w_cfmdcc__cf_cc;
    int   w_cfmdcc__rj_nw;
    int   w_cfmdcc__rj_md;
    int   w_cfmdcc__rj_cc;
    int   w_cfmdcc__cf_ex;
    int   w_cfmdcc__cf_exLK;
    int   w_cfmdcc__cf_st;
    int   w_cfnwmd__rq_nw;
    int   w_cfnwmd__rq_md;
    int   w_cfnwmd__rq_cc;
    int   w_cfnwmd__cf_nw;
    int   w_cfnwmd__cf_md;
    int   w_cfnwmd__cf_cc;
    int   w_cfnwmd__rj_nw;
    int   w_cfnwmd__rj_md;
    int   w_cfnwmd__rj_cc;
    int   w_cfnwmd__cf_ex;
    int   w_cfnwmd__cf_exLK;
    int   w_cfnwmd__cf_st;
    int   w_cfnwcc__rq_nw;
    int   w_cfnwcc__rq_md;
    int   w_cfnwcc__rq_cc;
    int   w_cfnwcc__cf_nw;
    int   w_cfnwcc__cf_md;
    int   w_cfnwcc__cf_cc;
    int   w_cfnwcc__rj_nw;
    int   w_cfnwcc__rj_md;
    int   w_cfnwcc__rj_cc;
    int   w_cfnwcc__cf_ex;
    int   w_cfnwcc__cf_exLK;
    int   w_cfnwcc__cf_st;
    int   canceled__rq_nw;
    int   canceled__rq_md;
    int   canceled__rq_cc;
    int   canceled__cf_nw;
    int   canceled__cf_md;
    int   canceled__cf_cc;
    int   canceled__rj_nw;
    int   canceled__rj_md;
    int   canceled__rj_cc;
    int   canceled__cf_ex;
    int   canceled__cf_exLK;
    int   canceled__cf_st;
    int   executed__rq_nw;
    int   executed__rq_md;
    int   executed__rq_cc;
    int   executed__cf_nw;
    int   executed__cf_md;
    int   executed__cf_cc;
    int   executed__rj_nw;
    int   executed__rj_md;
    int   executed__rj_cc;
    int   executed__cf_ex;
    int   executed__cf_exLK;
    int   executed__cf_st;
    int   error__rq_nw;
    int   error__rq_md;
    int   error__rq_cc;
    int   error__cf_nw;
    int   error__cf_md;
    int   error__cf_cc;
    int   error__rj_nw;
    int   error__rj_md;
    int   error__rj_cc;
    int   error__cf_ex;
    int   error__cf_exLK;
    int   error__cf_st;

    std::string  get_string(void)
    {

        static mtk::dtDateTime  last_result_date_time = mtk::dtNowLocal() - mtk::dtDays(1);
        static std::string last_result = "";
        int num_touched=0;
        if(last_result_date_time + mtk::dtSeconds(30) > mtk::dtNowLocal())
            last_result = "";
              if(init__rq_nw)   {++num_touched; last_result += MTK_SS("init__rq_nw:" << init__rq_nw << std::endl);}
              if(init__rq_md)   {++num_touched; last_result += MTK_SS("init__rq_md:" << init__rq_md << std::endl);}
              if(init__rq_cc)   {++num_touched; last_result += MTK_SS("init__rq_cc:" << init__rq_cc << std::endl);}
              if(init__cf_nw)   {++num_touched; last_result += MTK_SS("init__cf_nw:" << init__cf_nw << std::endl);}
              if(init__cf_md)   {++num_touched; last_result += MTK_SS("init__cf_md:" << init__cf_md << std::endl);}
              if(init__cf_cc)   {++num_touched; last_result += MTK_SS("init__cf_cc:" << init__cf_cc << std::endl);}
              if(init__rj_nw)   {++num_touched; last_result += MTK_SS("init__rj_nw:" << init__rj_nw << std::endl);}
              if(init__rj_md)   {++num_touched; last_result += MTK_SS("init__rj_md:" << init__rj_md << std::endl);}
              if(init__rj_cc)   {++num_touched; last_result += MTK_SS("init__rj_cc:" << init__rj_cc << std::endl);}
              if(init__cf_ex)   {++num_touched; last_result += MTK_SS("init__cf_ex:" << init__cf_ex << std::endl);}
              if(init__cf_exLK)   {++num_touched; last_result += MTK_SS("init__cf_exLK:" << init__cf_exLK << std::endl);}
              if(init__cf_st)   {++num_touched; last_result += MTK_SS("init__cf_st:" << init__cf_st << std::endl);}
              if(w_cfnw__rq_nw)   {++num_touched; last_result += MTK_SS("w_cfnw__rq_nw:" << w_cfnw__rq_nw << std::endl);}
              if(w_cfnw__rq_md)   {++num_touched; last_result += MTK_SS("w_cfnw__rq_md:" << w_cfnw__rq_md << std::endl);}
              if(w_cfnw__rq_cc)   {++num_touched; last_result += MTK_SS("w_cfnw__rq_cc:" << w_cfnw__rq_cc << std::endl);}
              if(w_cfnw__cf_nw)   {++num_touched; last_result += MTK_SS("w_cfnw__cf_nw:" << w_cfnw__cf_nw << std::endl);}
              if(w_cfnw__cf_md)   {++num_touched; last_result += MTK_SS("w_cfnw__cf_md:" << w_cfnw__cf_md << std::endl);}
              if(w_cfnw__cf_cc)   {++num_touched; last_result += MTK_SS("w_cfnw__cf_cc:" << w_cfnw__cf_cc << std::endl);}
              if(w_cfnw__rj_nw)   {++num_touched; last_result += MTK_SS("w_cfnw__rj_nw:" << w_cfnw__rj_nw << std::endl);}
              if(w_cfnw__rj_md)   {++num_touched; last_result += MTK_SS("w_cfnw__rj_md:" << w_cfnw__rj_md << std::endl);}
              if(w_cfnw__rj_cc)   {++num_touched; last_result += MTK_SS("w_cfnw__rj_cc:" << w_cfnw__rj_cc << std::endl);}
              if(w_cfnw__cf_ex)   {++num_touched; last_result += MTK_SS("w_cfnw__cf_ex:" << w_cfnw__cf_ex << std::endl);}
              if(w_cfnw__cf_exLK)   {++num_touched; last_result += MTK_SS("w_cfnw__cf_exLK:" << w_cfnw__cf_exLK << std::endl);}
              if(w_cfnw__cf_st)   {++num_touched; last_result += MTK_SS("w_cfnw__cf_st:" << w_cfnw__cf_st << std::endl);}
              if(market__rq_nw)   {++num_touched; last_result += MTK_SS("market__rq_nw:" << market__rq_nw << std::endl);}
              if(market__rq_md)   {++num_touched; last_result += MTK_SS("market__rq_md:" << market__rq_md << std::endl);}
              if(market__rq_cc)   {++num_touched; last_result += MTK_SS("market__rq_cc:" << market__rq_cc << std::endl);}
              if(market__cf_nw)   {++num_touched; last_result += MTK_SS("market__cf_nw:" << market__cf_nw << std::endl);}
              if(market__cf_md)   {++num_touched; last_result += MTK_SS("market__cf_md:" << market__cf_md << std::endl);}
              if(market__cf_cc)   {++num_touched; last_result += MTK_SS("market__cf_cc:" << market__cf_cc << std::endl);}
              if(market__rj_nw)   {++num_touched; last_result += MTK_SS("market__rj_nw:" << market__rj_nw << std::endl);}
              if(market__rj_md)   {++num_touched; last_result += MTK_SS("market__rj_md:" << market__rj_md << std::endl);}
              if(market__rj_cc)   {++num_touched; last_result += MTK_SS("market__rj_cc:" << market__rj_cc << std::endl);}
              if(market__cf_ex)   {++num_touched; last_result += MTK_SS("market__cf_ex:" << market__cf_ex << std::endl);}
              if(market__cf_exLK)   {++num_touched; last_result += MTK_SS("market__cf_exLK:" << market__cf_exLK << std::endl);}
              if(market__cf_st)   {++num_touched; last_result += MTK_SS("market__cf_st:" << market__cf_st << std::endl);}
              if(w_cfmd__rq_nw)   {++num_touched; last_result += MTK_SS("w_cfmd__rq_nw:" << w_cfmd__rq_nw << std::endl);}
              if(w_cfmd__rq_md)   {++num_touched; last_result += MTK_SS("w_cfmd__rq_md:" << w_cfmd__rq_md << std::endl);}
              if(w_cfmd__rq_cc)   {++num_touched; last_result += MTK_SS("w_cfmd__rq_cc:" << w_cfmd__rq_cc << std::endl);}
              if(w_cfmd__cf_nw)   {++num_touched; last_result += MTK_SS("w_cfmd__cf_nw:" << w_cfmd__cf_nw << std::endl);}
              if(w_cfmd__cf_md)   {++num_touched; last_result += MTK_SS("w_cfmd__cf_md:" << w_cfmd__cf_md << std::endl);}
              if(w_cfmd__cf_cc)   {++num_touched; last_result += MTK_SS("w_cfmd__cf_cc:" << w_cfmd__cf_cc << std::endl);}
              if(w_cfmd__rj_nw)   {++num_touched; last_result += MTK_SS("w_cfmd__rj_nw:" << w_cfmd__rj_nw << std::endl);}
              if(w_cfmd__rj_md)   {++num_touched; last_result += MTK_SS("w_cfmd__rj_md:" << w_cfmd__rj_md << std::endl);}
              if(w_cfmd__rj_cc)   {++num_touched; last_result += MTK_SS("w_cfmd__rj_cc:" << w_cfmd__rj_cc << std::endl);}
              if(w_cfmd__cf_ex)   {++num_touched; last_result += MTK_SS("w_cfmd__cf_ex:" << w_cfmd__cf_ex << std::endl);}
              if(w_cfmd__cf_exLK)   {++num_touched; last_result += MTK_SS("w_cfmd__cf_exLK:" << w_cfmd__cf_exLK << std::endl);}
              if(w_cfmd__cf_st)   {++num_touched; last_result += MTK_SS("w_cfmd__cf_st:" << w_cfmd__cf_st << std::endl);}
              if(w_cfcc__rq_nw)   {++num_touched; last_result += MTK_SS("w_cfcc__rq_nw:" << w_cfcc__rq_nw << std::endl);}
              if(w_cfcc__rq_md)   {++num_touched; last_result += MTK_SS("w_cfcc__rq_md:" << w_cfcc__rq_md << std::endl);}
              if(w_cfcc__rq_cc)   {++num_touched; last_result += MTK_SS("w_cfcc__rq_cc:" << w_cfcc__rq_cc << std::endl);}
              if(w_cfcc__cf_nw)   {++num_touched; last_result += MTK_SS("w_cfcc__cf_nw:" << w_cfcc__cf_nw << std::endl);}
              if(w_cfcc__cf_md)   {++num_touched; last_result += MTK_SS("w_cfcc__cf_md:" << w_cfcc__cf_md << std::endl);}
              if(w_cfcc__cf_cc)   {++num_touched; last_result += MTK_SS("w_cfcc__cf_cc:" << w_cfcc__cf_cc << std::endl);}
              if(w_cfcc__rj_nw)   {++num_touched; last_result += MTK_SS("w_cfcc__rj_nw:" << w_cfcc__rj_nw << std::endl);}
              if(w_cfcc__rj_md)   {++num_touched; last_result += MTK_SS("w_cfcc__rj_md:" << w_cfcc__rj_md << std::endl);}
              if(w_cfcc__rj_cc)   {++num_touched; last_result += MTK_SS("w_cfcc__rj_cc:" << w_cfcc__rj_cc << std::endl);}
              if(w_cfcc__cf_ex)   {++num_touched; last_result += MTK_SS("w_cfcc__cf_ex:" << w_cfcc__cf_ex << std::endl);}
              if(w_cfcc__cf_exLK)   {++num_touched; last_result += MTK_SS("w_cfcc__cf_exLK:" << w_cfcc__cf_exLK << std::endl);}
              if(w_cfcc__cf_st)   {++num_touched; last_result += MTK_SS("w_cfcc__cf_st:" << w_cfcc__cf_st << std::endl);}
              if(w_cfmdcc__rq_nw)   {++num_touched; last_result += MTK_SS("w_cfmdcc__rq_nw:" << w_cfmdcc__rq_nw << std::endl);}
              if(w_cfmdcc__rq_md)   {++num_touched; last_result += MTK_SS("w_cfmdcc__rq_md:" << w_cfmdcc__rq_md << std::endl);}
              if(w_cfmdcc__rq_cc)   {++num_touched; last_result += MTK_SS("w_cfmdcc__rq_cc:" << w_cfmdcc__rq_cc << std::endl);}
              if(w_cfmdcc__cf_nw)   {++num_touched; last_result += MTK_SS("w_cfmdcc__cf_nw:" << w_cfmdcc__cf_nw << std::endl);}
              if(w_cfmdcc__cf_md)   {++num_touched; last_result += MTK_SS("w_cfmdcc__cf_md:" << w_cfmdcc__cf_md << std::endl);}
              if(w_cfmdcc__cf_cc)   {++num_touched; last_result += MTK_SS("w_cfmdcc__cf_cc:" << w_cfmdcc__cf_cc << std::endl);}
              if(w_cfmdcc__rj_nw)   {++num_touched; last_result += MTK_SS("w_cfmdcc__rj_nw:" << w_cfmdcc__rj_nw << std::endl);}
              if(w_cfmdcc__rj_md)   {++num_touched; last_result += MTK_SS("w_cfmdcc__rj_md:" << w_cfmdcc__rj_md << std::endl);}
              if(w_cfmdcc__rj_cc)   {++num_touched; last_result += MTK_SS("w_cfmdcc__rj_cc:" << w_cfmdcc__rj_cc << std::endl);}
              if(w_cfmdcc__cf_ex)   {++num_touched; last_result += MTK_SS("w_cfmdcc__cf_ex:" << w_cfmdcc__cf_ex << std::endl);}
              if(w_cfmdcc__cf_exLK)   {++num_touched; last_result += MTK_SS("w_cfmdcc__cf_exLK:" << w_cfmdcc__cf_exLK << std::endl);}
              if(w_cfmdcc__cf_st)   {++num_touched; last_result += MTK_SS("w_cfmdcc__cf_st:" << w_cfmdcc__cf_st << std::endl);}
              if(w_cfnwmd__rq_nw)   {++num_touched; last_result += MTK_SS("w_cfnwmd__rq_nw:" << w_cfnwmd__rq_nw << std::endl);}
              if(w_cfnwmd__rq_md)   {++num_touched; last_result += MTK_SS("w_cfnwmd__rq_md:" << w_cfnwmd__rq_md << std::endl);}
              if(w_cfnwmd__rq_cc)   {++num_touched; last_result += MTK_SS("w_cfnwmd__rq_cc:" << w_cfnwmd__rq_cc << std::endl);}
              if(w_cfnwmd__cf_nw)   {++num_touched; last_result += MTK_SS("w_cfnwmd__cf_nw:" << w_cfnwmd__cf_nw << std::endl);}
              if(w_cfnwmd__cf_md)   {++num_touched; last_result += MTK_SS("w_cfnwmd__cf_md:" << w_cfnwmd__cf_md << std::endl);}
              if(w_cfnwmd__cf_cc)   {++num_touched; last_result += MTK_SS("w_cfnwmd__cf_cc:" << w_cfnwmd__cf_cc << std::endl);}
              if(w_cfnwmd__rj_nw)   {++num_touched; last_result += MTK_SS("w_cfnwmd__rj_nw:" << w_cfnwmd__rj_nw << std::endl);}
              if(w_cfnwmd__rj_md)   {++num_touched; last_result += MTK_SS("w_cfnwmd__rj_md:" << w_cfnwmd__rj_md << std::endl);}
              if(w_cfnwmd__rj_cc)   {++num_touched; last_result += MTK_SS("w_cfnwmd__rj_cc:" << w_cfnwmd__rj_cc << std::endl);}
              if(w_cfnwmd__cf_ex)   {++num_touched; last_result += MTK_SS("w_cfnwmd__cf_ex:" << w_cfnwmd__cf_ex << std::endl);}
              if(w_cfnwmd__cf_exLK)   {++num_touched; last_result += MTK_SS("w_cfnwmd__cf_exLK:" << w_cfnwmd__cf_exLK << std::endl);}
              if(w_cfnwmd__cf_st)   {++num_touched; last_result += MTK_SS("w_cfnwmd__cf_st:" << w_cfnwmd__cf_st << std::endl);}
              if(w_cfnwcc__rq_nw)   {++num_touched; last_result += MTK_SS("w_cfnwcc__rq_nw:" << w_cfnwcc__rq_nw << std::endl);}
              if(w_cfnwcc__rq_md)   {++num_touched; last_result += MTK_SS("w_cfnwcc__rq_md:" << w_cfnwcc__rq_md << std::endl);}
              if(w_cfnwcc__rq_cc)   {++num_touched; last_result += MTK_SS("w_cfnwcc__rq_cc:" << w_cfnwcc__rq_cc << std::endl);}
              if(w_cfnwcc__cf_nw)   {++num_touched; last_result += MTK_SS("w_cfnwcc__cf_nw:" << w_cfnwcc__cf_nw << std::endl);}
              if(w_cfnwcc__cf_md)   {++num_touched; last_result += MTK_SS("w_cfnwcc__cf_md:" << w_cfnwcc__cf_md << std::endl);}
              if(w_cfnwcc__cf_cc)   {++num_touched; last_result += MTK_SS("w_cfnwcc__cf_cc:" << w_cfnwcc__cf_cc << std::endl);}
              if(w_cfnwcc__rj_nw)   {++num_touched; last_result += MTK_SS("w_cfnwcc__rj_nw:" << w_cfnwcc__rj_nw << std::endl);}
              if(w_cfnwcc__rj_md)   {++num_touched; last_result += MTK_SS("w_cfnwcc__rj_md:" << w_cfnwcc__rj_md << std::endl);}
              if(w_cfnwcc__rj_cc)   {++num_touched; last_result += MTK_SS("w_cfnwcc__rj_cc:" << w_cfnwcc__rj_cc << std::endl);}
              if(w_cfnwcc__cf_ex)   {++num_touched; last_result += MTK_SS("w_cfnwcc__cf_ex:" << w_cfnwcc__cf_ex << std::endl);}
              if(w_cfnwcc__cf_exLK)   {++num_touched; last_result += MTK_SS("w_cfnwcc__cf_exLK:" << w_cfnwcc__cf_exLK << std::endl);}
              if(w_cfnwcc__cf_st)   {++num_touched; last_result += MTK_SS("w_cfnwcc__cf_st:" << w_cfnwcc__cf_st << std::endl);}
              if(canceled__rq_nw)   {++num_touched; last_result += MTK_SS("canceled__rq_nw:" << canceled__rq_nw << std::endl);}
              if(canceled__rq_md)   {++num_touched; last_result += MTK_SS("canceled__rq_md:" << canceled__rq_md << std::endl);}
              if(canceled__rq_cc)   {++num_touched; last_result += MTK_SS("canceled__rq_cc:" << canceled__rq_cc << std::endl);}
              if(canceled__cf_nw)   {++num_touched; last_result += MTK_SS("canceled__cf_nw:" << canceled__cf_nw << std::endl);}
              if(canceled__cf_md)   {++num_touched; last_result += MTK_SS("canceled__cf_md:" << canceled__cf_md << std::endl);}
              if(canceled__cf_cc)   {++num_touched; last_result += MTK_SS("canceled__cf_cc:" << canceled__cf_cc << std::endl);}
              if(canceled__rj_nw)   {++num_touched; last_result += MTK_SS("canceled__rj_nw:" << canceled__rj_nw << std::endl);}
              if(canceled__rj_md)   {++num_touched; last_result += MTK_SS("canceled__rj_md:" << canceled__rj_md << std::endl);}
              if(canceled__rj_cc)   {++num_touched; last_result += MTK_SS("canceled__rj_cc:" << canceled__rj_cc << std::endl);}
              if(canceled__cf_ex)   {++num_touched; last_result += MTK_SS("canceled__cf_ex:" << canceled__cf_ex << std::endl);}
              if(canceled__cf_exLK)   {++num_touched; last_result += MTK_SS("canceled__cf_exLK:" << canceled__cf_exLK << std::endl);}
              if(canceled__cf_st)   {++num_touched; last_result += MTK_SS("canceled__cf_st:" << canceled__cf_st << std::endl);}
              if(executed__rq_nw)   {++num_touched; last_result += MTK_SS("executed__rq_nw:" << executed__rq_nw << std::endl);}
              if(executed__rq_md)   {++num_touched; last_result += MTK_SS("executed__rq_md:" << executed__rq_md << std::endl);}
              if(executed__rq_cc)   {++num_touched; last_result += MTK_SS("executed__rq_cc:" << executed__rq_cc << std::endl);}
              if(executed__cf_nw)   {++num_touched; last_result += MTK_SS("executed__cf_nw:" << executed__cf_nw << std::endl);}
              if(executed__cf_md)   {++num_touched; last_result += MTK_SS("executed__cf_md:" << executed__cf_md << std::endl);}
              if(executed__cf_cc)   {++num_touched; last_result += MTK_SS("executed__cf_cc:" << executed__cf_cc << std::endl);}
              if(executed__rj_nw)   {++num_touched; last_result += MTK_SS("executed__rj_nw:" << executed__rj_nw << std::endl);}
              if(executed__rj_md)   {++num_touched; last_result += MTK_SS("executed__rj_md:" << executed__rj_md << std::endl);}
              if(executed__rj_cc)   {++num_touched; last_result += MTK_SS("executed__rj_cc:" << executed__rj_cc << std::endl);}
              if(executed__cf_ex)   {++num_touched; last_result += MTK_SS("executed__cf_ex:" << executed__cf_ex << std::endl);}
              if(executed__cf_exLK)   {++num_touched; last_result += MTK_SS("executed__cf_exLK:" << executed__cf_exLK << std::endl);}
              if(executed__cf_st)   {++num_touched; last_result += MTK_SS("executed__cf_st:" << executed__cf_st << std::endl);}
              if(error__rq_nw)   {++num_touched; last_result += MTK_SS("error__rq_nw:" << error__rq_nw << std::endl);}
              if(error__rq_md)   {++num_touched; last_result += MTK_SS("error__rq_md:" << error__rq_md << std::endl);}
              if(error__rq_cc)   {++num_touched; last_result += MTK_SS("error__rq_cc:" << error__rq_cc << std::endl);}
              if(error__cf_nw)   {++num_touched; last_result += MTK_SS("error__cf_nw:" << error__cf_nw << std::endl);}
              if(error__cf_md)   {++num_touched; last_result += MTK_SS("error__cf_md:" << error__cf_md << std::endl);}
              if(error__cf_cc)   {++num_touched; last_result += MTK_SS("error__cf_cc:" << error__cf_cc << std::endl);}
              if(error__rj_nw)   {++num_touched; last_result += MTK_SS("error__rj_nw:" << error__rj_nw << std::endl);}
              if(error__rj_md)   {++num_touched; last_result += MTK_SS("error__rj_md:" << error__rj_md << std::endl);}
              if(error__rj_cc)   {++num_touched; last_result += MTK_SS("error__rj_cc:" << error__rj_cc << std::endl);}
              if(error__cf_ex)   {++num_touched; last_result += MTK_SS("error__cf_ex:" << error__cf_ex << std::endl);}
              if(error__cf_exLK)   {++num_touched; last_result += MTK_SS("error__cf_exLK:" << error__cf_exLK << std::endl);}
              if(error__cf_st)   {++num_touched; last_result += MTK_SS("error__cf_st:" << error__cf_st << std::endl);}

        last_result += MTK_SS("__num_touched__:"  <<  num_touched);
        return last_result;

    }
};


// -----------------------------------------------------------------------
//      s t a t u s _ c o m m o n _ i n f o

struct  status_common_info
{
    status_common_info ( mtk::Signal<const mtk::trd::msg::RQ_NW_LS&   /*rq*/         >& _sig_rq_nw, mtk::Signal<const mtk::trd::msg::RQ_MD_LS&   /*rq*/         >& _sig_rq_md, mtk::Signal<const mtk::trd::msg::RQ_CC_LS&   /*rq*/         >& _sig_rq_cc, mtk::Signal<const mtk::trd::msg::RJ_NW_LS&   /*rj*/         >& _sig_rj_nw, mtk::Signal<const mtk::trd::msg::RJ_MD_LS&   /*rj*/         >& _sig_rj_md, mtk::Signal<const mtk::trd::msg::RJ_CC_LS&   /*rj*/         >& _sig_rj_cc, mtk::Signal<const mtk::trd::msg::CF_NW_LS&   /*cf*/         >& _sig_cf_nw, mtk::Signal<const mtk::trd::msg::CF_MD_LS&   /*cf*/         >& _sig_cf_md, mtk::Signal<const mtk::trd::msg::CF_CC_LS&   /*cf*/         >& _sig_cf_cc, mtk::Signal<const mtk::trd::msg::CF_EX_LS&   /*ex*/         >& _sig_cf_ex, mtk::Signal<const mtk::trd::msg::CF_ST_LS&   /*st*/         >& _sig_cf_st, mtk::Signal<>& _sig_changed)
        :  
        __last_confirmation(mtk::nullable<mtk::trd::msg::CF_XX_LS>() ),
        __last_request(mtk::nullable<mtk::trd::msg::RQ_XX_LS>() ),
        __history(mtk::make_cptr(new mtk::trd::hist::order_historic_dangerous_not_signal_warped)       ),
        __executions(mtk::make_cptr(new mtk::trd::hist::order_EXECS_historic_dangerous_not_signal_warped) ),
        __serrors(""), 
        sig_rq_nw (_sig_rq_nw), 
        sig_rq_md (_sig_rq_md), 
        sig_rq_cc (_sig_rq_cc), 
        sig_rj_nw (_sig_rj_nw), 
        sig_rj_md (_sig_rj_md), 
        sig_rj_cc (_sig_rj_cc), 
        sig_cf_nw (_sig_cf_nw), 
        sig_cf_md (_sig_cf_md), 
        sig_cf_cc (_sig_cf_cc), 
        sig_cf_ex (_sig_cf_ex), 
        sig_cf_st (_sig_cf_st), 
        sig_changed (_sig_changed)
        {};
    virtual ~status_common_info(){};

    // PROPERTIES AND SIGNALS
    mtk::nullable<mtk::trd::msg::CF_XX_LS>           __last_confirmation;
    virtual const mtk::nullable<mtk::trd::msg::CF_XX_LS>          &  last_confirmation() const {  return __last_confirmation; };
    virtual void set_last_confirmation(const mtk::nullable<mtk::trd::msg::CF_XX_LS>          &  _prop) {  __last_confirmation = _prop;  };
    mtk::nullable<mtk::trd::msg::RQ_XX_LS>           __last_request;
    virtual const mtk::nullable<mtk::trd::msg::RQ_XX_LS>          &  last_request() const {  return __last_request; };
    virtual void set_last_request(const mtk::nullable<mtk::trd::msg::RQ_XX_LS>          &  _prop) {  __last_request = _prop;  };
    mtk::CountPtr<mtk::trd::hist::order_historic_dangerous_not_signal_warped      >   __history;
    virtual const mtk::CountPtr<mtk::trd::hist::order_historic_dangerous_not_signal_warped      >  &  history() const {  return __history; };
    virtual void set_history(const mtk::CountPtr<mtk::trd::hist::order_historic_dangerous_not_signal_warped      >  &  _prop) {  __history = _prop;  };
    mtk::CountPtr<mtk::trd::hist::order_EXECS_historic_dangerous_not_signal_warped>   __executions;
    virtual const mtk::CountPtr<mtk::trd::hist::order_EXECS_historic_dangerous_not_signal_warped>  &  executions() const {  return __executions; };
    virtual void set_executions(const mtk::CountPtr<mtk::trd::hist::order_EXECS_historic_dangerous_not_signal_warped>  &  _prop) {  __executions = _prop;  };
    virtual const bool                                             &  in_market() const {  static bool                                             result(false);   return result; };
    virtual void set_in_market(const bool                                            & ) {  throw mtk::Alarm(MTK_HERE, "fsm_gen.set_property", "property not valid in current status", mtk::alPriorError);  };
    virtual const bool                                             &  is_canceled() const {  static bool                                             result(false);   return result; };
    virtual void set_is_canceled(const bool                                            & ) {  throw mtk::Alarm(MTK_HERE, "fsm_gen.set_property", "property not valid in current status", mtk::alPriorError);  };
    virtual const bool                                             &  is_full_executed() const {  static bool                                             result(false);   return result; };
    virtual void set_is_full_executed(const bool                                            & ) {  throw mtk::Alarm(MTK_HERE, "fsm_gen.set_property", "property not valid in current status", mtk::alPriorError);  };
    virtual const bool                                             &  has_pending_rq() const {  static bool                                             result(false);   return result; };
    virtual void set_has_pending_rq(const bool                                            & ) {  throw mtk::Alarm(MTK_HERE, "fsm_gen.set_property", "property not valid in current status", mtk::alPriorError);  };
    std::string                                      __serrors;
    virtual const std::string                                     &  serrors() const {  return __serrors; };
    virtual void set_serrors(const std::string                                     &  _prop) {  __serrors = _prop;  };
    mtk::Signal<const mtk::trd::msg::RQ_NW_LS&   /*rq*/         >& sig_rq_nw;
    mtk::Signal<const mtk::trd::msg::RQ_MD_LS&   /*rq*/         >& sig_rq_md;
    mtk::Signal<const mtk::trd::msg::RQ_CC_LS&   /*rq*/         >& sig_rq_cc;
    mtk::Signal<const mtk::trd::msg::RJ_NW_LS&   /*rj*/         >& sig_rj_nw;
    mtk::Signal<const mtk::trd::msg::RJ_MD_LS&   /*rj*/         >& sig_rj_md;
    mtk::Signal<const mtk::trd::msg::RJ_CC_LS&   /*rj*/         >& sig_rj_cc;
    mtk::Signal<const mtk::trd::msg::CF_NW_LS&   /*cf*/         >& sig_cf_nw;
    mtk::Signal<const mtk::trd::msg::CF_MD_LS&   /*cf*/         >& sig_cf_md;
    mtk::Signal<const mtk::trd::msg::CF_CC_LS&   /*cf*/         >& sig_cf_cc;
    mtk::Signal<const mtk::trd::msg::CF_EX_LS&   /*ex*/         >& sig_cf_ex;
    mtk::Signal<const mtk::trd::msg::CF_ST_LS&   /*st*/         >& sig_cf_st;
    mtk::Signal<>& sig_changed;


    mtk::Signal<mtk::CountPtr<abstract_status> > signal_new_status;
    mtk::Signal<> signal_keep_temp_status;
    mtk::Signal<> signal_remove_temp_status;


    //  STATS AND COVERAGE
    static  scoverage     coverage;
};

scoverage status_common_info::coverage;





// -----------------------------------------------------------------------
//      abstract_status
class abstract_status  : public mtk::SignalReceptor
{
    mtk::non_copyable  nc;

public:
    abstract_status (mtk::CountPtr<status_common_info> _ci)
        : ci (_ci) {};
    virtual ~abstract_status() {};
    
    mtk::CountPtr<status_common_info> ci;
    
    virtual std::string  GetStatusName() = 0;

    //  INPUTS
    virtual void rq_nw ( const mtk::trd::msg::RQ_NW_LS&   rq           )=0;
    virtual void rq_md ( const mtk::trd::msg::RQ_MD_LS&   rq           )=0;
    virtual void rq_cc ( const mtk::trd::msg::RQ_CC_LS&   rq           )=0;
    virtual void cf_nw ( const mtk::trd::msg::CF_NW_LS&   cf           )=0;
    virtual void cf_md ( const mtk::trd::msg::CF_MD_LS&   cf           )=0;
    virtual void cf_cc ( const mtk::trd::msg::CF_CC_LS&   cf           )=0;
    virtual void rj_nw ( const mtk::trd::msg::RJ_NW_LS&   rj           )=0;
    virtual void rj_md ( const mtk::trd::msg::RJ_MD_LS&   rj           )=0;
    virtual void rj_cc ( const mtk::trd::msg::RJ_CC_LS&   rj           )=0;
    virtual void cf_ex ( const mtk::trd::msg::CF_EX_LS&   ex           )=0;
    virtual void cf_exLK ( const mtk::trd::msg::CF_EXLK&   exlk         )=0;
    virtual void cf_st ( const mtk::trd::msg::CF_ST_LS&   st           )=0;


    //  ACCESS
    virtual const mtk::nullable<mtk::trd::msg::CF_XX_LS>           &  last_confirmation (void) const { return ci->last_confirmation(); }; 
    virtual const mtk::nullable<mtk::trd::msg::RQ_XX_LS>           &  last_request (void) const { return ci->last_request(); }; 
    virtual const mtk::CountPtr<mtk::trd::hist::order_historic_dangerous_not_signal_warped      >   &  history (void) const { return ci->history(); }; 
    virtual const mtk::CountPtr<mtk::trd::hist::order_EXECS_historic_dangerous_not_signal_warped>   &  executions (void) const { return ci->executions(); }; 
    virtual const bool                                             &  in_market (void) const { return ci->in_market(); }; 
    virtual const bool                                             &  is_canceled (void) const { return ci->is_canceled(); }; 
    virtual const bool                                             &  is_full_executed (void) const { return ci->is_full_executed(); }; 
    virtual const bool                                             &  has_pending_rq (void) const { return ci->has_pending_rq(); }; 
    virtual const std::string                                      &  serrors (void) const { return ci->serrors(); }; 


    //  COVERAGE
    std::string  get_coverage_string(void)  { return ci->coverage.get_string(); };
};





// -----------------------------------------------------------------------
//      init
class init  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef init  CLASS_NAME;

public:
    init (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci)

        {  };
    
    std::string  GetStatusName()  {  return "init"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_LS&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_LS&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_LS&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_LS&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_LS&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_LS&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_LS&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_LS&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_LS&   rj           );
    void cf_ex (const mtk::trd::msg::CF_EX_LS&   ex           );
    void cf_exLK (const mtk::trd::msg::CF_EXLK&   exlk         );
    void cf_st (const mtk::trd::msg::CF_ST_LS&   st           );


};



// -----------------------------------------------------------------------
//      w_cfnw
class w_cfnw  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef w_cfnw  CLASS_NAME;

public:
    w_cfnw (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci),
        __has_pending_rq(true)
        {  };
    
    std::string  GetStatusName()  {  return "w_cfnw"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    bool                                         __has_pending_rq;
    virtual const bool                                        &  has_pending_rq() const {  return __has_pending_rq; };
    virtual void set_has_pending_rq(const bool                                        &  _prop) {  __has_pending_rq = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_LS&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_LS&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_LS&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_LS&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_LS&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_LS&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_LS&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_LS&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_LS&   rj           );
    void cf_ex (const mtk::trd::msg::CF_EX_LS&   ex           );
    void cf_exLK (const mtk::trd::msg::CF_EXLK&   exlk         );
    void cf_st (const mtk::trd::msg::CF_ST_LS&   st           );


};



// -----------------------------------------------------------------------
//      market
class market  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef market  CLASS_NAME;

public:
    market (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci),
        __in_market(true)
        {  };
    
    std::string  GetStatusName()  {  return "market"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    bool                                         __in_market;
    virtual const bool                                        &  in_market() const {  return __in_market; };
    virtual void set_in_market(const bool                                        &  _prop) {  __in_market = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_LS&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_LS&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_LS&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_LS&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_LS&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_LS&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_LS&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_LS&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_LS&   rj           );
    void cf_ex (const mtk::trd::msg::CF_EX_LS&   ex           );
    void cf_exLK (const mtk::trd::msg::CF_EXLK&   exlk         );
    void cf_st (const mtk::trd::msg::CF_ST_LS&   st           );


};



// -----------------------------------------------------------------------
//      w_cfmd
class w_cfmd  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef w_cfmd  CLASS_NAME;

public:
    w_cfmd (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci),
        __has_pending_rq(true)
        {  };
    
    std::string  GetStatusName()  {  return "w_cfmd"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    bool                                         __has_pending_rq;
    virtual const bool                                        &  has_pending_rq() const {  return __has_pending_rq; };
    virtual void set_has_pending_rq(const bool                                        &  _prop) {  __has_pending_rq = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_LS&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_LS&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_LS&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_LS&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_LS&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_LS&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_LS&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_LS&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_LS&   rj           );
    void cf_ex (const mtk::trd::msg::CF_EX_LS&   ex           );
    void cf_exLK (const mtk::trd::msg::CF_EXLK&   exlk         );
    void cf_st (const mtk::trd::msg::CF_ST_LS&   st           );


};



// -----------------------------------------------------------------------
//      w_cfcc
class w_cfcc  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef w_cfcc  CLASS_NAME;

public:
    w_cfcc (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci),
        __has_pending_rq(true)
        {  };
    
    std::string  GetStatusName()  {  return "w_cfcc"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    bool                                         __has_pending_rq;
    virtual const bool                                        &  has_pending_rq() const {  return __has_pending_rq; };
    virtual void set_has_pending_rq(const bool                                        &  _prop) {  __has_pending_rq = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_LS&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_LS&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_LS&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_LS&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_LS&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_LS&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_LS&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_LS&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_LS&   rj           );
    void cf_ex (const mtk::trd::msg::CF_EX_LS&   ex           );
    void cf_exLK (const mtk::trd::msg::CF_EXLK&   exlk         );
    void cf_st (const mtk::trd::msg::CF_ST_LS&   st           );


};



// -----------------------------------------------------------------------
//      w_cfmdcc
class w_cfmdcc  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef w_cfmdcc  CLASS_NAME;

public:
    w_cfmdcc (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci),
        __has_pending_rq(true)
        {  };
    
    std::string  GetStatusName()  {  return "w_cfmdcc"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    bool                                         __has_pending_rq;
    virtual const bool                                        &  has_pending_rq() const {  return __has_pending_rq; };
    virtual void set_has_pending_rq(const bool                                        &  _prop) {  __has_pending_rq = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_LS&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_LS&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_LS&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_LS&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_LS&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_LS&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_LS&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_LS&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_LS&   rj           );
    void cf_ex (const mtk::trd::msg::CF_EX_LS&   ex           );
    void cf_exLK (const mtk::trd::msg::CF_EXLK&   exlk         );
    void cf_st (const mtk::trd::msg::CF_ST_LS&   st           );


};



// -----------------------------------------------------------------------
//      w_cfnwmd
class w_cfnwmd  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef w_cfnwmd  CLASS_NAME;

public:
    w_cfnwmd (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci),
        __has_pending_rq(true)
        {  };
    
    std::string  GetStatusName()  {  return "w_cfnwmd"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    bool                                         __has_pending_rq;
    virtual const bool                                        &  has_pending_rq() const {  return __has_pending_rq; };
    virtual void set_has_pending_rq(const bool                                        &  _prop) {  __has_pending_rq = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_LS&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_LS&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_LS&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_LS&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_LS&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_LS&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_LS&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_LS&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_LS&   rj           );
    void cf_ex (const mtk::trd::msg::CF_EX_LS&   ex           );
    void cf_exLK (const mtk::trd::msg::CF_EXLK&   exlk         );
    void cf_st (const mtk::trd::msg::CF_ST_LS&   st           );


};



// -----------------------------------------------------------------------
//      w_cfnwcc
class w_cfnwcc  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef w_cfnwcc  CLASS_NAME;

public:
    w_cfnwcc (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci),
        __has_pending_rq(true)
        {  };
    
    std::string  GetStatusName()  {  return "w_cfnwcc"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    bool                                         __has_pending_rq;
    virtual const bool                                        &  has_pending_rq() const {  return __has_pending_rq; };
    virtual void set_has_pending_rq(const bool                                        &  _prop) {  __has_pending_rq = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_LS&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_LS&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_LS&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_LS&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_LS&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_LS&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_LS&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_LS&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_LS&   rj           );
    void cf_ex (const mtk::trd::msg::CF_EX_LS&   ex           );
    void cf_exLK (const mtk::trd::msg::CF_EXLK&   exlk         );
    void cf_st (const mtk::trd::msg::CF_ST_LS&   st           );


};



// -----------------------------------------------------------------------
//      canceled
class canceled  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef canceled  CLASS_NAME;

public:
    canceled (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci),
        __is_canceled(true)
        {  };
    
    std::string  GetStatusName()  {  return "canceled"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    bool                                         __is_canceled;
    virtual const bool                                        &  is_canceled() const {  return __is_canceled; };
    virtual void set_is_canceled(const bool                                        &  _prop) {  __is_canceled = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_LS&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_LS&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_LS&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_LS&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_LS&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_LS&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_LS&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_LS&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_LS&   rj           );
    void cf_ex (const mtk::trd::msg::CF_EX_LS&   ex           );
    void cf_exLK (const mtk::trd::msg::CF_EXLK&   exlk         );
    void cf_st (const mtk::trd::msg::CF_ST_LS&   st           );


};



// -----------------------------------------------------------------------
//      executed
class executed  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef executed  CLASS_NAME;

public:
    executed (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci),
        __is_full_executed(true)
        {  };
    
    std::string  GetStatusName()  {  return "executed"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    bool                                         __is_full_executed;
    virtual const bool                                        &  is_full_executed() const {  return __is_full_executed; };
    virtual void set_is_full_executed(const bool                                        &  _prop) {  __is_full_executed = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_LS&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_LS&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_LS&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_LS&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_LS&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_LS&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_LS&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_LS&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_LS&   rj           );
    void cf_ex (const mtk::trd::msg::CF_EX_LS&   ex           );
    void cf_exLK (const mtk::trd::msg::CF_EXLK&   exlk         );
    void cf_st (const mtk::trd::msg::CF_ST_LS&   st           );


};



// -----------------------------------------------------------------------
//      error
class error  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef error  CLASS_NAME;

public:
    error (mtk::CountPtr<status_common_info> _ci,  const std::string                                      & _description)
        : 
        abstract_status(_ci),
        __description(_description)
        { 
            try
            {
                
            ci->__serrors += std::string(", ") + description();
            mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", description(), mtk::alPriorCritic, mtk::alTypeNoPermisions));
      
            }
            MTK_CATCH_RETHROW("error_ctor", "rethrowed") };
    
    std::string  GetStatusName()  {  return "error"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    std::string                                       __description;
    virtual const std::string                                      &  description() const {  return __description; };
    virtual void set_description(const std::string                                      &  _prop) {  __description = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_LS&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_LS&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_LS&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_LS&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_LS&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_LS&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_LS&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_LS&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_LS&   rj           );
    void cf_ex (const mtk::trd::msg::CF_EX_LS&   ex           );
    void cf_exLK (const mtk::trd::msg::CF_EXLK&   exlk         );
    void cf_st (const mtk::trd::msg::CF_ST_LS&   st           );


};






void init::rq_nw ( const mtk::trd::msg::RQ_NW_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.init__rq_nw;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "init::rq_nw";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_rq

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid rqnw ")       ));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 CREATE_AND_SEND_REJECT(sig_rj_nw, RJ_NW_LS, MTK_SS(ci->__serrors << " in " << method_name))      ADD_HIST_RJ(csr_rj, nw)      ci->sig_changed();  

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnw (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_rqnw
  ADD_HIST_RQ(rq, nw)     ci->sig_rq_nw(rq);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::rq_md ( const mtk::trd::msg::RQ_MD_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.init__rq_md;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "init::rq_md";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_MOD_AND_WRITE_LAST_REQ  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 std::string rj_message = MTK_SS(ci->__serrors << " in " << method_name);
                       if(qty_lower_exec)
                            rj_message =  " quantity lower than executed quantity  " +  rj_message;
                        CREATE_AND_SEND_REJECT(sig_rj_md, RJ_MD_LS, rj_message) ADD_HIST_RJ(csr_rj, md)      ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::rq_cc ( const mtk::trd::msg::RQ_CC_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.init__rq_cc;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "init::rq_cc";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqcc
 CREATE_AND_SEND_REJECT(sig_rj_cc, RJ_CC_LS, MTK_SS(ci->__serrors << " in " << method_name))      ADD_HIST_RJ(csr_rj, cc)      ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::cf_nw ( const mtk::trd::msg::CF_NW_LS&   cf            )
{
    //  coverage
    ++status_common_info::coverage.init__cf_nw;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "init::cf_nw";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::cf_md ( const mtk::trd::msg::CF_MD_LS&   cf            )
{
    //  coverage
    ++status_common_info::coverage.init__cf_md;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "init::cf_md";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::cf_cc ( const mtk::trd::msg::CF_CC_LS&   cf            )
{
    //  coverage
    ++status_common_info::coverage.init__cf_cc;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "init::cf_cc";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::rj_nw ( const mtk::trd::msg::RJ_NW_LS&   rj            )
{
    //  coverage
    ++status_common_info::coverage.init__rj_nw;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "init::rj_nw";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::rj_md ( const mtk::trd::msg::RJ_MD_LS&   rj            )
{
    //  coverage
    ++status_common_info::coverage.init__rj_md;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "init::rj_md";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::rj_cc ( const mtk::trd::msg::RJ_CC_LS&   rj            )
{
    //  coverage
    ++status_common_info::coverage.init__rj_cc;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "init::rj_cc";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::cf_ex ( const mtk::trd::msg::CF_EX_LS&   ex            )
{
    //  coverage
    ++status_common_info::coverage.init__cf_ex;

    //  remove unused warning
    (void) ex;

    
	static const char* method_name = "init::cf_ex";

    
                                int nerrors=0;
                                CHECK_EXEC
                                const mtk::trd::msg::CF_XX_LS& cf(ex);
                                CHECK_CONFIRM_AND_WRITE_LAST_CONF
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: full_exec

                    last_confirmation().HasValue() == true
                    &&  last_confirmation().Get().total_execs.acc_quantity
                        == last_confirmation().Get().market_pos.quantity
                 ) {

            new_status = mtk::make_cptr(new executed (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ADD_HIST_CFEX(ex)       ci->sig_cf_ex(ex);  ci->sig_changed();  

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ADD_HIST_CFEX(ex)       ci->sig_cf_ex(ex);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::cf_exLK ( const mtk::trd::msg::CF_EXLK&   exlk          )
{
    //  coverage
    ++status_common_info::coverage.init__cf_exLK;

    //  remove unused warning
    (void) exlk;

    
	static const char* method_name = "init::cf_exLK";

    
                            if(exlk.total_execs.acc_quantity.GetIntCode() != 0   ||  exlk.total_execs.sum_price_by_qty > 0.001)
                                mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", MTK_SS("espected empty total executions " << exlk.total_execs), mtk::alPriorCritic));
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, ("received cfexlk with no order")));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfexLK

                using namespace mtk::trd::hist;
                ci->executions()->add_item( { exlk, exlk.executed_pos } );
            

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::cf_st ( const mtk::trd::msg::CF_ST_LS&   st            )
{
    //  coverage
    ++status_common_info::coverage.init__cf_st;

    //  remove unused warning
    (void) st;

    
	static const char* method_name = "init::cf_st";

      IF_LAST_CONF_ISNULL__WRITE_IT         

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: full_exec

                    last_confirmation().HasValue() == true
                    &&  last_confirmation().Get().total_execs.acc_quantity
                        == last_confirmation().Get().market_pos.quantity
                 ) {

            new_status = mtk::make_cptr(new executed (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfst
                          ci->sig_cf_st(st);  ci->sig_changed();  

        }
    else 
        if (//  inserting macro: is_rem_qty_zero

                    last_confirmation().HasValue() == true
                    &&  last_confirmation().Get().total_execs.remaining_qty.GetIntCode() == 0
                 ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfst
                          ci->sig_cf_st(st);  ci->sig_changed();  

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfst
                          ci->sig_cf_st(st);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::rq_nw ( const mtk::trd::msg::RQ_NW_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnw__rq_nw;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfnw::rq_nw";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 CREATE_AND_SEND_REJECT(sig_rj_nw, RJ_NW_LS, MTK_SS(ci->__serrors << " in " << method_name))      ADD_HIST_RJ(csr_rj, nw)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::rq_md ( const mtk::trd::msg::RQ_MD_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnw__rq_md;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfnw::rq_md";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_MOD_AND_WRITE_LAST_REQ  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_rq

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new w_cfnwcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 std::string rj_message = MTK_SS(ci->__serrors << " in " << method_name);
                       if(qty_lower_exec)
                            rj_message =  " quantity lower than executed quantity  " +  rj_message;
                        CREATE_AND_SEND_REJECT(sig_rj_md, RJ_MD_LS, rj_message) ADD_HIST_RJ(csr_rj, md)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (//  inserting macro: quantity_lower_ex

                    qty_lower_exec
                 ) {

            new_status = mtk::make_cptr(new w_cfnwcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 std::string rj_message = MTK_SS(ci->__serrors << " in " << method_name);
                       if(qty_lower_exec)
                            rj_message =  " quantity lower than executed quantity  " +  rj_message;
                        CREATE_AND_SEND_REJECT(sig_rj_md, RJ_MD_LS, rj_message) ADD_HIST_RJ(csr_rj, md)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnwmd (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_rqmd
  ADD_HIST_RQ(rq, md)     ci->sig_rq_md(rq);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::rq_cc ( const mtk::trd::msg::RQ_CC_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnw__rq_cc;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfnw::rq_cc";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnwcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::cf_nw ( const mtk::trd::msg::CF_NW_LS&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnw__cf_nw;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfnw::cf_nw";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_cf

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid cfnw ")       ));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::cf_md ( const mtk::trd::msg::CF_MD_LS&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnw__cf_md;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfnw::cf_md";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::cf_cc ( const mtk::trd::msg::CF_CC_LS&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnw__cf_cc;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfnw::cf_cc";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::rj_nw ( const mtk::trd::msg::RJ_NW_LS&   rj            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnw__rj_nw;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfnw::rj_nw";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ADD_HIST_RJ(rj, nw)     ci->sig_rj_nw(rj);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::rj_md ( const mtk::trd::msg::RJ_MD_LS&   rj            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnw__rj_md;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfnw::rj_md";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ADD_HIST_RJ(rj, md)     ci->sig_rj_md(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::rj_cc ( const mtk::trd::msg::RJ_CC_LS&   rj            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnw__rj_cc;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfnw::rj_cc";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ADD_HIST_RJ(rj, cc)     ci->sig_rj_cc(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::cf_ex ( const mtk::trd::msg::CF_EX_LS&   ex            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnw__cf_ex;

    //  remove unused warning
    (void) ex;

    
	static const char* method_name = "w_cfnw::cf_ex";

    
                                int nerrors=0;
                                CHECK_EXEC
                                const mtk::trd::msg::CF_XX_LS& cf(ex);
                                CHECK_CONFIRM_AND_WRITE_LAST_CONF
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ADD_HIST_CFEX(ex)       ci->sig_cf_ex(ex);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::cf_exLK ( const mtk::trd::msg::CF_EXLK&   exlk          )
{
    //  coverage
    ++status_common_info::coverage.w_cfnw__cf_exLK;

    //  remove unused warning
    (void) exlk;

    
	static const char* method_name = "w_cfnw::cf_exLK";

    
                            if(exlk.total_execs.acc_quantity.GetIntCode() != 0   ||  exlk.total_execs.sum_price_by_qty > 0.001)
                                mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", MTK_SS("espected empty total executions " << exlk.total_execs), mtk::alPriorCritic));
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, ("received cfexlk waiting for confirmation")));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfexLK

                using namespace mtk::trd::hist;
                ci->executions()->add_item( { exlk, exlk.executed_pos } );
            

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::cf_st ( const mtk::trd::msg::CF_ST_LS&   st            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnw__cf_st;

    //  remove unused warning
    (void) st;

    
	static const char* method_name = "w_cfnw::cf_st";

      IF_LAST_CONF_ISNULL__WRITE_IT         

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnw (ci));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::rq_nw ( const mtk::trd::msg::RQ_NW_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.market__rq_nw;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "market::rq_nw";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 CREATE_AND_SEND_REJECT(sig_rj_nw, RJ_NW_LS, MTK_SS(ci->__serrors << " in " << method_name))      ADD_HIST_RJ(csr_rj, nw)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::rq_md ( const mtk::trd::msg::RQ_MD_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.market__rq_md;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "market::rq_md";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_MOD_AND_WRITE_LAST_REQ  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_rq

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new w_cfcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 std::string rj_message = MTK_SS(ci->__serrors << " in " << method_name);
                       if(qty_lower_exec)
                            rj_message =  " quantity lower than executed quantity  " +  rj_message;
                        CREATE_AND_SEND_REJECT(sig_rj_md, RJ_MD_LS, rj_message) ADD_HIST_RJ(csr_rj, md)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (//  inserting macro: quantity_lower_ex

                    qty_lower_exec
                 ) {

            new_status = mtk::make_cptr(new w_cfcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 std::string rj_message = MTK_SS(ci->__serrors << " in " << method_name);
                       if(qty_lower_exec)
                            rj_message =  " quantity lower than executed quantity  " +  rj_message;
                        CREATE_AND_SEND_REJECT(sig_rj_md, RJ_MD_LS, rj_message) ADD_HIST_RJ(csr_rj, md)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmd (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_rqmd
  ADD_HIST_RQ(rq, md)     ci->sig_rq_md(rq);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::rq_cc ( const mtk::trd::msg::RQ_CC_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.market__rq_cc;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "market::rq_cc";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::cf_nw ( const mtk::trd::msg::CF_NW_LS&   cf            )
{
    //  coverage
    ++status_common_info::coverage.market__cf_nw;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "market::cf_nw";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::cf_md ( const mtk::trd::msg::CF_MD_LS&   cf            )
{
    //  coverage
    ++status_common_info::coverage.market__cf_md;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "market::cf_md";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd_nr
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::cf_cc ( const mtk::trd::msg::CF_CC_LS&   cf            )
{
    //  coverage
    ++status_common_info::coverage.market__cf_cc;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "market::cf_cc";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_cf

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid cfcc")   ));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc_nr
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc_nr
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::rj_nw ( const mtk::trd::msg::RJ_NW_LS&   rj            )
{
    //  coverage
    ++status_common_info::coverage.market__rj_nw;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "market::rj_nw";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ADD_HIST_RJ(rj, nw)     ci->sig_rj_nw(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::rj_md ( const mtk::trd::msg::RJ_MD_LS&   rj            )
{
    //  coverage
    ++status_common_info::coverage.market__rj_md;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "market::rj_md";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ADD_HIST_RJ(rj, md)     ci->sig_rj_md(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::rj_cc ( const mtk::trd::msg::RJ_CC_LS&   rj            )
{
    //  coverage
    ++status_common_info::coverage.market__rj_cc;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "market::rj_cc";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ADD_HIST_RJ(rj, cc)     ci->sig_rj_cc(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::cf_ex ( const mtk::trd::msg::CF_EX_LS&   ex            )
{
    //  coverage
    ++status_common_info::coverage.market__cf_ex;

    //  remove unused warning
    (void) ex;

    
	static const char* method_name = "market::cf_ex";

    
                                int nerrors=0;
                                CHECK_EXEC
                                const mtk::trd::msg::CF_XX_LS& cf(ex);
                                CHECK_CONFIRM_AND_WRITE_LAST_CONF
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: full_exec

                    last_confirmation().HasValue() == true
                    &&  last_confirmation().Get().total_execs.acc_quantity
                        == last_confirmation().Get().market_pos.quantity
                 ) {

            new_status = mtk::make_cptr(new executed (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ADD_HIST_CFEX(ex)       ci->sig_cf_ex(ex);  ci->sig_changed();  

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ADD_HIST_CFEX(ex)       ci->sig_cf_ex(ex);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::cf_exLK ( const mtk::trd::msg::CF_EXLK&   exlk          )
{
    //  coverage
    ++status_common_info::coverage.market__cf_exLK;

    //  remove unused warning
    (void) exlk;

    
	static const char* method_name = "market::cf_exLK";

    
                            if(exlk.total_execs.acc_quantity.GetIntCode() != 0   ||  exlk.total_execs.sum_price_by_qty > 0.001)
                                mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", MTK_SS("espected empty total executions " << exlk.total_execs), mtk::alPriorCritic));
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfexLK

                using namespace mtk::trd::hist;
                ci->executions()->add_item( { exlk, exlk.executed_pos } );
            

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::cf_st ( const mtk::trd::msg::CF_ST_LS&   st            )
{
    //  coverage
    ++status_common_info::coverage.market__cf_st;

    //  remove unused warning
    (void) st;

    
	static const char* method_name = "market::cf_st";

      IF_LAST_CONF_ISNULL__WRITE_IT         

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::rq_nw ( const mtk::trd::msg::RQ_NW_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmd__rq_nw;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfmd::rq_nw";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 CREATE_AND_SEND_REJECT(sig_rj_nw, RJ_NW_LS, MTK_SS(ci->__serrors << " in " << method_name))      ADD_HIST_RJ(csr_rj, nw)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::rq_md ( const mtk::trd::msg::RQ_MD_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmd__rq_md;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfmd::rq_md";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_MOD_AND_WRITE_LAST_REQ  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_rq

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid rqmd")));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 std::string rj_message = MTK_SS(ci->__serrors << " in " << method_name);
                       if(qty_lower_exec)
                            rj_message =  " quantity lower than executed quantity  " +  rj_message;
                        CREATE_AND_SEND_REJECT(sig_rj_md, RJ_MD_LS, rj_message) ADD_HIST_RJ(csr_rj, md)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (//  inserting macro: quantity_lower_ex

                    qty_lower_exec
                 ) {

            new_status = mtk::make_cptr(new w_cfmdcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 std::string rj_message = MTK_SS(ci->__serrors << " in " << method_name);
                       if(qty_lower_exec)
                            rj_message =  " quantity lower than executed quantity  " +  rj_message;
                        CREATE_AND_SEND_REJECT(sig_rj_md, RJ_MD_LS, rj_message) ADD_HIST_RJ(csr_rj, md)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmd (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_rqmd
  ADD_HIST_RQ(rq, md)     ci->sig_rq_md(rq);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::rq_cc ( const mtk::trd::msg::RQ_CC_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmd__rq_cc;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfmd::rq_cc";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmdcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::cf_nw ( const mtk::trd::msg::CF_NW_LS&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmd__cf_nw;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfmd::cf_nw";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::cf_md ( const mtk::trd::msg::CF_MD_LS&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmd__cf_md;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfmd::cf_md";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_cf

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid cfmd")));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (//  inserting macro: is_conf_last_rqmd

                    ({  bool result = false;
                        if (ci->last_request().HasValue())
                            result = (cf.req_id == ci->last_request().Get().request_info.req_id);
                        else
                            result = false;
                        result;
                    })
                 ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmd (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd_pend
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::cf_cc ( const mtk::trd::msg::CF_CC_LS&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmd__cf_cc;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfmd::cf_cc";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_cf

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid cfcc")  ));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc_nr
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc_nr
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::rj_nw ( const mtk::trd::msg::RJ_NW_LS&   rj            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmd__rj_nw;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfmd::rj_nw";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ADD_HIST_RJ(rj, nw)     ci->sig_rj_nw(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::rj_md ( const mtk::trd::msg::RJ_MD_LS&   rj            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmd__rj_md;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfmd::rj_md";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ADD_HIST_RJ(rj, md)     ci->sig_rj_md(rj);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::rj_cc ( const mtk::trd::msg::RJ_CC_LS&   rj            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmd__rj_cc;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfmd::rj_cc";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ADD_HIST_RJ(rj, cc)     ci->sig_rj_cc(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::cf_ex ( const mtk::trd::msg::CF_EX_LS&   ex            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmd__cf_ex;

    //  remove unused warning
    (void) ex;

    
	static const char* method_name = "w_cfmd::cf_ex";

    
                                int nerrors=0;
                                CHECK_EXEC
                                const mtk::trd::msg::CF_XX_LS& cf(ex);
                                CHECK_CONFIRM_AND_WRITE_LAST_CONF
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: full_exec

                    last_confirmation().HasValue() == true
                    &&  last_confirmation().Get().total_execs.acc_quantity
                        == last_confirmation().Get().market_pos.quantity
                 ) {

            new_status = mtk::make_cptr(new executed (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ADD_HIST_CFEX(ex)       ci->sig_cf_ex(ex);  ci->sig_changed();  

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmd (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ADD_HIST_CFEX(ex)       ci->sig_cf_ex(ex);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::cf_exLK ( const mtk::trd::msg::CF_EXLK&   exlk          )
{
    //  coverage
    ++status_common_info::coverage.w_cfmd__cf_exLK;

    //  remove unused warning
    (void) exlk;

    
	static const char* method_name = "w_cfmd::cf_exLK";

    
                            if(exlk.total_execs.acc_quantity.GetIntCode() != 0   ||  exlk.total_execs.sum_price_by_qty > 0.001)
                                mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", MTK_SS("espected empty total executions " << exlk.total_execs), mtk::alPriorCritic));
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmd (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfexLK

                using namespace mtk::trd::hist;
                ci->executions()->add_item( { exlk, exlk.executed_pos } );
            

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::cf_st ( const mtk::trd::msg::CF_ST_LS&   st            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmd__cf_st;

    //  remove unused warning
    (void) st;

    
	static const char* method_name = "w_cfmd::cf_st";

      IF_LAST_CONF_ISNULL__WRITE_IT         

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmd (ci));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::rq_nw ( const mtk::trd::msg::RQ_NW_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.w_cfcc__rq_nw;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfcc::rq_nw";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 CREATE_AND_SEND_REJECT(sig_rj_nw, RJ_NW_LS, MTK_SS(ci->__serrors << " in " << method_name))      ADD_HIST_RJ(csr_rj, nw)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::rq_md ( const mtk::trd::msg::RQ_MD_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.w_cfcc__rq_md;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfcc::rq_md";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_MOD_AND_WRITE_LAST_REQ  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 std::string rj_message = MTK_SS(ci->__serrors << " in " << method_name);
                       if(qty_lower_exec)
                            rj_message =  " quantity lower than executed quantity  " +  rj_message;
                        CREATE_AND_SEND_REJECT(sig_rj_md, RJ_MD_LS, rj_message) ADD_HIST_RJ(csr_rj, md)      ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::rq_cc ( const mtk::trd::msg::RQ_CC_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.w_cfcc__rq_cc;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfcc::rq_cc";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::cf_nw ( const mtk::trd::msg::CF_NW_LS&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_cfcc__cf_nw;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfcc::cf_nw";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::cf_md ( const mtk::trd::msg::CF_MD_LS&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_cfcc__cf_md;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfcc::cf_md";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::cf_cc ( const mtk::trd::msg::CF_CC_LS&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_cfcc__cf_cc;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfcc::cf_cc";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_cf

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid cfcc")  ));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc_nr
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::rj_nw ( const mtk::trd::msg::RJ_NW_LS&   rj            )
{
    //  coverage
    ++status_common_info::coverage.w_cfcc__rj_nw;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfcc::rj_nw";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ADD_HIST_RJ(rj, nw)     ci->sig_rj_nw(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::rj_md ( const mtk::trd::msg::RJ_MD_LS&   rj            )
{
    //  coverage
    ++status_common_info::coverage.w_cfcc__rj_md;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfcc::rj_md";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ADD_HIST_RJ(rj, md)     ci->sig_rj_md(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::rj_cc ( const mtk::trd::msg::RJ_CC_LS&   rj            )
{
    //  coverage
    ++status_common_info::coverage.w_cfcc__rj_cc;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfcc::rj_cc";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ADD_HIST_RJ(rj, cc)     ci->sig_rj_cc(rj);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::cf_ex ( const mtk::trd::msg::CF_EX_LS&   ex            )
{
    //  coverage
    ++status_common_info::coverage.w_cfcc__cf_ex;

    //  remove unused warning
    (void) ex;

    
	static const char* method_name = "w_cfcc::cf_ex";

    
                                int nerrors=0;
                                CHECK_EXEC
                                const mtk::trd::msg::CF_XX_LS& cf(ex);
                                CHECK_CONFIRM_AND_WRITE_LAST_CONF
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: full_exec

                    last_confirmation().HasValue() == true
                    &&  last_confirmation().Get().total_execs.acc_quantity
                        == last_confirmation().Get().market_pos.quantity
                 ) {

            new_status = mtk::make_cptr(new executed (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ADD_HIST_CFEX(ex)       ci->sig_cf_ex(ex);  ci->sig_changed();  

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ADD_HIST_CFEX(ex)       ci->sig_cf_ex(ex);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::cf_exLK ( const mtk::trd::msg::CF_EXLK&   exlk          )
{
    //  coverage
    ++status_common_info::coverage.w_cfcc__cf_exLK;

    //  remove unused warning
    (void) exlk;

    
	static const char* method_name = "w_cfcc::cf_exLK";

    
                            if(exlk.total_execs.acc_quantity.GetIntCode() != 0   ||  exlk.total_execs.sum_price_by_qty > 0.001)
                                mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", MTK_SS("espected empty total executions " << exlk.total_execs), mtk::alPriorCritic));
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfexLK

                using namespace mtk::trd::hist;
                ci->executions()->add_item( { exlk, exlk.executed_pos } );
            

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::cf_st ( const mtk::trd::msg::CF_ST_LS&   st            )
{
    //  coverage
    ++status_common_info::coverage.w_cfcc__cf_st;

    //  remove unused warning
    (void) st;

    
	static const char* method_name = "w_cfcc::cf_st";

      IF_LAST_CONF_ISNULL__WRITE_IT         

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfcc (ci));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::rq_nw ( const mtk::trd::msg::RQ_NW_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmdcc__rq_nw;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfmdcc::rq_nw";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 CREATE_AND_SEND_REJECT(sig_rj_nw, RJ_NW_LS, MTK_SS(ci->__serrors << " in " << method_name))      ADD_HIST_RJ(csr_rj, nw)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::rq_md ( const mtk::trd::msg::RQ_MD_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmdcc__rq_md;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfmdcc::rq_md";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_MOD_AND_WRITE_LAST_REQ  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_rq

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new w_cfmdcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 std::string rj_message = MTK_SS(ci->__serrors << " in " << method_name);
                       if(qty_lower_exec)
                            rj_message =  " quantity lower than executed quantity  " +  rj_message;
                        CREATE_AND_SEND_REJECT(sig_rj_md, RJ_MD_LS, rj_message) ADD_HIST_RJ(csr_rj, md)      ci->sig_changed();  

        }
    else 
        if (//  inserting macro: quantity_lower_ex

                    qty_lower_exec
                 ) {

            new_status = mtk::make_cptr(new w_cfmdcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 std::string rj_message = MTK_SS(ci->__serrors << " in " << method_name);
                       if(qty_lower_exec)
                            rj_message =  " quantity lower than executed quantity  " +  rj_message;
                        CREATE_AND_SEND_REJECT(sig_rj_md, RJ_MD_LS, rj_message) ADD_HIST_RJ(csr_rj, md)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmdcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 std::string rj_message = MTK_SS(ci->__serrors << " in " << method_name);
                       if(qty_lower_exec)
                            rj_message =  " quantity lower than executed quantity  " +  rj_message;
                        CREATE_AND_SEND_REJECT(sig_rj_md, RJ_MD_LS, rj_message) ADD_HIST_RJ(csr_rj, md)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::rq_cc ( const mtk::trd::msg::RQ_CC_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmdcc__rq_cc;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfmdcc::rq_cc";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmdcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::cf_nw ( const mtk::trd::msg::CF_NW_LS&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmdcc__cf_nw;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfmdcc::cf_nw";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::cf_md ( const mtk::trd::msg::CF_MD_LS&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmdcc__cf_md;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfmdcc::cf_md";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_cf

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid cfmd")));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (//  inserting macro: is_conf_last_rqmd

                    ({  bool result = false;
                        if (ci->last_request().HasValue())
                            result = (cf.req_id == ci->last_request().Get().request_info.req_id);
                        else
                            result = false;
                        result;
                    })
                 ) {

            new_status = mtk::make_cptr(new w_cfcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmdcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd_pend
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::cf_cc ( const mtk::trd::msg::CF_CC_LS&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmdcc__cf_cc;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfmdcc::cf_cc";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_cf

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid cfcc")  ));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc_nr
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::rj_nw ( const mtk::trd::msg::RJ_NW_LS&   rj            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmdcc__rj_nw;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfmdcc::rj_nw";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ADD_HIST_RJ(rj, nw)     ci->sig_rj_nw(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::rj_md ( const mtk::trd::msg::RJ_MD_LS&   rj            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmdcc__rj_md;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfmdcc::rj_md";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ADD_HIST_RJ(rj, md)     ci->sig_rj_md(rj);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::rj_cc ( const mtk::trd::msg::RJ_CC_LS&   rj            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmdcc__rj_cc;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfmdcc::rj_cc";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmd (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ADD_HIST_RJ(rj, cc)     ci->sig_rj_cc(rj);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::cf_ex ( const mtk::trd::msg::CF_EX_LS&   ex            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmdcc__cf_ex;

    //  remove unused warning
    (void) ex;

    
	static const char* method_name = "w_cfmdcc::cf_ex";

    
                                int nerrors=0;
                                CHECK_EXEC
                                const mtk::trd::msg::CF_XX_LS& cf(ex);
                                CHECK_CONFIRM_AND_WRITE_LAST_CONF
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: full_exec

                    last_confirmation().HasValue() == true
                    &&  last_confirmation().Get().total_execs.acc_quantity
                        == last_confirmation().Get().market_pos.quantity
                 ) {

            new_status = mtk::make_cptr(new executed (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ADD_HIST_CFEX(ex)       ci->sig_cf_ex(ex);  ci->sig_changed();  

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmdcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ADD_HIST_CFEX(ex)       ci->sig_cf_ex(ex);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::cf_exLK ( const mtk::trd::msg::CF_EXLK&   exlk          )
{
    //  coverage
    ++status_common_info::coverage.w_cfmdcc__cf_exLK;

    //  remove unused warning
    (void) exlk;

    
	static const char* method_name = "w_cfmdcc::cf_exLK";

    
                            if(exlk.total_execs.acc_quantity.GetIntCode() != 0   ||  exlk.total_execs.sum_price_by_qty > 0.001)
                                mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", MTK_SS("espected empty total executions " << exlk.total_execs), mtk::alPriorCritic));
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmdcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfexLK

                using namespace mtk::trd::hist;
                ci->executions()->add_item( { exlk, exlk.executed_pos } );
            

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::cf_st ( const mtk::trd::msg::CF_ST_LS&   st            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmdcc__cf_st;

    //  remove unused warning
    (void) st;

    
	static const char* method_name = "w_cfmdcc::cf_st";

      IF_LAST_CONF_ISNULL__WRITE_IT         

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmdcc (ci));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::rq_nw ( const mtk::trd::msg::RQ_NW_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwmd__rq_nw;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfnwmd::rq_nw";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 CREATE_AND_SEND_REJECT(sig_rj_nw, RJ_NW_LS, MTK_SS(ci->__serrors << " in " << method_name))      ADD_HIST_RJ(csr_rj, nw)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::rq_md ( const mtk::trd::msg::RQ_MD_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwmd__rq_md;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfnwmd::rq_md";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_MOD_AND_WRITE_LAST_REQ  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_rq

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new w_cfnwcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 std::string rj_message = MTK_SS(ci->__serrors << " in " << method_name);
                       if(qty_lower_exec)
                            rj_message =  " quantity lower than executed quantity  " +  rj_message;
                        CREATE_AND_SEND_REJECT(sig_rj_md, RJ_MD_LS, rj_message) ADD_HIST_RJ(csr_rj, md)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (//  inserting macro: quantity_lower_ex

                    qty_lower_exec
                 ) {

            new_status = mtk::make_cptr(new w_cfnwcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 std::string rj_message = MTK_SS(ci->__serrors << " in " << method_name);
                       if(qty_lower_exec)
                            rj_message =  " quantity lower than executed quantity  " +  rj_message;
                        CREATE_AND_SEND_REJECT(sig_rj_md, RJ_MD_LS, rj_message) ADD_HIST_RJ(csr_rj, md)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnwmd (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_rqmd
  ADD_HIST_RQ(rq, md)     ci->sig_rq_md(rq);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::rq_cc ( const mtk::trd::msg::RQ_CC_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwmd__rq_cc;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfnwmd::rq_cc";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnwcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::cf_nw ( const mtk::trd::msg::CF_NW_LS&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwmd__cf_nw;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfnwmd::cf_nw";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_cf

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid cfnw")));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmd (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::cf_md ( const mtk::trd::msg::CF_MD_LS&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwmd__cf_md;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfnwmd::cf_md";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::cf_cc ( const mtk::trd::msg::CF_CC_LS&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwmd__cf_cc;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfnwmd::cf_cc";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::rj_nw ( const mtk::trd::msg::RJ_NW_LS&   rj            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwmd__rj_nw;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfnwmd::rj_nw";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ADD_HIST_RJ(rj, nw)     ci->sig_rj_nw(rj);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::rj_md ( const mtk::trd::msg::RJ_MD_LS&   rj            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwmd__rj_md;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfnwmd::rj_md";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ADD_HIST_RJ(rj, md)     ci->sig_rj_md(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::rj_cc ( const mtk::trd::msg::RJ_CC_LS&   rj            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwmd__rj_cc;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfnwmd::rj_cc";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ADD_HIST_RJ(rj, cc)     ci->sig_rj_cc(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::cf_ex ( const mtk::trd::msg::CF_EX_LS&   ex            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwmd__cf_ex;

    //  remove unused warning
    (void) ex;

    
	static const char* method_name = "w_cfnwmd::cf_ex";

    
                                int nerrors=0;
                                CHECK_EXEC
                                const mtk::trd::msg::CF_XX_LS& cf(ex);
                                CHECK_CONFIRM_AND_WRITE_LAST_CONF
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ADD_HIST_CFEX(ex)       ci->sig_cf_ex(ex);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::cf_exLK ( const mtk::trd::msg::CF_EXLK&   exlk          )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwmd__cf_exLK;

    //  remove unused warning
    (void) exlk;

    
	static const char* method_name = "w_cfnwmd::cf_exLK";

    
                            if(exlk.total_execs.acc_quantity.GetIntCode() != 0   ||  exlk.total_execs.sum_price_by_qty > 0.001)
                                mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", MTK_SS("espected empty total executions " << exlk.total_execs), mtk::alPriorCritic));
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, ("received cfexlk waiting for confirmation2")));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfexLK

                using namespace mtk::trd::hist;
                ci->executions()->add_item( { exlk, exlk.executed_pos } );
            

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::cf_st ( const mtk::trd::msg::CF_ST_LS&   st            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwmd__cf_st;

    //  remove unused warning
    (void) st;

    
	static const char* method_name = "w_cfnwmd::cf_st";

      IF_LAST_CONF_ISNULL__WRITE_IT         

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnwmd (ci));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::rq_nw ( const mtk::trd::msg::RQ_NW_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwcc__rq_nw;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfnwcc::rq_nw";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 CREATE_AND_SEND_REJECT(sig_rj_nw, RJ_NW_LS, MTK_SS(ci->__serrors << " in " << method_name))      ADD_HIST_RJ(csr_rj, nw)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::rq_md ( const mtk::trd::msg::RQ_MD_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwcc__rq_md;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfnwcc::rq_md";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_MOD_AND_WRITE_LAST_REQ  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnwcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_rqmd
  ADD_HIST_RQ(rq, md)     ci->sig_rq_md(rq);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::rq_cc ( const mtk::trd::msg::RQ_CC_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwcc__rq_cc;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfnwcc::rq_cc";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnwcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::cf_nw ( const mtk::trd::msg::CF_NW_LS&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwcc__cf_nw;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfnwcc::cf_nw";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_cf

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid cfnw")));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::cf_md ( const mtk::trd::msg::CF_MD_LS&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwcc__cf_md;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfnwcc::cf_md";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::cf_cc ( const mtk::trd::msg::CF_CC_LS&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwcc__cf_cc;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfnwcc::cf_cc";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::rj_nw ( const mtk::trd::msg::RJ_NW_LS&   rj            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwcc__rj_nw;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfnwcc::rj_nw";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ADD_HIST_RJ(rj, nw)     ci->sig_rj_nw(rj);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::rj_md ( const mtk::trd::msg::RJ_MD_LS&   rj            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwcc__rj_md;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfnwcc::rj_md";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ADD_HIST_RJ(rj, md)     ci->sig_rj_md(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::rj_cc ( const mtk::trd::msg::RJ_CC_LS&   rj            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwcc__rj_cc;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfnwcc::rj_cc";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ADD_HIST_RJ(rj, cc)     ci->sig_rj_cc(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::cf_ex ( const mtk::trd::msg::CF_EX_LS&   ex            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwcc__cf_ex;

    //  remove unused warning
    (void) ex;

    
	static const char* method_name = "w_cfnwcc::cf_ex";

    
                                int nerrors=0;
                                CHECK_EXEC
                                const mtk::trd::msg::CF_XX_LS& cf(ex);
                                CHECK_CONFIRM_AND_WRITE_LAST_CONF
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ADD_HIST_CFEX(ex)       ci->sig_cf_ex(ex);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::cf_exLK ( const mtk::trd::msg::CF_EXLK&   exlk          )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwcc__cf_exLK;

    //  remove unused warning
    (void) exlk;

    
	static const char* method_name = "w_cfnwcc::cf_exLK";

    
                            if(exlk.total_execs.acc_quantity.GetIntCode() != 0   ||  exlk.total_execs.sum_price_by_qty > 0.001)
                                mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", MTK_SS("espected empty total executions " << exlk.total_execs), mtk::alPriorCritic));
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, ("received cfexlk waiting for confirmation3")));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfexLK

                using namespace mtk::trd::hist;
                ci->executions()->add_item( { exlk, exlk.executed_pos } );
            

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::cf_st ( const mtk::trd::msg::CF_ST_LS&   st            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwcc__cf_st;

    //  remove unused warning
    (void) st;

    
	static const char* method_name = "w_cfnwcc::cf_st";

      IF_LAST_CONF_ISNULL__WRITE_IT         

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnwcc (ci));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::rq_nw ( const mtk::trd::msg::RQ_NW_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.canceled__rq_nw;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "canceled::rq_nw";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 CREATE_AND_SEND_REJECT(sig_rj_nw, RJ_NW_LS, MTK_SS(ci->__serrors << " in " << method_name))      ADD_HIST_RJ(csr_rj, nw)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::rq_md ( const mtk::trd::msg::RQ_MD_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.canceled__rq_md;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "canceled::rq_md";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_MOD_AND_WRITE_LAST_REQ  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 std::string rj_message = MTK_SS(ci->__serrors << " in " << method_name);
                       if(qty_lower_exec)
                            rj_message =  " quantity lower than executed quantity  " +  rj_message;
                        CREATE_AND_SEND_REJECT(sig_rj_md, RJ_MD_LS, rj_message) ADD_HIST_RJ(csr_rj, md)      ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::rq_cc ( const mtk::trd::msg::RQ_CC_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.canceled__rq_cc;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "canceled::rq_cc";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqcc
 CREATE_AND_SEND_REJECT(sig_rj_cc, RJ_CC_LS, MTK_SS(ci->__serrors << " in " << method_name))      ADD_HIST_RJ(csr_rj, cc)      ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::cf_nw ( const mtk::trd::msg::CF_NW_LS&   cf            )
{
    //  coverage
    ++status_common_info::coverage.canceled__cf_nw;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "canceled::cf_nw";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::cf_md ( const mtk::trd::msg::CF_MD_LS&   cf            )
{
    //  coverage
    ++status_common_info::coverage.canceled__cf_md;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "canceled::cf_md";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::cf_cc ( const mtk::trd::msg::CF_CC_LS&   cf            )
{
    //  coverage
    ++status_common_info::coverage.canceled__cf_cc;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "canceled::cf_cc";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::rj_nw ( const mtk::trd::msg::RJ_NW_LS&   rj            )
{
    //  coverage
    ++status_common_info::coverage.canceled__rj_nw;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "canceled::rj_nw";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ADD_HIST_RJ(rj, nw)     ci->sig_rj_nw(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::rj_md ( const mtk::trd::msg::RJ_MD_LS&   rj            )
{
    //  coverage
    ++status_common_info::coverage.canceled__rj_md;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "canceled::rj_md";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ADD_HIST_RJ(rj, md)     ci->sig_rj_md(rj);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::rj_cc ( const mtk::trd::msg::RJ_CC_LS&   rj            )
{
    //  coverage
    ++status_common_info::coverage.canceled__rj_cc;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "canceled::rj_cc";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ADD_HIST_RJ(rj, cc)     ci->sig_rj_cc(rj);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::cf_ex ( const mtk::trd::msg::CF_EX_LS&   ex            )
{
    //  coverage
    ++status_common_info::coverage.canceled__cf_ex;

    //  remove unused warning
    (void) ex;

    
	static const char* method_name = "canceled::cf_ex";

    
                                int nerrors=0;
                                CHECK_EXEC
                                const mtk::trd::msg::CF_XX_LS& cf(ex);
                                CHECK_CONFIRM_AND_WRITE_LAST_CONF
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ADD_HIST_CFEX(ex)       ci->sig_cf_ex(ex);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::cf_exLK ( const mtk::trd::msg::CF_EXLK&   exlk          )
{
    //  coverage
    ++status_common_info::coverage.canceled__cf_exLK;

    //  remove unused warning
    (void) exlk;

    
	static const char* method_name = "canceled::cf_exLK";

    
                            if(exlk.total_execs.acc_quantity.GetIntCode() != 0   ||  exlk.total_execs.sum_price_by_qty > 0.001)
                                mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", MTK_SS("espected empty total executions " << exlk.total_execs), mtk::alPriorCritic));
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfexLK

                using namespace mtk::trd::hist;
                ci->executions()->add_item( { exlk, exlk.executed_pos } );
            

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::cf_st ( const mtk::trd::msg::CF_ST_LS&   st            )
{
    //  coverage
    ++status_common_info::coverage.canceled__cf_st;

    //  remove unused warning
    (void) st;

    
	static const char* method_name = "canceled::cf_st";

      IF_LAST_CONF_ISNULL__WRITE_IT         

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void executed::rq_nw ( const mtk::trd::msg::RQ_NW_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.executed__rq_nw;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "executed::rq_nw";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 CREATE_AND_SEND_REJECT(sig_rj_nw, RJ_NW_LS, MTK_SS(ci->__serrors << " in " << method_name))      ADD_HIST_RJ(csr_rj, nw)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void executed::rq_md ( const mtk::trd::msg::RQ_MD_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.executed__rq_md;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "executed::rq_md";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_MOD_AND_WRITE_LAST_REQ  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new executed (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 std::string rj_message = MTK_SS(ci->__serrors << " in " << method_name);
                       if(qty_lower_exec)
                            rj_message =  " quantity lower than executed quantity  " +  rj_message;
                        CREATE_AND_SEND_REJECT(sig_rj_md, RJ_MD_LS, rj_message) ADD_HIST_RJ(csr_rj, md)      ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void executed::rq_cc ( const mtk::trd::msg::RQ_CC_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.executed__rq_cc;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "executed::rq_cc";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new executed (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqcc
 CREATE_AND_SEND_REJECT(sig_rj_cc, RJ_CC_LS, MTK_SS(ci->__serrors << " in " << method_name))      ADD_HIST_RJ(csr_rj, cc)      ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void executed::cf_nw ( const mtk::trd::msg::CF_NW_LS&   cf            )
{
    //  coverage
    ++status_common_info::coverage.executed__cf_nw;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "executed::cf_nw";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void executed::cf_md ( const mtk::trd::msg::CF_MD_LS&   cf            )
{
    //  coverage
    ++status_common_info::coverage.executed__cf_md;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "executed::cf_md";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void executed::cf_cc ( const mtk::trd::msg::CF_CC_LS&   cf            )
{
    //  coverage
    ++status_common_info::coverage.executed__cf_cc;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "executed::cf_cc";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void executed::rj_nw ( const mtk::trd::msg::RJ_NW_LS&   rj            )
{
    //  coverage
    ++status_common_info::coverage.executed__rj_nw;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "executed::rj_nw";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ADD_HIST_RJ(rj, nw)     ci->sig_rj_nw(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void executed::rj_md ( const mtk::trd::msg::RJ_MD_LS&   rj            )
{
    //  coverage
    ++status_common_info::coverage.executed__rj_md;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "executed::rj_md";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new executed (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ADD_HIST_RJ(rj, md)     ci->sig_rj_md(rj);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void executed::rj_cc ( const mtk::trd::msg::RJ_CC_LS&   rj            )
{
    //  coverage
    ++status_common_info::coverage.executed__rj_cc;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "executed::rj_cc";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new executed (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ADD_HIST_RJ(rj, cc)     ci->sig_rj_cc(rj);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void executed::cf_ex ( const mtk::trd::msg::CF_EX_LS&   ex            )
{
    //  coverage
    ++status_common_info::coverage.executed__cf_ex;

    //  remove unused warning
    (void) ex;

    
	static const char* method_name = "executed::cf_ex";

    
                                int nerrors=0;
                                CHECK_EXEC
                                const mtk::trd::msg::CF_XX_LS& cf(ex);
                                CHECK_CONFIRM_AND_WRITE_LAST_CONF
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ADD_HIST_CFEX(ex)       ci->sig_cf_ex(ex);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void executed::cf_exLK ( const mtk::trd::msg::CF_EXLK&   exlk          )
{
    //  coverage
    ++status_common_info::coverage.executed__cf_exLK;

    //  remove unused warning
    (void) exlk;

    
	static const char* method_name = "executed::cf_exLK";

    
                            if(exlk.total_execs.acc_quantity.GetIntCode() != 0   ||  exlk.total_execs.sum_price_by_qty > 0.001)
                                mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", MTK_SS("espected empty total executions " << exlk.total_execs), mtk::alPriorCritic));
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new executed (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfexLK

                using namespace mtk::trd::hist;
                ci->executions()->add_item( { exlk, exlk.executed_pos } );
            

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void executed::cf_st ( const mtk::trd::msg::CF_ST_LS&   st            )
{
    //  coverage
    ++status_common_info::coverage.executed__cf_st;

    //  remove unused warning
    (void) st;

    
	static const char* method_name = "executed::cf_st";

      IF_LAST_CONF_ISNULL__WRITE_IT         

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new executed (ci));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::rq_nw ( const mtk::trd::msg::RQ_NW_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.error__rq_nw;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "error::rq_nw";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 CREATE_AND_SEND_REJECT(sig_rj_nw, RJ_NW_LS, MTK_SS(ci->__serrors << " in " << method_name))      ADD_HIST_RJ(csr_rj, nw)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::rq_md ( const mtk::trd::msg::RQ_MD_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.error__rq_md;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "error::rq_md";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_MOD_AND_WRITE_LAST_REQ  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 std::string rj_message = MTK_SS(ci->__serrors << " in " << method_name);
                       if(qty_lower_exec)
                            rj_message =  " quantity lower than executed quantity  " +  rj_message;
                        CREATE_AND_SEND_REJECT(sig_rj_md, RJ_MD_LS, rj_message) ADD_HIST_RJ(csr_rj, md)      ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::rq_cc ( const mtk::trd::msg::RQ_CC_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.error__rq_cc;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "error::rq_cc";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::cf_nw ( const mtk::trd::msg::CF_NW_LS&   cf            )
{
    //  coverage
    ++status_common_info::coverage.error__cf_nw;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "error::cf_nw";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::cf_md ( const mtk::trd::msg::CF_MD_LS&   cf            )
{
    //  coverage
    ++status_common_info::coverage.error__cf_md;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "error::cf_md";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::cf_cc ( const mtk::trd::msg::CF_CC_LS&   cf            )
{
    //  coverage
    ++status_common_info::coverage.error__cf_cc;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "error::cf_cc";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::rj_nw ( const mtk::trd::msg::RJ_NW_LS&   rj            )
{
    //  coverage
    ++status_common_info::coverage.error__rj_nw;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "error::rj_nw";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ADD_HIST_RJ(rj, nw)     ci->sig_rj_nw(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::rj_md ( const mtk::trd::msg::RJ_MD_LS&   rj            )
{
    //  coverage
    ++status_common_info::coverage.error__rj_md;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "error::rj_md";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ADD_HIST_RJ(rj, md)     ci->sig_rj_md(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::rj_cc ( const mtk::trd::msg::RJ_CC_LS&   rj            )
{
    //  coverage
    ++status_common_info::coverage.error__rj_cc;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "error::rj_cc";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ADD_HIST_RJ(rj, cc)     ci->sig_rj_cc(rj);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::cf_ex ( const mtk::trd::msg::CF_EX_LS&   ex            )
{
    //  coverage
    ++status_common_info::coverage.error__cf_ex;

    //  remove unused warning
    (void) ex;

    
	static const char* method_name = "error::cf_ex";

    
                                int nerrors=0;
                                CHECK_EXEC
                                const mtk::trd::msg::CF_XX_LS& cf(ex);
                                CHECK_CONFIRM_AND_WRITE_LAST_CONF
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ADD_HIST_CFEX(ex)       ci->sig_cf_ex(ex);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::cf_exLK ( const mtk::trd::msg::CF_EXLK&   exlk          )
{
    //  coverage
    ++status_common_info::coverage.error__cf_exLK;

    //  remove unused warning
    (void) exlk;

    
	static const char* method_name = "error::cf_exLK";

    
                            if(exlk.total_execs.acc_quantity.GetIntCode() != 0   ||  exlk.total_execs.sum_price_by_qty > 0.001)
                                mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", MTK_SS("espected empty total executions " << exlk.total_execs), mtk::alPriorCritic));
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfexLK

                using namespace mtk::trd::hist;
                ci->executions()->add_item( { exlk, exlk.executed_pos } );
            

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::cf_st ( const mtk::trd::msg::CF_ST_LS&   st            )
{
    //  coverage
    ++status_common_info::coverage.error__cf_st;

    //  remove unused warning
    (void) st;

    
	static const char* method_name = "error::cf_st";

      IF_LAST_CONF_ISNULL__WRITE_IT         

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}


};  // end   namespace fsmgen_trd_cli_ls {

mtk::trd::trd_cli_ls_dangerous_signals_not_warped::trd_cli_ls_dangerous_signals_not_warped()
{
    mtk::CountPtr<fsmgen_trd_cli_ls::status_common_info> ci = mtk::make_cptr(
                            new fsmgen_trd_cli_ls::status_common_info ( sig_rq_nw,sig_rq_md,sig_rq_cc,sig_rj_nw,sig_rj_md,sig_rj_cc,sig_cf_nw,sig_cf_md,sig_cf_cc,sig_cf_ex,sig_cf_st,sig_changed));

    current_status = mtk::make_cptr(new fsmgen_trd_cli_ls::init(ci ) );
    MTK_CONNECT_THIS(ci->signal_new_status, on_new_status)
    MTK_CONNECT_THIS(ci->signal_keep_temp_status, on_keep_temp_status)
    MTK_CONNECT_THIS(ci->signal_remove_temp_status, on_remove_temp_status)
}


mtk::trd::trd_cli_ls_dangerous_signals_not_warped::~trd_cli_ls_dangerous_signals_not_warped()
{
}

void mtk::trd::trd_cli_ls_dangerous_signals_not_warped::on_new_status (mtk::CountPtr<fsmgen_trd_cli_ls::abstract_status>  new_status)
{
    current_status = new_status;
}

void mtk::trd::trd_cli_ls_dangerous_signals_not_warped::on_keep_temp_status (void)
{
    queue_temp_status.push_back(current_status);
}
void mtk::trd::trd_cli_ls_dangerous_signals_not_warped::on_remove_temp_status (void)
{
    queue_temp_status.pop_front();
}


std::string  mtk::trd::trd_cli_ls_dangerous_signals_not_warped::get_coverage_string(void)
{
    return current_status->get_coverage_string();
}

void mtk::trd::trd_cli_ls_dangerous_signals_not_warped::rq_nw (const mtk::trd::msg::RQ_NW_LS&   rq           )
{
    mtk::CountPtr<fsmgen_trd_cli_ls::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->rq_nw(rq);
}
void mtk::trd::trd_cli_ls_dangerous_signals_not_warped::rq_md (const mtk::trd::msg::RQ_MD_LS&   rq           )
{
    mtk::CountPtr<fsmgen_trd_cli_ls::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->rq_md(rq);
}
void mtk::trd::trd_cli_ls_dangerous_signals_not_warped::rq_cc (const mtk::trd::msg::RQ_CC_LS&   rq           )
{
    mtk::CountPtr<fsmgen_trd_cli_ls::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->rq_cc(rq);
}
void mtk::trd::trd_cli_ls_dangerous_signals_not_warped::cf_nw (const mtk::trd::msg::CF_NW_LS&   cf           )
{
    mtk::CountPtr<fsmgen_trd_cli_ls::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->cf_nw(cf);
}
void mtk::trd::trd_cli_ls_dangerous_signals_not_warped::cf_md (const mtk::trd::msg::CF_MD_LS&   cf           )
{
    mtk::CountPtr<fsmgen_trd_cli_ls::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->cf_md(cf);
}
void mtk::trd::trd_cli_ls_dangerous_signals_not_warped::cf_cc (const mtk::trd::msg::CF_CC_LS&   cf           )
{
    mtk::CountPtr<fsmgen_trd_cli_ls::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->cf_cc(cf);
}
void mtk::trd::trd_cli_ls_dangerous_signals_not_warped::rj_nw (const mtk::trd::msg::RJ_NW_LS&   rj           )
{
    mtk::CountPtr<fsmgen_trd_cli_ls::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->rj_nw(rj);
}
void mtk::trd::trd_cli_ls_dangerous_signals_not_warped::rj_md (const mtk::trd::msg::RJ_MD_LS&   rj           )
{
    mtk::CountPtr<fsmgen_trd_cli_ls::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->rj_md(rj);
}
void mtk::trd::trd_cli_ls_dangerous_signals_not_warped::rj_cc (const mtk::trd::msg::RJ_CC_LS&   rj           )
{
    mtk::CountPtr<fsmgen_trd_cli_ls::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->rj_cc(rj);
}
void mtk::trd::trd_cli_ls_dangerous_signals_not_warped::cf_ex (const mtk::trd::msg::CF_EX_LS&   ex           )
{
    mtk::CountPtr<fsmgen_trd_cli_ls::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->cf_ex(ex);
}
void mtk::trd::trd_cli_ls_dangerous_signals_not_warped::cf_exLK (const mtk::trd::msg::CF_EXLK&   exlk         )
{
    mtk::CountPtr<fsmgen_trd_cli_ls::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->cf_exLK(exlk);
}
void mtk::trd::trd_cli_ls_dangerous_signals_not_warped::cf_st (const mtk::trd::msg::CF_ST_LS&   st           )
{
    mtk::CountPtr<fsmgen_trd_cli_ls::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->cf_st(st);
}
const mtk::nullable<mtk::trd::msg::CF_XX_LS>           & mtk::trd::trd_cli_ls_dangerous_signals_not_warped::last_confirmation (void) const
{
    return current_status->last_confirmation();
}
const mtk::nullable<mtk::trd::msg::RQ_XX_LS>           & mtk::trd::trd_cli_ls_dangerous_signals_not_warped::last_request (void) const
{
    return current_status->last_request();
}
const mtk::CountPtr<mtk::trd::hist::order_historic_dangerous_not_signal_warped      >   & mtk::trd::trd_cli_ls_dangerous_signals_not_warped::history (void) const
{
    return current_status->history();
}
const mtk::CountPtr<mtk::trd::hist::order_EXECS_historic_dangerous_not_signal_warped>   & mtk::trd::trd_cli_ls_dangerous_signals_not_warped::executions (void) const
{
    return current_status->executions();
}
const bool                                             & mtk::trd::trd_cli_ls_dangerous_signals_not_warped::in_market (void) const
{
    return current_status->in_market();
}
const bool                                             & mtk::trd::trd_cli_ls_dangerous_signals_not_warped::is_canceled (void) const
{
    return current_status->is_canceled();
}
const bool                                             & mtk::trd::trd_cli_ls_dangerous_signals_not_warped::is_full_executed (void) const
{
    return current_status->is_full_executed();
}
const bool                                             & mtk::trd::trd_cli_ls_dangerous_signals_not_warped::has_pending_rq (void) const
{
    return current_status->has_pending_rq();
}
const std::string                                      & mtk::trd::trd_cli_ls_dangerous_signals_not_warped::serrors (void) const
{
    return current_status->serrors();
}

//  warper RAII with signals and repository
mtk::trd::trd_cli_ls::trd_cli_ls (void)
    : ptr (new trd_cli_ls_dangerous_signals_not_warped())
{
    ptr->sig_rq_nw.connect(&sig_rq_nw);
    ptr->sig_rq_md.connect(&sig_rq_md);
    ptr->sig_rq_cc.connect(&sig_rq_cc);
    ptr->sig_rj_nw.connect(&sig_rj_nw);
    ptr->sig_rj_md.connect(&sig_rj_md);
    ptr->sig_rj_cc.connect(&sig_rj_cc);
    ptr->sig_cf_nw.connect(&sig_cf_nw);
    ptr->sig_cf_md.connect(&sig_cf_md);
    ptr->sig_cf_cc.connect(&sig_cf_cc);
    ptr->sig_cf_ex.connect(&sig_cf_ex);
    ptr->sig_cf_st.connect(&sig_cf_st);
    ptr->sig_changed.connect(&sig_changed);
}
mtk::trd::trd_cli_ls::trd_cli_ls (const mtk::CountPtr<trd_cli_ls_dangerous_signals_not_warped>& _ptr)
    :   ptr(_ptr)
{
    try
    {
    ptr->sig_rq_nw.connect(&sig_rq_nw);
    ptr->sig_rq_md.connect(&sig_rq_md);
    ptr->sig_rq_cc.connect(&sig_rq_cc);
    ptr->sig_rj_nw.connect(&sig_rj_nw);
    ptr->sig_rj_md.connect(&sig_rj_md);
    ptr->sig_rj_cc.connect(&sig_rj_cc);
    ptr->sig_cf_nw.connect(&sig_cf_nw);
    ptr->sig_cf_md.connect(&sig_cf_md);
    ptr->sig_cf_cc.connect(&sig_cf_cc);
    ptr->sig_cf_ex.connect(&sig_cf_ex);
    ptr->sig_cf_st.connect(&sig_cf_st);
    ptr->sig_changed.connect(&sig_changed);
    } MTK_CATCH_RETHROW("trd_cli_ls","connecting signals")
}

void mtk::trd::trd_cli_ls::set (const mtk::CountPtr<trd_cli_ls_dangerous_signals_not_warped>& _ptr)
{
ptr = _ptr;
    ptr->sig_rq_nw.connect(&sig_rq_nw);
    ptr->sig_rq_md.connect(&sig_rq_md);
    ptr->sig_rq_cc.connect(&sig_rq_cc);
    ptr->sig_rj_nw.connect(&sig_rj_nw);
    ptr->sig_rj_md.connect(&sig_rj_md);
    ptr->sig_rj_cc.connect(&sig_rj_cc);
    ptr->sig_cf_nw.connect(&sig_cf_nw);
    ptr->sig_cf_md.connect(&sig_cf_md);
    ptr->sig_cf_cc.connect(&sig_cf_cc);
    ptr->sig_cf_ex.connect(&sig_cf_ex);
    ptr->sig_cf_st.connect(&sig_cf_st);
    ptr->sig_changed.connect(&sig_changed);
}


void mtk::trd::trd_cli_ls::rq_nw (const mtk::trd::msg::RQ_NW_LS&   rq           )
{
    ptr->rq_nw(rq);
}
void mtk::trd::trd_cli_ls::rq_md (const mtk::trd::msg::RQ_MD_LS&   rq           )
{
    ptr->rq_md(rq);
}
void mtk::trd::trd_cli_ls::rq_cc (const mtk::trd::msg::RQ_CC_LS&   rq           )
{
    ptr->rq_cc(rq);
}
void mtk::trd::trd_cli_ls::cf_nw (const mtk::trd::msg::CF_NW_LS&   cf           )
{
    ptr->cf_nw(cf);
}
void mtk::trd::trd_cli_ls::cf_md (const mtk::trd::msg::CF_MD_LS&   cf           )
{
    ptr->cf_md(cf);
}
void mtk::trd::trd_cli_ls::cf_cc (const mtk::trd::msg::CF_CC_LS&   cf           )
{
    ptr->cf_cc(cf);
}
void mtk::trd::trd_cli_ls::rj_nw (const mtk::trd::msg::RJ_NW_LS&   rj           )
{
    ptr->rj_nw(rj);
}
void mtk::trd::trd_cli_ls::rj_md (const mtk::trd::msg::RJ_MD_LS&   rj           )
{
    ptr->rj_md(rj);
}
void mtk::trd::trd_cli_ls::rj_cc (const mtk::trd::msg::RJ_CC_LS&   rj           )
{
    ptr->rj_cc(rj);
}
void mtk::trd::trd_cli_ls::cf_ex (const mtk::trd::msg::CF_EX_LS&   ex           )
{
    ptr->cf_ex(ex);
}
void mtk::trd::trd_cli_ls::cf_exLK (const mtk::trd::msg::CF_EXLK&   exlk         )
{
    ptr->cf_exLK(exlk);
}
void mtk::trd::trd_cli_ls::cf_st (const mtk::trd::msg::CF_ST_LS&   st           )
{
    ptr->cf_st(st);
}
const mtk::nullable<mtk::trd::msg::CF_XX_LS>           & mtk::trd::trd_cli_ls::last_confirmation (void) const
{
    return  ptr->last_confirmation();
}
const mtk::nullable<mtk::trd::msg::RQ_XX_LS>           & mtk::trd::trd_cli_ls::last_request (void) const
{
    return  ptr->last_request();
}
const mtk::CountPtr<mtk::trd::hist::order_historic_dangerous_not_signal_warped      >   & mtk::trd::trd_cli_ls::history (void) const
{
    return  ptr->history();
}
const mtk::CountPtr<mtk::trd::hist::order_EXECS_historic_dangerous_not_signal_warped>   & mtk::trd::trd_cli_ls::executions (void) const
{
    return  ptr->executions();
}
const bool                                             & mtk::trd::trd_cli_ls::in_market (void) const
{
    return  ptr->in_market();
}
const bool                                             & mtk::trd::trd_cli_ls::is_canceled (void) const
{
    return  ptr->is_canceled();
}
const bool                                             & mtk::trd::trd_cli_ls::is_full_executed (void) const
{
    return  ptr->is_full_executed();
}
const bool                                             & mtk::trd::trd_cli_ls::has_pending_rq (void) const
{
    return  ptr->has_pending_rq();
}
const std::string                                      & mtk::trd::trd_cli_ls::serrors (void) const
{
    return  ptr->serrors();
}
std::string  mtk::trd::trd_cli_ls::get_coverage_string (void)
{
    return ptr->get_coverage_string();
}
