//  code generated by fsm_gen
// generated automatically
// coded last modification:        $CODED_LAST_MODIF  desactivated, lots of false notifications
// pythonscript last modification: $SCRIPT_LAST_MODIF



namespace fsmgen_trd_cli_ls {


class abstract_status;

// -----------------------------------------------------------------------
//      s t a t u s _ c o m m o n _ i n f o

struct  status_common_info
{
    status_common_info ( mtk::Signal<const mtk::trd::msg::RQ_NW_LS&   /*rq*/         >& _sig_rq_nw, mtk::Signal<const mtk::trd::msg::RQ_MD_LS&   /*rq*/         >& _sig_rq_md, mtk::Signal<const mtk::trd::msg::RQ_CC_LS&   /*rq*/         >& _sig_rq_cc, mtk::Signal<const mtk::trd::msg::RJ_NW_LS&   /*rj*/         >& _sig_rj_nw, mtk::Signal<const mtk::trd::msg::RJ_MD_LS&   /*rj*/         >& _sig_rj_md, mtk::Signal<const mtk::trd::msg::RJ_CC_LS&   /*rj*/         >& _sig_rj_cc, mtk::Signal<const mtk::trd::msg::CF_NW_LS&   /*cf*/         >& _sig_cf_nw, mtk::Signal<const mtk::trd::msg::CF_MD_LS&   /*cf*/         >& _sig_cf_md, mtk::Signal<const mtk::trd::msg::CF_CC_LS&   /*cf*/         >& _sig_cf_cc, mtk::Signal<const mtk::trd::msg::CF_EX_LS&   /*ex*/         >& _sig_cf_ex, mtk::Signal<const mtk::trd::msg::CF_ST_LS&   /*st*/         >& _sig_cf_st, mtk::Signal<>& _sig_changed)
        :  
        __last_confirmation(mtk::nullable<mtk::trd::msg::CF_XX_LS>() ),
        __last_request(mtk::nullable<mtk::trd::msg::RQ_XX_LS>() ),
        __history(mtk::make_cptr(new mtk::trd::hist::order_historic_dangerous_not_signal_warped) ),
        __serrors(""), 
        sig_rq_nw (_sig_rq_nw), 
        sig_rq_md (_sig_rq_md), 
        sig_rq_cc (_sig_rq_cc), 
        sig_rj_nw (_sig_rj_nw), 
        sig_rj_md (_sig_rj_md), 
        sig_rj_cc (_sig_rj_cc), 
        sig_cf_nw (_sig_cf_nw), 
        sig_cf_md (_sig_cf_md), 
        sig_cf_cc (_sig_cf_cc), 
        sig_cf_ex (_sig_cf_ex), 
        sig_cf_st (_sig_cf_st), 
        sig_changed (_sig_changed)
        {};
    virtual ~status_common_info(){};

    // PROPERTIES AND SIGNALS
    mtk::nullable<mtk::trd::msg::CF_XX_LS>           __last_confirmation;
    virtual const mtk::nullable<mtk::trd::msg::CF_XX_LS>          &  last_confirmation() const {  return __last_confirmation; };
    virtual void set_last_confirmation(const mtk::nullable<mtk::trd::msg::CF_XX_LS>          &  _prop) {  __last_confirmation = _prop;  };
    mtk::nullable<mtk::trd::msg::RQ_XX_LS>           __last_request;
    virtual const mtk::nullable<mtk::trd::msg::RQ_XX_LS>          &  last_request() const {  return __last_request; };
    virtual void set_last_request(const mtk::nullable<mtk::trd::msg::RQ_XX_LS>          &  _prop) {  __last_request = _prop;  };
    mtk::CountPtr<mtk::trd::hist::order_historic_dangerous_not_signal_warped>   __history;
    virtual const mtk::CountPtr<mtk::trd::hist::order_historic_dangerous_not_signal_warped>  &  history() const {  return __history; };
    virtual void set_history(const mtk::CountPtr<mtk::trd::hist::order_historic_dangerous_not_signal_warped>  &  _prop) {  __history = _prop;  };
    virtual const bool                                             &  in_market() const {  static bool                                             result(false);   return result; };
    virtual void set_in_market(const bool                                            & ) {  throw mtk::Alarm(MTK_HERE, "fsm_gen.set_property", "property not valid in current status", mtk::alPriorError);  };
    virtual const bool                                             &  is_canceled() const {  static bool                                             result(false);   return result; };
    virtual void set_is_canceled(const bool                                            & ) {  throw mtk::Alarm(MTK_HERE, "fsm_gen.set_property", "property not valid in current status", mtk::alPriorError);  };
    virtual const bool                                             &  is_full_executed() const {  static bool                                             result(false);   return result; };
    virtual void set_is_full_executed(const bool                                            & ) {  throw mtk::Alarm(MTK_HERE, "fsm_gen.set_property", "property not valid in current status", mtk::alPriorError);  };
    virtual const bool                                             &  has_pending_rq() const {  static bool                                             result(false);   return result; };
    virtual void set_has_pending_rq(const bool                                            & ) {  throw mtk::Alarm(MTK_HERE, "fsm_gen.set_property", "property not valid in current status", mtk::alPriorError);  };
    std::string                                      __serrors;
    virtual const std::string                                     &  serrors() const {  return __serrors; };
    virtual void set_serrors(const std::string                                     &  _prop) {  __serrors = _prop;  };
    mtk::Signal<const mtk::trd::msg::RQ_NW_LS&   /*rq*/         >& sig_rq_nw;
    mtk::Signal<const mtk::trd::msg::RQ_MD_LS&   /*rq*/         >& sig_rq_md;
    mtk::Signal<const mtk::trd::msg::RQ_CC_LS&   /*rq*/         >& sig_rq_cc;
    mtk::Signal<const mtk::trd::msg::RJ_NW_LS&   /*rj*/         >& sig_rj_nw;
    mtk::Signal<const mtk::trd::msg::RJ_MD_LS&   /*rj*/         >& sig_rj_md;
    mtk::Signal<const mtk::trd::msg::RJ_CC_LS&   /*rj*/         >& sig_rj_cc;
    mtk::Signal<const mtk::trd::msg::CF_NW_LS&   /*cf*/         >& sig_cf_nw;
    mtk::Signal<const mtk::trd::msg::CF_MD_LS&   /*cf*/         >& sig_cf_md;
    mtk::Signal<const mtk::trd::msg::CF_CC_LS&   /*cf*/         >& sig_cf_cc;
    mtk::Signal<const mtk::trd::msg::CF_EX_LS&   /*ex*/         >& sig_cf_ex;
    mtk::Signal<const mtk::trd::msg::CF_ST_LS&   /*st*/         >& sig_cf_st;
    mtk::Signal<>& sig_changed;


    mtk::Signal<mtk::CountPtr<abstract_status> > signal_new_status;
    mtk::Signal<> signal_keep_temp_status;
    mtk::Signal<> signal_remove_temp_status;

};





// -----------------------------------------------------------------------
//      abstract_status
class abstract_status  : public mtk::SignalReceptor
{
    mtk::non_copyable  nc;

public:
    abstract_status (mtk::CountPtr<status_common_info> _ci)
        : ci (_ci) {};
    virtual ~abstract_status() {};
    
    mtk::CountPtr<status_common_info> ci;
    
    virtual std::string  GetStatusName() = 0;

    //  INPUTS
    virtual void rq_nw ( const mtk::trd::msg::RQ_NW_LS&   rq           )=0;
    virtual void rq_md ( const mtk::trd::msg::RQ_MD_LS&   rq           )=0;
    virtual void rq_cc ( const mtk::trd::msg::RQ_CC_LS&   rq           )=0;
    virtual void cf_nw ( const mtk::trd::msg::CF_NW_LS&   cf           )=0;
    virtual void cf_md ( const mtk::trd::msg::CF_MD_LS&   cf           )=0;
    virtual void cf_cc ( const mtk::trd::msg::CF_CC_LS&   cf           )=0;
    virtual void rj_nw ( const mtk::trd::msg::RJ_NW_LS&   rj           )=0;
    virtual void rj_md ( const mtk::trd::msg::RJ_MD_LS&   rj           )=0;
    virtual void rj_cc ( const mtk::trd::msg::RJ_CC_LS&   rj           )=0;
    virtual void cf_ex ( const mtk::trd::msg::CF_EX_LS&   ex           )=0;
    virtual void cf_st ( const mtk::trd::msg::CF_ST_LS&   st           )=0;


    //  ACCESS
    virtual const mtk::nullable<mtk::trd::msg::CF_XX_LS>           &  last_confirmation (void) const { return ci->last_confirmation(); }; 
    virtual const mtk::nullable<mtk::trd::msg::RQ_XX_LS>           &  last_request (void) const { return ci->last_request(); }; 
    virtual const mtk::CountPtr<mtk::trd::hist::order_historic_dangerous_not_signal_warped>   &  history (void) const { return ci->history(); }; 
    virtual const bool                                             &  in_market (void) const { return ci->in_market(); }; 
    virtual const bool                                             &  is_canceled (void) const { return ci->is_canceled(); }; 
    virtual const bool                                             &  is_full_executed (void) const { return ci->is_full_executed(); }; 
    virtual const bool                                             &  has_pending_rq (void) const { return ci->has_pending_rq(); }; 
    virtual const std::string                                      &  serrors (void) const { return ci->serrors(); }; 

};





// -----------------------------------------------------------------------
//      init
class init  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef init  CLASS_NAME;

public:
    init (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci)

        {  };
    
    std::string  GetStatusName()  {  return "init"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_LS&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_LS&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_LS&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_LS&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_LS&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_LS&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_LS&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_LS&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_LS&   rj           );
    void cf_ex (const mtk::trd::msg::CF_EX_LS&   ex           );
    void cf_st (const mtk::trd::msg::CF_ST_LS&   st           );


};



// -----------------------------------------------------------------------
//      w_cfnw
class w_cfnw  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef w_cfnw  CLASS_NAME;

public:
    w_cfnw (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci),
        __has_pending_rq(true)
        {  };
    
    std::string  GetStatusName()  {  return "w_cfnw"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    bool                                         __has_pending_rq;
    virtual const bool                                        &  has_pending_rq() const {  return __has_pending_rq; };
    virtual void set_has_pending_rq(const bool                                        &  _prop) {  __has_pending_rq = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_LS&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_LS&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_LS&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_LS&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_LS&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_LS&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_LS&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_LS&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_LS&   rj           );
    void cf_ex (const mtk::trd::msg::CF_EX_LS&   ex           );
    void cf_st (const mtk::trd::msg::CF_ST_LS&   st           );


};



// -----------------------------------------------------------------------
//      market
class market  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef market  CLASS_NAME;

public:
    market (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci),
        __in_market(true)
        {  };
    
    std::string  GetStatusName()  {  return "market"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    bool                                         __in_market;
    virtual const bool                                        &  in_market() const {  return __in_market; };
    virtual void set_in_market(const bool                                        &  _prop) {  __in_market = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_LS&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_LS&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_LS&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_LS&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_LS&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_LS&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_LS&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_LS&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_LS&   rj           );
    void cf_ex (const mtk::trd::msg::CF_EX_LS&   ex           );
    void cf_st (const mtk::trd::msg::CF_ST_LS&   st           );


};



// -----------------------------------------------------------------------
//      w_cfmd
class w_cfmd  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef w_cfmd  CLASS_NAME;

public:
    w_cfmd (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci),
        __has_pending_rq(true)
        {  };
    
    std::string  GetStatusName()  {  return "w_cfmd"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    bool                                         __has_pending_rq;
    virtual const bool                                        &  has_pending_rq() const {  return __has_pending_rq; };
    virtual void set_has_pending_rq(const bool                                        &  _prop) {  __has_pending_rq = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_LS&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_LS&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_LS&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_LS&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_LS&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_LS&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_LS&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_LS&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_LS&   rj           );
    void cf_ex (const mtk::trd::msg::CF_EX_LS&   ex           );
    void cf_st (const mtk::trd::msg::CF_ST_LS&   st           );


};



// -----------------------------------------------------------------------
//      w_cfcc
class w_cfcc  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef w_cfcc  CLASS_NAME;

public:
    w_cfcc (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci),
        __has_pending_rq(true)
        {  };
    
    std::string  GetStatusName()  {  return "w_cfcc"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    bool                                         __has_pending_rq;
    virtual const bool                                        &  has_pending_rq() const {  return __has_pending_rq; };
    virtual void set_has_pending_rq(const bool                                        &  _prop) {  __has_pending_rq = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_LS&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_LS&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_LS&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_LS&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_LS&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_LS&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_LS&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_LS&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_LS&   rj           );
    void cf_ex (const mtk::trd::msg::CF_EX_LS&   ex           );
    void cf_st (const mtk::trd::msg::CF_ST_LS&   st           );


};



// -----------------------------------------------------------------------
//      w_cfmdcc
class w_cfmdcc  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef w_cfmdcc  CLASS_NAME;

public:
    w_cfmdcc (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci),
        __has_pending_rq(true)
        {  };
    
    std::string  GetStatusName()  {  return "w_cfmdcc"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    bool                                         __has_pending_rq;
    virtual const bool                                        &  has_pending_rq() const {  return __has_pending_rq; };
    virtual void set_has_pending_rq(const bool                                        &  _prop) {  __has_pending_rq = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_LS&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_LS&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_LS&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_LS&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_LS&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_LS&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_LS&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_LS&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_LS&   rj           );
    void cf_ex (const mtk::trd::msg::CF_EX_LS&   ex           );
    void cf_st (const mtk::trd::msg::CF_ST_LS&   st           );


};



// -----------------------------------------------------------------------
//      w_cfnwmd
class w_cfnwmd  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef w_cfnwmd  CLASS_NAME;

public:
    w_cfnwmd (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci),
        __has_pending_rq(true)
        {  };
    
    std::string  GetStatusName()  {  return "w_cfnwmd"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    bool                                         __has_pending_rq;
    virtual const bool                                        &  has_pending_rq() const {  return __has_pending_rq; };
    virtual void set_has_pending_rq(const bool                                        &  _prop) {  __has_pending_rq = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_LS&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_LS&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_LS&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_LS&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_LS&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_LS&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_LS&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_LS&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_LS&   rj           );
    void cf_ex (const mtk::trd::msg::CF_EX_LS&   ex           );
    void cf_st (const mtk::trd::msg::CF_ST_LS&   st           );


};



// -----------------------------------------------------------------------
//      w_cfnwcc
class w_cfnwcc  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef w_cfnwcc  CLASS_NAME;

public:
    w_cfnwcc (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci),
        __has_pending_rq(true)
        {  };
    
    std::string  GetStatusName()  {  return "w_cfnwcc"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    bool                                         __has_pending_rq;
    virtual const bool                                        &  has_pending_rq() const {  return __has_pending_rq; };
    virtual void set_has_pending_rq(const bool                                        &  _prop) {  __has_pending_rq = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_LS&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_LS&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_LS&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_LS&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_LS&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_LS&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_LS&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_LS&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_LS&   rj           );
    void cf_ex (const mtk::trd::msg::CF_EX_LS&   ex           );
    void cf_st (const mtk::trd::msg::CF_ST_LS&   st           );


};



// -----------------------------------------------------------------------
//      canceled
class canceled  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef canceled  CLASS_NAME;

public:
    canceled (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci),
        __is_canceled(true)
        {  };
    
    std::string  GetStatusName()  {  return "canceled"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    bool                                         __is_canceled;
    virtual const bool                                        &  is_canceled() const {  return __is_canceled; };
    virtual void set_is_canceled(const bool                                        &  _prop) {  __is_canceled = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_LS&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_LS&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_LS&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_LS&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_LS&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_LS&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_LS&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_LS&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_LS&   rj           );
    void cf_ex (const mtk::trd::msg::CF_EX_LS&   ex           );
    void cf_st (const mtk::trd::msg::CF_ST_LS&   st           );


};



// -----------------------------------------------------------------------
//      executed
class executed  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef executed  CLASS_NAME;

public:
    executed (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci),
        __is_full_executed(true)
        {  };
    
    std::string  GetStatusName()  {  return "executed"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    bool                                         __is_full_executed;
    virtual const bool                                        &  is_full_executed() const {  return __is_full_executed; };
    virtual void set_is_full_executed(const bool                                        &  _prop) {  __is_full_executed = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_LS&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_LS&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_LS&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_LS&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_LS&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_LS&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_LS&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_LS&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_LS&   rj           );
    void cf_ex (const mtk::trd::msg::CF_EX_LS&   ex           );
    void cf_st (const mtk::trd::msg::CF_ST_LS&   st           );


};



// -----------------------------------------------------------------------
//      error
class error  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef error  CLASS_NAME;

public:
    error (mtk::CountPtr<status_common_info> _ci,  const std::string                                      & _description)
        : 
        abstract_status(_ci),
        __description(_description)
        { 
            try
            {
                  
            ci->__serrors += std::string(", ") + description();   
            mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", description(), mtk::alPriorCritic, mtk::alTypeNoPermisions));  
      
            }
            MTK_CATCH_RETHROW("error_ctor", "rethrowed") };
    
    std::string  GetStatusName()  {  return "error"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    std::string                                       __description;
    virtual const std::string                                      &  description() const {  return __description; };
    virtual void set_description(const std::string                                      &  _prop) {  __description = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_LS&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_LS&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_LS&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_LS&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_LS&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_LS&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_LS&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_LS&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_LS&   rj           );
    void cf_ex (const mtk::trd::msg::CF_EX_LS&   ex           );
    void cf_st (const mtk::trd::msg::CF_ST_LS&   st           );


};






void init::rq_nw ( const mtk::trd::msg::RQ_NW_LS&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "init::rq_nw";

      CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_rq

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid rqnw ")       ));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 CREATE_AND_SEND_REJECT(sig_rj_nw, RJ_NW_LS)      ADD_HIST_RJ(csr_rj, nw)      ci->sig_changed();  

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnw (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_rqnw
  ADD_HIST_RQ(rq, nw)     ci->sig_rq_nw(rq);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::rq_md ( const mtk::trd::msg::RQ_MD_LS&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "init::rq_md";

      CHECK_REQUEST_MOD_AND_WRITE_LAST_REQ  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 CREATE_AND_SEND_REJECT(sig_rj_md, RJ_MD_LS)      ADD_HIST_RJ(csr_rj, md)      ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::rq_cc ( const mtk::trd::msg::RQ_CC_LS&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "init::rq_cc";

      CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqcc
 CREATE_AND_SEND_REJECT(sig_rj_cc, RJ_CC_LS)      ADD_HIST_RJ(csr_rj, cc)      ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::cf_nw ( const mtk::trd::msg::CF_NW_LS&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "init::cf_nw";

      CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::cf_md ( const mtk::trd::msg::CF_MD_LS&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "init::cf_md";

      CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::cf_cc ( const mtk::trd::msg::CF_CC_LS&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "init::cf_cc";

      CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::rj_nw ( const mtk::trd::msg::RJ_NW_LS&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "init::rj_nw";

      CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::rj_md ( const mtk::trd::msg::RJ_MD_LS&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "init::rj_md";

      CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::rj_cc ( const mtk::trd::msg::RJ_CC_LS&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "init::rj_cc";

      CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::cf_ex ( const mtk::trd::msg::CF_EX_LS&   ex            )
{
    //  remove unused warning
    (void) ex;

    
	static const char* method_name = "init::cf_ex";

          
                                const mtk::trd::msg::CF_XX_LS& cf(ex);
                                CHECK_CONFIRM_AND_WRITE_LAST_CONF
                                CHECK_EXEC  
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: full_exec

                    last_confirmation().HasValue() == true
                    &&  last_confirmation().Get().total_execs.acc_quantity
                        == last_confirmation().Get().market_pos.quantity
                 ) {

            new_status = mtk::make_cptr(new executed (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ADD_HIST_CFEX(ex)       ci->sig_cf_ex(ex);  ci->sig_changed();  

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ADD_HIST_CFEX(ex)       ci->sig_cf_ex(ex);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::cf_st ( const mtk::trd::msg::CF_ST_LS&   st            )
{
    //  remove unused warning
    (void) st;

    
	static const char* method_name = "init::cf_st";

      IF_LAST_CONF_ISNULL__WRITE_IT         

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: full_exec

                    last_confirmation().HasValue() == true
                    &&  last_confirmation().Get().total_execs.acc_quantity
                        == last_confirmation().Get().market_pos.quantity
                 ) {

            new_status = mtk::make_cptr(new executed (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfst
                          ci->sig_cf_st(st);  ci->sig_changed();  

        }
    else 
        if (//  inserting macro: is_rem_qty_zero

                    last_confirmation().HasValue() == true
                    &&  last_confirmation().Get().total_execs.remaining_qty.GetIntCode() == 0
                 ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfst
                          ci->sig_cf_st(st);  ci->sig_changed();  

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfst
                          ci->sig_cf_st(st);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::rq_nw ( const mtk::trd::msg::RQ_NW_LS&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfnw::rq_nw";

      CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 CREATE_AND_SEND_REJECT(sig_rj_nw, RJ_NW_LS)      ADD_HIST_RJ(csr_rj, nw)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::rq_md ( const mtk::trd::msg::RQ_MD_LS&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfnw::rq_md";

      CHECK_REQUEST_MOD_AND_WRITE_LAST_REQ  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_rq

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new w_cfnwcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 CREATE_AND_SEND_REJECT(sig_rj_md, RJ_MD_LS)      ADD_HIST_RJ(csr_rj, md)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnwmd (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_rqmd
  ADD_HIST_RQ(rq, md)     ci->sig_rq_md(rq);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::rq_cc ( const mtk::trd::msg::RQ_CC_LS&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfnw::rq_cc";

      CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnwcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::cf_nw ( const mtk::trd::msg::CF_NW_LS&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfnw::cf_nw";

      CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_cf

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid cfnw ")       ));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::cf_md ( const mtk::trd::msg::CF_MD_LS&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfnw::cf_md";

      CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::cf_cc ( const mtk::trd::msg::CF_CC_LS&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfnw::cf_cc";

      CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::rj_nw ( const mtk::trd::msg::RJ_NW_LS&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfnw::rj_nw";

      CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ADD_HIST_RJ(rj, nw)     ci->sig_rj_nw(rj);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::rj_md ( const mtk::trd::msg::RJ_MD_LS&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfnw::rj_md";

      CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ADD_HIST_RJ(rj, md)     ci->sig_rj_md(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::rj_cc ( const mtk::trd::msg::RJ_CC_LS&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfnw::rj_cc";

      CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ADD_HIST_RJ(rj, cc)     ci->sig_rj_cc(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::cf_ex ( const mtk::trd::msg::CF_EX_LS&   ex            )
{
    //  remove unused warning
    (void) ex;

    
	static const char* method_name = "w_cfnw::cf_ex";

          
                                const mtk::trd::msg::CF_XX_LS& cf(ex);
                                CHECK_CONFIRM_AND_WRITE_LAST_CONF
                                CHECK_EXEC  
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ADD_HIST_CFEX(ex)       ci->sig_cf_ex(ex);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::cf_st ( const mtk::trd::msg::CF_ST_LS&   st            )
{
    //  remove unused warning
    (void) st;

    
	static const char* method_name = "w_cfnw::cf_st";

      IF_LAST_CONF_ISNULL__WRITE_IT         

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnw (ci));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::rq_nw ( const mtk::trd::msg::RQ_NW_LS&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "market::rq_nw";

      CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 CREATE_AND_SEND_REJECT(sig_rj_nw, RJ_NW_LS)      ADD_HIST_RJ(csr_rj, nw)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::rq_md ( const mtk::trd::msg::RQ_MD_LS&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "market::rq_md";

      CHECK_REQUEST_MOD_AND_WRITE_LAST_REQ  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_rq

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new w_cfcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 CREATE_AND_SEND_REJECT(sig_rj_md, RJ_MD_LS)      ADD_HIST_RJ(csr_rj, md)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmd (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_rqmd
  ADD_HIST_RQ(rq, md)     ci->sig_rq_md(rq);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::rq_cc ( const mtk::trd::msg::RQ_CC_LS&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "market::rq_cc";

      CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::cf_nw ( const mtk::trd::msg::CF_NW_LS&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "market::cf_nw";

      CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::cf_md ( const mtk::trd::msg::CF_MD_LS&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "market::cf_md";

      CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd_nr
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::cf_cc ( const mtk::trd::msg::CF_CC_LS&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "market::cf_cc";

      CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_cf

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid cfcc")   ));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc_nr
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc_nr
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::rj_nw ( const mtk::trd::msg::RJ_NW_LS&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "market::rj_nw";

      CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ADD_HIST_RJ(rj, nw)     ci->sig_rj_nw(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::rj_md ( const mtk::trd::msg::RJ_MD_LS&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "market::rj_md";

      CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ADD_HIST_RJ(rj, md)     ci->sig_rj_md(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::rj_cc ( const mtk::trd::msg::RJ_CC_LS&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "market::rj_cc";

      CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ADD_HIST_RJ(rj, cc)     ci->sig_rj_cc(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::cf_ex ( const mtk::trd::msg::CF_EX_LS&   ex            )
{
    //  remove unused warning
    (void) ex;

    
	static const char* method_name = "market::cf_ex";

          
                                const mtk::trd::msg::CF_XX_LS& cf(ex);
                                CHECK_CONFIRM_AND_WRITE_LAST_CONF
                                CHECK_EXEC  
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: full_exec

                    last_confirmation().HasValue() == true
                    &&  last_confirmation().Get().total_execs.acc_quantity
                        == last_confirmation().Get().market_pos.quantity
                 ) {

            new_status = mtk::make_cptr(new executed (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ADD_HIST_CFEX(ex)       ci->sig_cf_ex(ex);  ci->sig_changed();  

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ADD_HIST_CFEX(ex)       ci->sig_cf_ex(ex);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::cf_st ( const mtk::trd::msg::CF_ST_LS&   st            )
{
    //  remove unused warning
    (void) st;

    
	static const char* method_name = "market::cf_st";

      IF_LAST_CONF_ISNULL__WRITE_IT         

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::rq_nw ( const mtk::trd::msg::RQ_NW_LS&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfmd::rq_nw";

      CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 CREATE_AND_SEND_REJECT(sig_rj_nw, RJ_NW_LS)      ADD_HIST_RJ(csr_rj, nw)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::rq_md ( const mtk::trd::msg::RQ_MD_LS&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfmd::rq_md";

      CHECK_REQUEST_MOD_AND_WRITE_LAST_REQ  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_rq

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid rqmd")));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 CREATE_AND_SEND_REJECT(sig_rj_md, RJ_MD_LS)      ADD_HIST_RJ(csr_rj, md)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmd (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_rqmd
  ADD_HIST_RQ(rq, md)     ci->sig_rq_md(rq);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::rq_cc ( const mtk::trd::msg::RQ_CC_LS&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfmd::rq_cc";

      CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmdcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::cf_nw ( const mtk::trd::msg::CF_NW_LS&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfmd::cf_nw";

      CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::cf_md ( const mtk::trd::msg::CF_MD_LS&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfmd::cf_md";

      CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_cf

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid cfmd")));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (//  inserting macro: is_conf_last_rqmd

                    ({  bool result = false;
                        if (ci->last_request().HasValue())
                            result = (cf.req_id == ci->last_request().Get().request_info.req_id);
                        else
                            result = false;
                        result;
                    })
                 ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmd (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd_pend
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::cf_cc ( const mtk::trd::msg::CF_CC_LS&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfmd::cf_cc";

      CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_cf

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid cfcc")  ));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc_nr
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc_nr
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::rj_nw ( const mtk::trd::msg::RJ_NW_LS&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfmd::rj_nw";

      CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ADD_HIST_RJ(rj, nw)     ci->sig_rj_nw(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::rj_md ( const mtk::trd::msg::RJ_MD_LS&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfmd::rj_md";

      CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ADD_HIST_RJ(rj, md)     ci->sig_rj_md(rj);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::rj_cc ( const mtk::trd::msg::RJ_CC_LS&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfmd::rj_cc";

      CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ADD_HIST_RJ(rj, cc)     ci->sig_rj_cc(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::cf_ex ( const mtk::trd::msg::CF_EX_LS&   ex            )
{
    //  remove unused warning
    (void) ex;

    
	static const char* method_name = "w_cfmd::cf_ex";

          
                                const mtk::trd::msg::CF_XX_LS& cf(ex);
                                CHECK_CONFIRM_AND_WRITE_LAST_CONF
                                CHECK_EXEC  
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: full_exec

                    last_confirmation().HasValue() == true
                    &&  last_confirmation().Get().total_execs.acc_quantity
                        == last_confirmation().Get().market_pos.quantity
                 ) {

            new_status = mtk::make_cptr(new executed (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ADD_HIST_CFEX(ex)       ci->sig_cf_ex(ex);  ci->sig_changed();  

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmd (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ADD_HIST_CFEX(ex)       ci->sig_cf_ex(ex);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::cf_st ( const mtk::trd::msg::CF_ST_LS&   st            )
{
    //  remove unused warning
    (void) st;

    
	static const char* method_name = "w_cfmd::cf_st";

      IF_LAST_CONF_ISNULL__WRITE_IT         

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmd (ci));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::rq_nw ( const mtk::trd::msg::RQ_NW_LS&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfcc::rq_nw";

      CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 CREATE_AND_SEND_REJECT(sig_rj_nw, RJ_NW_LS)      ADD_HIST_RJ(csr_rj, nw)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::rq_md ( const mtk::trd::msg::RQ_MD_LS&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfcc::rq_md";

      CHECK_REQUEST_MOD_AND_WRITE_LAST_REQ  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 CREATE_AND_SEND_REJECT(sig_rj_md, RJ_MD_LS)      ADD_HIST_RJ(csr_rj, md)      ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::rq_cc ( const mtk::trd::msg::RQ_CC_LS&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfcc::rq_cc";

      CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::cf_nw ( const mtk::trd::msg::CF_NW_LS&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfcc::cf_nw";

      CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::cf_md ( const mtk::trd::msg::CF_MD_LS&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfcc::cf_md";

      CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::cf_cc ( const mtk::trd::msg::CF_CC_LS&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfcc::cf_cc";

      CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_cf

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid cfcc")  ));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc_nr
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::rj_nw ( const mtk::trd::msg::RJ_NW_LS&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfcc::rj_nw";

      CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ADD_HIST_RJ(rj, nw)     ci->sig_rj_nw(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::rj_md ( const mtk::trd::msg::RJ_MD_LS&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfcc::rj_md";

      CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ADD_HIST_RJ(rj, md)     ci->sig_rj_md(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::rj_cc ( const mtk::trd::msg::RJ_CC_LS&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfcc::rj_cc";

      CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ADD_HIST_RJ(rj, cc)     ci->sig_rj_cc(rj);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::cf_ex ( const mtk::trd::msg::CF_EX_LS&   ex            )
{
    //  remove unused warning
    (void) ex;

    
	static const char* method_name = "w_cfcc::cf_ex";

          
                                const mtk::trd::msg::CF_XX_LS& cf(ex);
                                CHECK_CONFIRM_AND_WRITE_LAST_CONF
                                CHECK_EXEC  
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: full_exec

                    last_confirmation().HasValue() == true
                    &&  last_confirmation().Get().total_execs.acc_quantity
                        == last_confirmation().Get().market_pos.quantity
                 ) {

            new_status = mtk::make_cptr(new executed (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ADD_HIST_CFEX(ex)       ci->sig_cf_ex(ex);  ci->sig_changed();  

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ADD_HIST_CFEX(ex)       ci->sig_cf_ex(ex);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::cf_st ( const mtk::trd::msg::CF_ST_LS&   st            )
{
    //  remove unused warning
    (void) st;

    
	static const char* method_name = "w_cfcc::cf_st";

      IF_LAST_CONF_ISNULL__WRITE_IT         

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfcc (ci));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::rq_nw ( const mtk::trd::msg::RQ_NW_LS&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfmdcc::rq_nw";

      CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 CREATE_AND_SEND_REJECT(sig_rj_nw, RJ_NW_LS)      ADD_HIST_RJ(csr_rj, nw)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::rq_md ( const mtk::trd::msg::RQ_MD_LS&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfmdcc::rq_md";

      CHECK_REQUEST_MOD_AND_WRITE_LAST_REQ  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_rq

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new w_cfmdcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 CREATE_AND_SEND_REJECT(sig_rj_md, RJ_MD_LS)      ADD_HIST_RJ(csr_rj, md)      ci->sig_changed();  

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmdcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 CREATE_AND_SEND_REJECT(sig_rj_md, RJ_MD_LS)      ADD_HIST_RJ(csr_rj, md)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::rq_cc ( const mtk::trd::msg::RQ_CC_LS&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfmdcc::rq_cc";

      CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmdcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::cf_nw ( const mtk::trd::msg::CF_NW_LS&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfmdcc::cf_nw";

      CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::cf_md ( const mtk::trd::msg::CF_MD_LS&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfmdcc::cf_md";

      CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_cf

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid cfmd")));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (//  inserting macro: is_conf_last_rqmd

                    ({  bool result = false;
                        if (ci->last_request().HasValue())
                            result = (cf.req_id == ci->last_request().Get().request_info.req_id);
                        else
                            result = false;
                        result;
                    })
                 ) {

            new_status = mtk::make_cptr(new w_cfcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmdcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd_pend
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::cf_cc ( const mtk::trd::msg::CF_CC_LS&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfmdcc::cf_cc";

      CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_cf

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid cfcc")  ));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc_nr
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::rj_nw ( const mtk::trd::msg::RJ_NW_LS&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfmdcc::rj_nw";

      CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ADD_HIST_RJ(rj, nw)     ci->sig_rj_nw(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::rj_md ( const mtk::trd::msg::RJ_MD_LS&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfmdcc::rj_md";

      CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ADD_HIST_RJ(rj, md)     ci->sig_rj_md(rj);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::rj_cc ( const mtk::trd::msg::RJ_CC_LS&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfmdcc::rj_cc";

      CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmd (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ADD_HIST_RJ(rj, cc)     ci->sig_rj_cc(rj);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::cf_ex ( const mtk::trd::msg::CF_EX_LS&   ex            )
{
    //  remove unused warning
    (void) ex;

    
	static const char* method_name = "w_cfmdcc::cf_ex";

          
                                const mtk::trd::msg::CF_XX_LS& cf(ex);
                                CHECK_CONFIRM_AND_WRITE_LAST_CONF
                                CHECK_EXEC  
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: full_exec

                    last_confirmation().HasValue() == true
                    &&  last_confirmation().Get().total_execs.acc_quantity
                        == last_confirmation().Get().market_pos.quantity
                 ) {

            new_status = mtk::make_cptr(new executed (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ADD_HIST_CFEX(ex)       ci->sig_cf_ex(ex);  ci->sig_changed();  

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmdcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ADD_HIST_CFEX(ex)       ci->sig_cf_ex(ex);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::cf_st ( const mtk::trd::msg::CF_ST_LS&   st            )
{
    //  remove unused warning
    (void) st;

    
	static const char* method_name = "w_cfmdcc::cf_st";

      IF_LAST_CONF_ISNULL__WRITE_IT         

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmdcc (ci));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::rq_nw ( const mtk::trd::msg::RQ_NW_LS&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfnwmd::rq_nw";

      CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 CREATE_AND_SEND_REJECT(sig_rj_nw, RJ_NW_LS)      ADD_HIST_RJ(csr_rj, nw)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::rq_md ( const mtk::trd::msg::RQ_MD_LS&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfnwmd::rq_md";

      CHECK_REQUEST_MOD_AND_WRITE_LAST_REQ  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_rq

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new w_cfnwcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 CREATE_AND_SEND_REJECT(sig_rj_md, RJ_MD_LS)      ADD_HIST_RJ(csr_rj, md)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnwmd (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_rqmd
  ADD_HIST_RQ(rq, md)     ci->sig_rq_md(rq);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::rq_cc ( const mtk::trd::msg::RQ_CC_LS&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfnwmd::rq_cc";

      CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnwcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::cf_nw ( const mtk::trd::msg::CF_NW_LS&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfnwmd::cf_nw";

      CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_cf

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid cfnw")));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmd (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::cf_md ( const mtk::trd::msg::CF_MD_LS&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfnwmd::cf_md";

      CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::cf_cc ( const mtk::trd::msg::CF_CC_LS&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfnwmd::cf_cc";

      CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::rj_nw ( const mtk::trd::msg::RJ_NW_LS&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfnwmd::rj_nw";

      CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ADD_HIST_RJ(rj, nw)     ci->sig_rj_nw(rj);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::rj_md ( const mtk::trd::msg::RJ_MD_LS&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfnwmd::rj_md";

      CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ADD_HIST_RJ(rj, md)     ci->sig_rj_md(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::rj_cc ( const mtk::trd::msg::RJ_CC_LS&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfnwmd::rj_cc";

      CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ADD_HIST_RJ(rj, cc)     ci->sig_rj_cc(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::cf_ex ( const mtk::trd::msg::CF_EX_LS&   ex            )
{
    //  remove unused warning
    (void) ex;

    
	static const char* method_name = "w_cfnwmd::cf_ex";

          
                                const mtk::trd::msg::CF_XX_LS& cf(ex);
                                CHECK_CONFIRM_AND_WRITE_LAST_CONF
                                CHECK_EXEC  
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ADD_HIST_CFEX(ex)       ci->sig_cf_ex(ex);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::cf_st ( const mtk::trd::msg::CF_ST_LS&   st            )
{
    //  remove unused warning
    (void) st;

    
	static const char* method_name = "w_cfnwmd::cf_st";

      IF_LAST_CONF_ISNULL__WRITE_IT         

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnwmd (ci));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::rq_nw ( const mtk::trd::msg::RQ_NW_LS&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfnwcc::rq_nw";

      CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 CREATE_AND_SEND_REJECT(sig_rj_nw, RJ_NW_LS)      ADD_HIST_RJ(csr_rj, nw)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::rq_md ( const mtk::trd::msg::RQ_MD_LS&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfnwcc::rq_md";

      CHECK_REQUEST_MOD_AND_WRITE_LAST_REQ  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnwcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_rqmd
  ADD_HIST_RQ(rq, md)     ci->sig_rq_md(rq);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::rq_cc ( const mtk::trd::msg::RQ_CC_LS&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfnwcc::rq_cc";

      CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnwcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::cf_nw ( const mtk::trd::msg::CF_NW_LS&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfnwcc::cf_nw";

      CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_cf

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid cfnw")));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfcc (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::cf_md ( const mtk::trd::msg::CF_MD_LS&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfnwcc::cf_md";

      CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::cf_cc ( const mtk::trd::msg::CF_CC_LS&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfnwcc::cf_cc";

      CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::rj_nw ( const mtk::trd::msg::RJ_NW_LS&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfnwcc::rj_nw";

      CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ADD_HIST_RJ(rj, nw)     ci->sig_rj_nw(rj);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::rj_md ( const mtk::trd::msg::RJ_MD_LS&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfnwcc::rj_md";

      CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ADD_HIST_RJ(rj, md)     ci->sig_rj_md(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::rj_cc ( const mtk::trd::msg::RJ_CC_LS&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfnwcc::rj_cc";

      CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ADD_HIST_RJ(rj, cc)     ci->sig_rj_cc(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::cf_ex ( const mtk::trd::msg::CF_EX_LS&   ex            )
{
    //  remove unused warning
    (void) ex;

    
	static const char* method_name = "w_cfnwcc::cf_ex";

          
                                const mtk::trd::msg::CF_XX_LS& cf(ex);
                                CHECK_CONFIRM_AND_WRITE_LAST_CONF
                                CHECK_EXEC  
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ADD_HIST_CFEX(ex)       ci->sig_cf_ex(ex);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::cf_st ( const mtk::trd::msg::CF_ST_LS&   st            )
{
    //  remove unused warning
    (void) st;

    
	static const char* method_name = "w_cfnwcc::cf_st";

      IF_LAST_CONF_ISNULL__WRITE_IT         

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnwcc (ci));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::rq_nw ( const mtk::trd::msg::RQ_NW_LS&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "canceled::rq_nw";

      CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 CREATE_AND_SEND_REJECT(sig_rj_nw, RJ_NW_LS)      ADD_HIST_RJ(csr_rj, nw)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::rq_md ( const mtk::trd::msg::RQ_MD_LS&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "canceled::rq_md";

      CHECK_REQUEST_MOD_AND_WRITE_LAST_REQ  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 CREATE_AND_SEND_REJECT(sig_rj_md, RJ_MD_LS)      ADD_HIST_RJ(csr_rj, md)      ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::rq_cc ( const mtk::trd::msg::RQ_CC_LS&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "canceled::rq_cc";

      CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqcc
 CREATE_AND_SEND_REJECT(sig_rj_cc, RJ_CC_LS)      ADD_HIST_RJ(csr_rj, cc)      ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::cf_nw ( const mtk::trd::msg::CF_NW_LS&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "canceled::cf_nw";

      CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::cf_md ( const mtk::trd::msg::CF_MD_LS&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "canceled::cf_md";

      CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::cf_cc ( const mtk::trd::msg::CF_CC_LS&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "canceled::cf_cc";

      CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::rj_nw ( const mtk::trd::msg::RJ_NW_LS&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "canceled::rj_nw";

      CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ADD_HIST_RJ(rj, nw)     ci->sig_rj_nw(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::rj_md ( const mtk::trd::msg::RJ_MD_LS&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "canceled::rj_md";

      CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ADD_HIST_RJ(rj, md)     ci->sig_rj_md(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::rj_cc ( const mtk::trd::msg::RJ_CC_LS&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "canceled::rj_cc";

      CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ADD_HIST_RJ(rj, cc)     ci->sig_rj_cc(rj);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::cf_ex ( const mtk::trd::msg::CF_EX_LS&   ex            )
{
    //  remove unused warning
    (void) ex;

    
	static const char* method_name = "canceled::cf_ex";

          
                                const mtk::trd::msg::CF_XX_LS& cf(ex);
                                CHECK_CONFIRM_AND_WRITE_LAST_CONF
                                CHECK_EXEC  
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ADD_HIST_CFEX(ex)       ci->sig_cf_ex(ex);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::cf_st ( const mtk::trd::msg::CF_ST_LS&   st            )
{
    //  remove unused warning
    (void) st;

    
	static const char* method_name = "canceled::cf_st";

      IF_LAST_CONF_ISNULL__WRITE_IT         

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void executed::rq_nw ( const mtk::trd::msg::RQ_NW_LS&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "executed::rq_nw";

      CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 CREATE_AND_SEND_REJECT(sig_rj_nw, RJ_NW_LS)      ADD_HIST_RJ(csr_rj, nw)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void executed::rq_md ( const mtk::trd::msg::RQ_MD_LS&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "executed::rq_md";

      CHECK_REQUEST_MOD_AND_WRITE_LAST_REQ  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new executed (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 CREATE_AND_SEND_REJECT(sig_rj_md, RJ_MD_LS)      ADD_HIST_RJ(csr_rj, md)      ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void executed::rq_cc ( const mtk::trd::msg::RQ_CC_LS&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "executed::rq_cc";

      CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new executed (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqcc
 CREATE_AND_SEND_REJECT(sig_rj_cc, RJ_CC_LS)      ADD_HIST_RJ(csr_rj, cc)      ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void executed::cf_nw ( const mtk::trd::msg::CF_NW_LS&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "executed::cf_nw";

      CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void executed::cf_md ( const mtk::trd::msg::CF_MD_LS&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "executed::cf_md";

      CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void executed::cf_cc ( const mtk::trd::msg::CF_CC_LS&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "executed::cf_cc";

      CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void executed::rj_nw ( const mtk::trd::msg::RJ_NW_LS&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "executed::rj_nw";

      CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ADD_HIST_RJ(rj, nw)     ci->sig_rj_nw(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void executed::rj_md ( const mtk::trd::msg::RJ_MD_LS&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "executed::rj_md";

      CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ADD_HIST_RJ(rj, md)     ci->sig_rj_md(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void executed::rj_cc ( const mtk::trd::msg::RJ_CC_LS&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "executed::rj_cc";

      CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ADD_HIST_RJ(rj, cc)     ci->sig_rj_cc(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void executed::cf_ex ( const mtk::trd::msg::CF_EX_LS&   ex            )
{
    //  remove unused warning
    (void) ex;

    
	static const char* method_name = "executed::cf_ex";

          
                                const mtk::trd::msg::CF_XX_LS& cf(ex);
                                CHECK_CONFIRM_AND_WRITE_LAST_CONF
                                CHECK_EXEC  
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ADD_HIST_CFEX(ex)       ci->sig_cf_ex(ex);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void executed::cf_st ( const mtk::trd::msg::CF_ST_LS&   st            )
{
    //  remove unused warning
    (void) st;

    
	static const char* method_name = "executed::cf_st";

      IF_LAST_CONF_ISNULL__WRITE_IT         

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new executed (ci));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::rq_nw ( const mtk::trd::msg::RQ_NW_LS&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "error::rq_nw";

      CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 CREATE_AND_SEND_REJECT(sig_rj_nw, RJ_NW_LS)      ADD_HIST_RJ(csr_rj, nw)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::rq_md ( const mtk::trd::msg::RQ_MD_LS&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "error::rq_md";

      CHECK_REQUEST_MOD_AND_WRITE_LAST_REQ  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 CREATE_AND_SEND_REJECT(sig_rj_md, RJ_MD_LS)      ADD_HIST_RJ(csr_rj, md)      ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::rq_cc ( const mtk::trd::msg::RQ_CC_LS&   rq            )
{
    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "error::rq_cc";

      CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::cf_nw ( const mtk::trd::msg::CF_NW_LS&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "error::cf_nw";

      CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::cf_md ( const mtk::trd::msg::CF_MD_LS&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "error::cf_md";

      CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::cf_cc ( const mtk::trd::msg::CF_CC_LS&   cf            )
{
    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "error::cf_cc";

      CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::rj_nw ( const mtk::trd::msg::RJ_NW_LS&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "error::rj_nw";

      CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ADD_HIST_RJ(rj, nw)     ci->sig_rj_nw(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::rj_md ( const mtk::trd::msg::RJ_MD_LS&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "error::rj_md";

      CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ADD_HIST_RJ(rj, md)     ci->sig_rj_md(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::rj_cc ( const mtk::trd::msg::RJ_CC_LS&   rj            )
{
    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "error::rj_cc";

      CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ADD_HIST_RJ(rj, cc)     ci->sig_rj_cc(rj);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::cf_ex ( const mtk::trd::msg::CF_EX_LS&   ex            )
{
    //  remove unused warning
    (void) ex;

    
	static const char* method_name = "error::cf_ex";

          
                                const mtk::trd::msg::CF_XX_LS& cf(ex);
                                CHECK_CONFIRM_AND_WRITE_LAST_CONF
                                CHECK_EXEC  
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfex
  ADD_HIST_CFEX(ex)       ci->sig_cf_ex(ex);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), last_confirmation().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_LS  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), last_request().Get().cli_ref, mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_LS rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_LS rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();  
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_ls.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::cf_st ( const mtk::trd::msg::CF_ST_LS&   st            )
{
    //  remove unused warning
    (void) st;

    
	static const char* method_name = "error::cf_st";

      IF_LAST_CONF_ISNULL__WRITE_IT         

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}


};  // end   namespace fsmgen_trd_cli_ls {

mtk::trd::trd_cli_ls_dangerous_signals_not_warped::trd_cli_ls_dangerous_signals_not_warped()
{
    mtk::CountPtr<fsmgen_trd_cli_ls::status_common_info> ci = mtk::make_cptr(
                            new fsmgen_trd_cli_ls::status_common_info ( sig_rq_nw,sig_rq_md,sig_rq_cc,sig_rj_nw,sig_rj_md,sig_rj_cc,sig_cf_nw,sig_cf_md,sig_cf_cc,sig_cf_ex,sig_cf_st,sig_changed));

    current_status = mtk::make_cptr(new fsmgen_trd_cli_ls::init(ci ) );
    MTK_CONNECT_THIS(ci->signal_new_status, on_new_status)
    MTK_CONNECT_THIS(ci->signal_keep_temp_status, on_keep_temp_status)
    MTK_CONNECT_THIS(ci->signal_remove_temp_status, on_remove_temp_status)
}


mtk::trd::trd_cli_ls_dangerous_signals_not_warped::~trd_cli_ls_dangerous_signals_not_warped()
{
}

void mtk::trd::trd_cli_ls_dangerous_signals_not_warped::on_new_status (mtk::CountPtr<fsmgen_trd_cli_ls::abstract_status>  new_status)
{
    current_status = new_status;
}

void mtk::trd::trd_cli_ls_dangerous_signals_not_warped::on_keep_temp_status (void)
{
    queue_temp_status.push_back(current_status);
}
void mtk::trd::trd_cli_ls_dangerous_signals_not_warped::on_remove_temp_status (void)
{
    queue_temp_status.pop_front();
}


void mtk::trd::trd_cli_ls_dangerous_signals_not_warped::rq_nw (const mtk::trd::msg::RQ_NW_LS&   rq           )
{
    mtk::CountPtr<fsmgen_trd_cli_ls::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->rq_nw(rq);
}
void mtk::trd::trd_cli_ls_dangerous_signals_not_warped::rq_md (const mtk::trd::msg::RQ_MD_LS&   rq           )
{
    mtk::CountPtr<fsmgen_trd_cli_ls::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->rq_md(rq);
}
void mtk::trd::trd_cli_ls_dangerous_signals_not_warped::rq_cc (const mtk::trd::msg::RQ_CC_LS&   rq           )
{
    mtk::CountPtr<fsmgen_trd_cli_ls::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->rq_cc(rq);
}
void mtk::trd::trd_cli_ls_dangerous_signals_not_warped::cf_nw (const mtk::trd::msg::CF_NW_LS&   cf           )
{
    mtk::CountPtr<fsmgen_trd_cli_ls::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->cf_nw(cf);
}
void mtk::trd::trd_cli_ls_dangerous_signals_not_warped::cf_md (const mtk::trd::msg::CF_MD_LS&   cf           )
{
    mtk::CountPtr<fsmgen_trd_cli_ls::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->cf_md(cf);
}
void mtk::trd::trd_cli_ls_dangerous_signals_not_warped::cf_cc (const mtk::trd::msg::CF_CC_LS&   cf           )
{
    mtk::CountPtr<fsmgen_trd_cli_ls::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->cf_cc(cf);
}
void mtk::trd::trd_cli_ls_dangerous_signals_not_warped::rj_nw (const mtk::trd::msg::RJ_NW_LS&   rj           )
{
    mtk::CountPtr<fsmgen_trd_cli_ls::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->rj_nw(rj);
}
void mtk::trd::trd_cli_ls_dangerous_signals_not_warped::rj_md (const mtk::trd::msg::RJ_MD_LS&   rj           )
{
    mtk::CountPtr<fsmgen_trd_cli_ls::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->rj_md(rj);
}
void mtk::trd::trd_cli_ls_dangerous_signals_not_warped::rj_cc (const mtk::trd::msg::RJ_CC_LS&   rj           )
{
    mtk::CountPtr<fsmgen_trd_cli_ls::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->rj_cc(rj);
}
void mtk::trd::trd_cli_ls_dangerous_signals_not_warped::cf_ex (const mtk::trd::msg::CF_EX_LS&   ex           )
{
    mtk::CountPtr<fsmgen_trd_cli_ls::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->cf_ex(ex);
}
void mtk::trd::trd_cli_ls_dangerous_signals_not_warped::cf_st (const mtk::trd::msg::CF_ST_LS&   st           )
{
    mtk::CountPtr<fsmgen_trd_cli_ls::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->cf_st(st);
}
const mtk::nullable<mtk::trd::msg::CF_XX_LS>           & mtk::trd::trd_cli_ls_dangerous_signals_not_warped::last_confirmation (void) const
{
    return current_status->last_confirmation();
}
const mtk::nullable<mtk::trd::msg::RQ_XX_LS>           & mtk::trd::trd_cli_ls_dangerous_signals_not_warped::last_request (void) const
{
    return current_status->last_request();
}
const mtk::CountPtr<mtk::trd::hist::order_historic_dangerous_not_signal_warped>   & mtk::trd::trd_cli_ls_dangerous_signals_not_warped::history (void) const
{
    return current_status->history();
}
const bool                                             & mtk::trd::trd_cli_ls_dangerous_signals_not_warped::in_market (void) const
{
    return current_status->in_market();
}
const bool                                             & mtk::trd::trd_cli_ls_dangerous_signals_not_warped::is_canceled (void) const
{
    return current_status->is_canceled();
}
const bool                                             & mtk::trd::trd_cli_ls_dangerous_signals_not_warped::is_full_executed (void) const
{
    return current_status->is_full_executed();
}
const bool                                             & mtk::trd::trd_cli_ls_dangerous_signals_not_warped::has_pending_rq (void) const
{
    return current_status->has_pending_rq();
}
const std::string                                      & mtk::trd::trd_cli_ls_dangerous_signals_not_warped::serrors (void) const
{
    return current_status->serrors();
}

//  warper RAII with signals and repository
mtk::trd::trd_cli_ls::trd_cli_ls (void)
    : ptr (new trd_cli_ls_dangerous_signals_not_warped())
{
    ptr->sig_rq_nw.connect(&sig_rq_nw);
    ptr->sig_rq_md.connect(&sig_rq_md);
    ptr->sig_rq_cc.connect(&sig_rq_cc);
    ptr->sig_rj_nw.connect(&sig_rj_nw);
    ptr->sig_rj_md.connect(&sig_rj_md);
    ptr->sig_rj_cc.connect(&sig_rj_cc);
    ptr->sig_cf_nw.connect(&sig_cf_nw);
    ptr->sig_cf_md.connect(&sig_cf_md);
    ptr->sig_cf_cc.connect(&sig_cf_cc);
    ptr->sig_cf_ex.connect(&sig_cf_ex);
    ptr->sig_cf_st.connect(&sig_cf_st);
    ptr->sig_changed.connect(&sig_changed);
}
mtk::trd::trd_cli_ls::trd_cli_ls (const mtk::CountPtr<trd_cli_ls_dangerous_signals_not_warped>& _ptr)
    :   ptr(_ptr)
{
    try
    {
    ptr->sig_rq_nw.connect(&sig_rq_nw);
    ptr->sig_rq_md.connect(&sig_rq_md);
    ptr->sig_rq_cc.connect(&sig_rq_cc);
    ptr->sig_rj_nw.connect(&sig_rj_nw);
    ptr->sig_rj_md.connect(&sig_rj_md);
    ptr->sig_rj_cc.connect(&sig_rj_cc);
    ptr->sig_cf_nw.connect(&sig_cf_nw);
    ptr->sig_cf_md.connect(&sig_cf_md);
    ptr->sig_cf_cc.connect(&sig_cf_cc);
    ptr->sig_cf_ex.connect(&sig_cf_ex);
    ptr->sig_cf_st.connect(&sig_cf_st);
    ptr->sig_changed.connect(&sig_changed);
    } MTK_CATCH_RETHROW("trd_cli_ls","connecting signals")
}

void mtk::trd::trd_cli_ls::set (const mtk::CountPtr<trd_cli_ls_dangerous_signals_not_warped>& _ptr)
{
ptr = _ptr;
    ptr->sig_rq_nw.connect(&sig_rq_nw);
    ptr->sig_rq_md.connect(&sig_rq_md);
    ptr->sig_rq_cc.connect(&sig_rq_cc);
    ptr->sig_rj_nw.connect(&sig_rj_nw);
    ptr->sig_rj_md.connect(&sig_rj_md);
    ptr->sig_rj_cc.connect(&sig_rj_cc);
    ptr->sig_cf_nw.connect(&sig_cf_nw);
    ptr->sig_cf_md.connect(&sig_cf_md);
    ptr->sig_cf_cc.connect(&sig_cf_cc);
    ptr->sig_cf_ex.connect(&sig_cf_ex);
    ptr->sig_cf_st.connect(&sig_cf_st);
    ptr->sig_changed.connect(&sig_changed);
}


void mtk::trd::trd_cli_ls::rq_nw (const mtk::trd::msg::RQ_NW_LS&   rq           )
{
    ptr->rq_nw(rq);
}
void mtk::trd::trd_cli_ls::rq_md (const mtk::trd::msg::RQ_MD_LS&   rq           )
{
    ptr->rq_md(rq);
}
void mtk::trd::trd_cli_ls::rq_cc (const mtk::trd::msg::RQ_CC_LS&   rq           )
{
    ptr->rq_cc(rq);
}
void mtk::trd::trd_cli_ls::cf_nw (const mtk::trd::msg::CF_NW_LS&   cf           )
{
    ptr->cf_nw(cf);
}
void mtk::trd::trd_cli_ls::cf_md (const mtk::trd::msg::CF_MD_LS&   cf           )
{
    ptr->cf_md(cf);
}
void mtk::trd::trd_cli_ls::cf_cc (const mtk::trd::msg::CF_CC_LS&   cf           )
{
    ptr->cf_cc(cf);
}
void mtk::trd::trd_cli_ls::rj_nw (const mtk::trd::msg::RJ_NW_LS&   rj           )
{
    ptr->rj_nw(rj);
}
void mtk::trd::trd_cli_ls::rj_md (const mtk::trd::msg::RJ_MD_LS&   rj           )
{
    ptr->rj_md(rj);
}
void mtk::trd::trd_cli_ls::rj_cc (const mtk::trd::msg::RJ_CC_LS&   rj           )
{
    ptr->rj_cc(rj);
}
void mtk::trd::trd_cli_ls::cf_ex (const mtk::trd::msg::CF_EX_LS&   ex           )
{
    ptr->cf_ex(ex);
}
void mtk::trd::trd_cli_ls::cf_st (const mtk::trd::msg::CF_ST_LS&   st           )
{
    ptr->cf_st(st);
}
const mtk::nullable<mtk::trd::msg::CF_XX_LS>           & mtk::trd::trd_cli_ls::last_confirmation (void) const
{
    return  ptr->last_confirmation();
}
const mtk::nullable<mtk::trd::msg::RQ_XX_LS>           & mtk::trd::trd_cli_ls::last_request (void) const
{
    return  ptr->last_request();
}
const mtk::CountPtr<mtk::trd::hist::order_historic_dangerous_not_signal_warped>   & mtk::trd::trd_cli_ls::history (void) const
{
    return  ptr->history();
}
const bool                                             & mtk::trd::trd_cli_ls::in_market (void) const
{
    return  ptr->in_market();
}
const bool                                             & mtk::trd::trd_cli_ls::is_canceled (void) const
{
    return  ptr->is_canceled();
}
const bool                                             & mtk::trd::trd_cli_ls::is_full_executed (void) const
{
    return  ptr->is_full_executed();
}
const bool                                             & mtk::trd::trd_cli_ls::has_pending_rq (void) const
{
    return  ptr->has_pending_rq();
}
const std::string                                      & mtk::trd::trd_cli_ls::serrors (void) const
{
    return  ptr->serrors();
}
