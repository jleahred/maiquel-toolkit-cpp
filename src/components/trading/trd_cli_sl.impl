//  code generated by fsm_gen
// generated automatically
// coded last modification:        $CODED_LAST_MODIF  desactivated, lots of false notifications
// pythonscript last modification: $SCRIPT_LAST_MODIF

#include "support/mtk_string.h"




namespace fsmgen_trd_cli_sl {


class abstract_status;


// -----------------------------------------------------------------------
//      c o v e r a g e
struct   scoverage
{
    scoverage(void) :

          init__rq_nw (0)
        , init__rq_md (0)
        , init__rq_cc (0)
        , init__cf_nw (0)
        , init__cf_md (0)
        , init__cf_cc (0)
        , init__rj_nw (0)
        , init__rj_md (0)
        , init__rj_cc (0)
        , init__cf_tr (0)
        , init__cf_st (0)
        , init__time_out (0)
        , w_cfnw__rq_nw (0)
        , w_cfnw__rq_md (0)
        , w_cfnw__rq_cc (0)
        , w_cfnw__cf_nw (0)
        , w_cfnw__cf_md (0)
        , w_cfnw__cf_cc (0)
        , w_cfnw__rj_nw (0)
        , w_cfnw__rj_md (0)
        , w_cfnw__rj_cc (0)
        , w_cfnw__cf_tr (0)
        , w_cfnw__cf_st (0)
        , w_cfnw__time_out (0)
        , market__rq_nw (0)
        , market__rq_md (0)
        , market__rq_cc (0)
        , market__cf_nw (0)
        , market__cf_md (0)
        , market__cf_cc (0)
        , market__rj_nw (0)
        , market__rj_md (0)
        , market__rj_cc (0)
        , market__cf_tr (0)
        , market__cf_st (0)
        , market__time_out (0)
        , w_cfmd__rq_nw (0)
        , w_cfmd__rq_md (0)
        , w_cfmd__rq_cc (0)
        , w_cfmd__cf_nw (0)
        , w_cfmd__cf_md (0)
        , w_cfmd__cf_cc (0)
        , w_cfmd__rj_nw (0)
        , w_cfmd__rj_md (0)
        , w_cfmd__rj_cc (0)
        , w_cfmd__cf_tr (0)
        , w_cfmd__cf_st (0)
        , w_cfmd__time_out (0)
        , w_cfcc__rq_nw (0)
        , w_cfcc__rq_md (0)
        , w_cfcc__rq_cc (0)
        , w_cfcc__cf_nw (0)
        , w_cfcc__cf_md (0)
        , w_cfcc__cf_cc (0)
        , w_cfcc__rj_nw (0)
        , w_cfcc__rj_md (0)
        , w_cfcc__rj_cc (0)
        , w_cfcc__cf_tr (0)
        , w_cfcc__cf_st (0)
        , w_cfcc__time_out (0)
        , w_cfmdcc__rq_nw (0)
        , w_cfmdcc__rq_md (0)
        , w_cfmdcc__rq_cc (0)
        , w_cfmdcc__cf_nw (0)
        , w_cfmdcc__cf_md (0)
        , w_cfmdcc__cf_cc (0)
        , w_cfmdcc__rj_nw (0)
        , w_cfmdcc__rj_md (0)
        , w_cfmdcc__rj_cc (0)
        , w_cfmdcc__cf_tr (0)
        , w_cfmdcc__cf_st (0)
        , w_cfmdcc__time_out (0)
        , w_cfnwmd__rq_nw (0)
        , w_cfnwmd__rq_md (0)
        , w_cfnwmd__rq_cc (0)
        , w_cfnwmd__cf_nw (0)
        , w_cfnwmd__cf_md (0)
        , w_cfnwmd__cf_cc (0)
        , w_cfnwmd__rj_nw (0)
        , w_cfnwmd__rj_md (0)
        , w_cfnwmd__rj_cc (0)
        , w_cfnwmd__cf_tr (0)
        , w_cfnwmd__cf_st (0)
        , w_cfnwmd__time_out (0)
        , w_cfnwcc__rq_nw (0)
        , w_cfnwcc__rq_md (0)
        , w_cfnwcc__rq_cc (0)
        , w_cfnwcc__cf_nw (0)
        , w_cfnwcc__cf_md (0)
        , w_cfnwcc__cf_cc (0)
        , w_cfnwcc__rj_nw (0)
        , w_cfnwcc__rj_md (0)
        , w_cfnwcc__rj_cc (0)
        , w_cfnwcc__cf_tr (0)
        , w_cfnwcc__cf_st (0)
        , w_cfnwcc__time_out (0)
        , canceled__rq_nw (0)
        , canceled__rq_md (0)
        , canceled__rq_cc (0)
        , canceled__cf_nw (0)
        , canceled__cf_md (0)
        , canceled__cf_cc (0)
        , canceled__rj_nw (0)
        , canceled__rj_md (0)
        , canceled__rj_cc (0)
        , canceled__cf_tr (0)
        , canceled__cf_st (0)
        , canceled__time_out (0)
        , triggered__rq_nw (0)
        , triggered__rq_md (0)
        , triggered__rq_cc (0)
        , triggered__cf_nw (0)
        , triggered__cf_md (0)
        , triggered__cf_cc (0)
        , triggered__rj_nw (0)
        , triggered__rj_md (0)
        , triggered__rj_cc (0)
        , triggered__cf_tr (0)
        , triggered__cf_st (0)
        , triggered__time_out (0)
        , error__rq_nw (0)
        , error__rq_md (0)
        , error__rq_cc (0)
        , error__cf_nw (0)
        , error__cf_md (0)
        , error__cf_cc (0)
        , error__rj_nw (0)
        , error__rj_md (0)
        , error__rj_cc (0)
        , error__cf_tr (0)
        , error__cf_st (0)
        , error__time_out (0)
    {}

    int   init__rq_nw;
    int   init__rq_md;
    int   init__rq_cc;
    int   init__cf_nw;
    int   init__cf_md;
    int   init__cf_cc;
    int   init__rj_nw;
    int   init__rj_md;
    int   init__rj_cc;
    int   init__cf_tr;
    int   init__cf_st;
    int   init__time_out;
    int   w_cfnw__rq_nw;
    int   w_cfnw__rq_md;
    int   w_cfnw__rq_cc;
    int   w_cfnw__cf_nw;
    int   w_cfnw__cf_md;
    int   w_cfnw__cf_cc;
    int   w_cfnw__rj_nw;
    int   w_cfnw__rj_md;
    int   w_cfnw__rj_cc;
    int   w_cfnw__cf_tr;
    int   w_cfnw__cf_st;
    int   w_cfnw__time_out;
    int   market__rq_nw;
    int   market__rq_md;
    int   market__rq_cc;
    int   market__cf_nw;
    int   market__cf_md;
    int   market__cf_cc;
    int   market__rj_nw;
    int   market__rj_md;
    int   market__rj_cc;
    int   market__cf_tr;
    int   market__cf_st;
    int   market__time_out;
    int   w_cfmd__rq_nw;
    int   w_cfmd__rq_md;
    int   w_cfmd__rq_cc;
    int   w_cfmd__cf_nw;
    int   w_cfmd__cf_md;
    int   w_cfmd__cf_cc;
    int   w_cfmd__rj_nw;
    int   w_cfmd__rj_md;
    int   w_cfmd__rj_cc;
    int   w_cfmd__cf_tr;
    int   w_cfmd__cf_st;
    int   w_cfmd__time_out;
    int   w_cfcc__rq_nw;
    int   w_cfcc__rq_md;
    int   w_cfcc__rq_cc;
    int   w_cfcc__cf_nw;
    int   w_cfcc__cf_md;
    int   w_cfcc__cf_cc;
    int   w_cfcc__rj_nw;
    int   w_cfcc__rj_md;
    int   w_cfcc__rj_cc;
    int   w_cfcc__cf_tr;
    int   w_cfcc__cf_st;
    int   w_cfcc__time_out;
    int   w_cfmdcc__rq_nw;
    int   w_cfmdcc__rq_md;
    int   w_cfmdcc__rq_cc;
    int   w_cfmdcc__cf_nw;
    int   w_cfmdcc__cf_md;
    int   w_cfmdcc__cf_cc;
    int   w_cfmdcc__rj_nw;
    int   w_cfmdcc__rj_md;
    int   w_cfmdcc__rj_cc;
    int   w_cfmdcc__cf_tr;
    int   w_cfmdcc__cf_st;
    int   w_cfmdcc__time_out;
    int   w_cfnwmd__rq_nw;
    int   w_cfnwmd__rq_md;
    int   w_cfnwmd__rq_cc;
    int   w_cfnwmd__cf_nw;
    int   w_cfnwmd__cf_md;
    int   w_cfnwmd__cf_cc;
    int   w_cfnwmd__rj_nw;
    int   w_cfnwmd__rj_md;
    int   w_cfnwmd__rj_cc;
    int   w_cfnwmd__cf_tr;
    int   w_cfnwmd__cf_st;
    int   w_cfnwmd__time_out;
    int   w_cfnwcc__rq_nw;
    int   w_cfnwcc__rq_md;
    int   w_cfnwcc__rq_cc;
    int   w_cfnwcc__cf_nw;
    int   w_cfnwcc__cf_md;
    int   w_cfnwcc__cf_cc;
    int   w_cfnwcc__rj_nw;
    int   w_cfnwcc__rj_md;
    int   w_cfnwcc__rj_cc;
    int   w_cfnwcc__cf_tr;
    int   w_cfnwcc__cf_st;
    int   w_cfnwcc__time_out;
    int   canceled__rq_nw;
    int   canceled__rq_md;
    int   canceled__rq_cc;
    int   canceled__cf_nw;
    int   canceled__cf_md;
    int   canceled__cf_cc;
    int   canceled__rj_nw;
    int   canceled__rj_md;
    int   canceled__rj_cc;
    int   canceled__cf_tr;
    int   canceled__cf_st;
    int   canceled__time_out;
    int   triggered__rq_nw;
    int   triggered__rq_md;
    int   triggered__rq_cc;
    int   triggered__cf_nw;
    int   triggered__cf_md;
    int   triggered__cf_cc;
    int   triggered__rj_nw;
    int   triggered__rj_md;
    int   triggered__rj_cc;
    int   triggered__cf_tr;
    int   triggered__cf_st;
    int   triggered__time_out;
    int   error__rq_nw;
    int   error__rq_md;
    int   error__rq_cc;
    int   error__cf_nw;
    int   error__cf_md;
    int   error__cf_cc;
    int   error__rj_nw;
    int   error__rj_md;
    int   error__rj_cc;
    int   error__cf_tr;
    int   error__cf_st;
    int   error__time_out;

    std::string  get_string(void)
    {

        static mtk::dtDateTime  last_result_date_time = mtk::dtNowLocal() - mtk::dtDays(1);
        static std::string last_result = "";
        int num_touched=0;
        if(last_result_date_time + mtk::dtSeconds(30) > mtk::dtNowLocal())
            last_result = "";
              if(init__rq_nw)   {++num_touched; last_result += MTK_SS("init__rq_nw:" << init__rq_nw << std::endl);}
              if(init__rq_md)   {++num_touched; last_result += MTK_SS("init__rq_md:" << init__rq_md << std::endl);}
              if(init__rq_cc)   {++num_touched; last_result += MTK_SS("init__rq_cc:" << init__rq_cc << std::endl);}
              if(init__cf_nw)   {++num_touched; last_result += MTK_SS("init__cf_nw:" << init__cf_nw << std::endl);}
              if(init__cf_md)   {++num_touched; last_result += MTK_SS("init__cf_md:" << init__cf_md << std::endl);}
              if(init__cf_cc)   {++num_touched; last_result += MTK_SS("init__cf_cc:" << init__cf_cc << std::endl);}
              if(init__rj_nw)   {++num_touched; last_result += MTK_SS("init__rj_nw:" << init__rj_nw << std::endl);}
              if(init__rj_md)   {++num_touched; last_result += MTK_SS("init__rj_md:" << init__rj_md << std::endl);}
              if(init__rj_cc)   {++num_touched; last_result += MTK_SS("init__rj_cc:" << init__rj_cc << std::endl);}
              if(init__cf_tr)   {++num_touched; last_result += MTK_SS("init__cf_tr:" << init__cf_tr << std::endl);}
              if(init__cf_st)   {++num_touched; last_result += MTK_SS("init__cf_st:" << init__cf_st << std::endl);}
              if(init__time_out)   {++num_touched; last_result += MTK_SS("init__time_out:" << init__time_out << std::endl);}
              if(w_cfnw__rq_nw)   {++num_touched; last_result += MTK_SS("w_cfnw__rq_nw:" << w_cfnw__rq_nw << std::endl);}
              if(w_cfnw__rq_md)   {++num_touched; last_result += MTK_SS("w_cfnw__rq_md:" << w_cfnw__rq_md << std::endl);}
              if(w_cfnw__rq_cc)   {++num_touched; last_result += MTK_SS("w_cfnw__rq_cc:" << w_cfnw__rq_cc << std::endl);}
              if(w_cfnw__cf_nw)   {++num_touched; last_result += MTK_SS("w_cfnw__cf_nw:" << w_cfnw__cf_nw << std::endl);}
              if(w_cfnw__cf_md)   {++num_touched; last_result += MTK_SS("w_cfnw__cf_md:" << w_cfnw__cf_md << std::endl);}
              if(w_cfnw__cf_cc)   {++num_touched; last_result += MTK_SS("w_cfnw__cf_cc:" << w_cfnw__cf_cc << std::endl);}
              if(w_cfnw__rj_nw)   {++num_touched; last_result += MTK_SS("w_cfnw__rj_nw:" << w_cfnw__rj_nw << std::endl);}
              if(w_cfnw__rj_md)   {++num_touched; last_result += MTK_SS("w_cfnw__rj_md:" << w_cfnw__rj_md << std::endl);}
              if(w_cfnw__rj_cc)   {++num_touched; last_result += MTK_SS("w_cfnw__rj_cc:" << w_cfnw__rj_cc << std::endl);}
              if(w_cfnw__cf_tr)   {++num_touched; last_result += MTK_SS("w_cfnw__cf_tr:" << w_cfnw__cf_tr << std::endl);}
              if(w_cfnw__cf_st)   {++num_touched; last_result += MTK_SS("w_cfnw__cf_st:" << w_cfnw__cf_st << std::endl);}
              if(w_cfnw__time_out)   {++num_touched; last_result += MTK_SS("w_cfnw__time_out:" << w_cfnw__time_out << std::endl);}
              if(market__rq_nw)   {++num_touched; last_result += MTK_SS("market__rq_nw:" << market__rq_nw << std::endl);}
              if(market__rq_md)   {++num_touched; last_result += MTK_SS("market__rq_md:" << market__rq_md << std::endl);}
              if(market__rq_cc)   {++num_touched; last_result += MTK_SS("market__rq_cc:" << market__rq_cc << std::endl);}
              if(market__cf_nw)   {++num_touched; last_result += MTK_SS("market__cf_nw:" << market__cf_nw << std::endl);}
              if(market__cf_md)   {++num_touched; last_result += MTK_SS("market__cf_md:" << market__cf_md << std::endl);}
              if(market__cf_cc)   {++num_touched; last_result += MTK_SS("market__cf_cc:" << market__cf_cc << std::endl);}
              if(market__rj_nw)   {++num_touched; last_result += MTK_SS("market__rj_nw:" << market__rj_nw << std::endl);}
              if(market__rj_md)   {++num_touched; last_result += MTK_SS("market__rj_md:" << market__rj_md << std::endl);}
              if(market__rj_cc)   {++num_touched; last_result += MTK_SS("market__rj_cc:" << market__rj_cc << std::endl);}
              if(market__cf_tr)   {++num_touched; last_result += MTK_SS("market__cf_tr:" << market__cf_tr << std::endl);}
              if(market__cf_st)   {++num_touched; last_result += MTK_SS("market__cf_st:" << market__cf_st << std::endl);}
              if(market__time_out)   {++num_touched; last_result += MTK_SS("market__time_out:" << market__time_out << std::endl);}
              if(w_cfmd__rq_nw)   {++num_touched; last_result += MTK_SS("w_cfmd__rq_nw:" << w_cfmd__rq_nw << std::endl);}
              if(w_cfmd__rq_md)   {++num_touched; last_result += MTK_SS("w_cfmd__rq_md:" << w_cfmd__rq_md << std::endl);}
              if(w_cfmd__rq_cc)   {++num_touched; last_result += MTK_SS("w_cfmd__rq_cc:" << w_cfmd__rq_cc << std::endl);}
              if(w_cfmd__cf_nw)   {++num_touched; last_result += MTK_SS("w_cfmd__cf_nw:" << w_cfmd__cf_nw << std::endl);}
              if(w_cfmd__cf_md)   {++num_touched; last_result += MTK_SS("w_cfmd__cf_md:" << w_cfmd__cf_md << std::endl);}
              if(w_cfmd__cf_cc)   {++num_touched; last_result += MTK_SS("w_cfmd__cf_cc:" << w_cfmd__cf_cc << std::endl);}
              if(w_cfmd__rj_nw)   {++num_touched; last_result += MTK_SS("w_cfmd__rj_nw:" << w_cfmd__rj_nw << std::endl);}
              if(w_cfmd__rj_md)   {++num_touched; last_result += MTK_SS("w_cfmd__rj_md:" << w_cfmd__rj_md << std::endl);}
              if(w_cfmd__rj_cc)   {++num_touched; last_result += MTK_SS("w_cfmd__rj_cc:" << w_cfmd__rj_cc << std::endl);}
              if(w_cfmd__cf_tr)   {++num_touched; last_result += MTK_SS("w_cfmd__cf_tr:" << w_cfmd__cf_tr << std::endl);}
              if(w_cfmd__cf_st)   {++num_touched; last_result += MTK_SS("w_cfmd__cf_st:" << w_cfmd__cf_st << std::endl);}
              if(w_cfmd__time_out)   {++num_touched; last_result += MTK_SS("w_cfmd__time_out:" << w_cfmd__time_out << std::endl);}
              if(w_cfcc__rq_nw)   {++num_touched; last_result += MTK_SS("w_cfcc__rq_nw:" << w_cfcc__rq_nw << std::endl);}
              if(w_cfcc__rq_md)   {++num_touched; last_result += MTK_SS("w_cfcc__rq_md:" << w_cfcc__rq_md << std::endl);}
              if(w_cfcc__rq_cc)   {++num_touched; last_result += MTK_SS("w_cfcc__rq_cc:" << w_cfcc__rq_cc << std::endl);}
              if(w_cfcc__cf_nw)   {++num_touched; last_result += MTK_SS("w_cfcc__cf_nw:" << w_cfcc__cf_nw << std::endl);}
              if(w_cfcc__cf_md)   {++num_touched; last_result += MTK_SS("w_cfcc__cf_md:" << w_cfcc__cf_md << std::endl);}
              if(w_cfcc__cf_cc)   {++num_touched; last_result += MTK_SS("w_cfcc__cf_cc:" << w_cfcc__cf_cc << std::endl);}
              if(w_cfcc__rj_nw)   {++num_touched; last_result += MTK_SS("w_cfcc__rj_nw:" << w_cfcc__rj_nw << std::endl);}
              if(w_cfcc__rj_md)   {++num_touched; last_result += MTK_SS("w_cfcc__rj_md:" << w_cfcc__rj_md << std::endl);}
              if(w_cfcc__rj_cc)   {++num_touched; last_result += MTK_SS("w_cfcc__rj_cc:" << w_cfcc__rj_cc << std::endl);}
              if(w_cfcc__cf_tr)   {++num_touched; last_result += MTK_SS("w_cfcc__cf_tr:" << w_cfcc__cf_tr << std::endl);}
              if(w_cfcc__cf_st)   {++num_touched; last_result += MTK_SS("w_cfcc__cf_st:" << w_cfcc__cf_st << std::endl);}
              if(w_cfcc__time_out)   {++num_touched; last_result += MTK_SS("w_cfcc__time_out:" << w_cfcc__time_out << std::endl);}
              if(w_cfmdcc__rq_nw)   {++num_touched; last_result += MTK_SS("w_cfmdcc__rq_nw:" << w_cfmdcc__rq_nw << std::endl);}
              if(w_cfmdcc__rq_md)   {++num_touched; last_result += MTK_SS("w_cfmdcc__rq_md:" << w_cfmdcc__rq_md << std::endl);}
              if(w_cfmdcc__rq_cc)   {++num_touched; last_result += MTK_SS("w_cfmdcc__rq_cc:" << w_cfmdcc__rq_cc << std::endl);}
              if(w_cfmdcc__cf_nw)   {++num_touched; last_result += MTK_SS("w_cfmdcc__cf_nw:" << w_cfmdcc__cf_nw << std::endl);}
              if(w_cfmdcc__cf_md)   {++num_touched; last_result += MTK_SS("w_cfmdcc__cf_md:" << w_cfmdcc__cf_md << std::endl);}
              if(w_cfmdcc__cf_cc)   {++num_touched; last_result += MTK_SS("w_cfmdcc__cf_cc:" << w_cfmdcc__cf_cc << std::endl);}
              if(w_cfmdcc__rj_nw)   {++num_touched; last_result += MTK_SS("w_cfmdcc__rj_nw:" << w_cfmdcc__rj_nw << std::endl);}
              if(w_cfmdcc__rj_md)   {++num_touched; last_result += MTK_SS("w_cfmdcc__rj_md:" << w_cfmdcc__rj_md << std::endl);}
              if(w_cfmdcc__rj_cc)   {++num_touched; last_result += MTK_SS("w_cfmdcc__rj_cc:" << w_cfmdcc__rj_cc << std::endl);}
              if(w_cfmdcc__cf_tr)   {++num_touched; last_result += MTK_SS("w_cfmdcc__cf_tr:" << w_cfmdcc__cf_tr << std::endl);}
              if(w_cfmdcc__cf_st)   {++num_touched; last_result += MTK_SS("w_cfmdcc__cf_st:" << w_cfmdcc__cf_st << std::endl);}
              if(w_cfmdcc__time_out)   {++num_touched; last_result += MTK_SS("w_cfmdcc__time_out:" << w_cfmdcc__time_out << std::endl);}
              if(w_cfnwmd__rq_nw)   {++num_touched; last_result += MTK_SS("w_cfnwmd__rq_nw:" << w_cfnwmd__rq_nw << std::endl);}
              if(w_cfnwmd__rq_md)   {++num_touched; last_result += MTK_SS("w_cfnwmd__rq_md:" << w_cfnwmd__rq_md << std::endl);}
              if(w_cfnwmd__rq_cc)   {++num_touched; last_result += MTK_SS("w_cfnwmd__rq_cc:" << w_cfnwmd__rq_cc << std::endl);}
              if(w_cfnwmd__cf_nw)   {++num_touched; last_result += MTK_SS("w_cfnwmd__cf_nw:" << w_cfnwmd__cf_nw << std::endl);}
              if(w_cfnwmd__cf_md)   {++num_touched; last_result += MTK_SS("w_cfnwmd__cf_md:" << w_cfnwmd__cf_md << std::endl);}
              if(w_cfnwmd__cf_cc)   {++num_touched; last_result += MTK_SS("w_cfnwmd__cf_cc:" << w_cfnwmd__cf_cc << std::endl);}
              if(w_cfnwmd__rj_nw)   {++num_touched; last_result += MTK_SS("w_cfnwmd__rj_nw:" << w_cfnwmd__rj_nw << std::endl);}
              if(w_cfnwmd__rj_md)   {++num_touched; last_result += MTK_SS("w_cfnwmd__rj_md:" << w_cfnwmd__rj_md << std::endl);}
              if(w_cfnwmd__rj_cc)   {++num_touched; last_result += MTK_SS("w_cfnwmd__rj_cc:" << w_cfnwmd__rj_cc << std::endl);}
              if(w_cfnwmd__cf_tr)   {++num_touched; last_result += MTK_SS("w_cfnwmd__cf_tr:" << w_cfnwmd__cf_tr << std::endl);}
              if(w_cfnwmd__cf_st)   {++num_touched; last_result += MTK_SS("w_cfnwmd__cf_st:" << w_cfnwmd__cf_st << std::endl);}
              if(w_cfnwmd__time_out)   {++num_touched; last_result += MTK_SS("w_cfnwmd__time_out:" << w_cfnwmd__time_out << std::endl);}
              if(w_cfnwcc__rq_nw)   {++num_touched; last_result += MTK_SS("w_cfnwcc__rq_nw:" << w_cfnwcc__rq_nw << std::endl);}
              if(w_cfnwcc__rq_md)   {++num_touched; last_result += MTK_SS("w_cfnwcc__rq_md:" << w_cfnwcc__rq_md << std::endl);}
              if(w_cfnwcc__rq_cc)   {++num_touched; last_result += MTK_SS("w_cfnwcc__rq_cc:" << w_cfnwcc__rq_cc << std::endl);}
              if(w_cfnwcc__cf_nw)   {++num_touched; last_result += MTK_SS("w_cfnwcc__cf_nw:" << w_cfnwcc__cf_nw << std::endl);}
              if(w_cfnwcc__cf_md)   {++num_touched; last_result += MTK_SS("w_cfnwcc__cf_md:" << w_cfnwcc__cf_md << std::endl);}
              if(w_cfnwcc__cf_cc)   {++num_touched; last_result += MTK_SS("w_cfnwcc__cf_cc:" << w_cfnwcc__cf_cc << std::endl);}
              if(w_cfnwcc__rj_nw)   {++num_touched; last_result += MTK_SS("w_cfnwcc__rj_nw:" << w_cfnwcc__rj_nw << std::endl);}
              if(w_cfnwcc__rj_md)   {++num_touched; last_result += MTK_SS("w_cfnwcc__rj_md:" << w_cfnwcc__rj_md << std::endl);}
              if(w_cfnwcc__rj_cc)   {++num_touched; last_result += MTK_SS("w_cfnwcc__rj_cc:" << w_cfnwcc__rj_cc << std::endl);}
              if(w_cfnwcc__cf_tr)   {++num_touched; last_result += MTK_SS("w_cfnwcc__cf_tr:" << w_cfnwcc__cf_tr << std::endl);}
              if(w_cfnwcc__cf_st)   {++num_touched; last_result += MTK_SS("w_cfnwcc__cf_st:" << w_cfnwcc__cf_st << std::endl);}
              if(w_cfnwcc__time_out)   {++num_touched; last_result += MTK_SS("w_cfnwcc__time_out:" << w_cfnwcc__time_out << std::endl);}
              if(canceled__rq_nw)   {++num_touched; last_result += MTK_SS("canceled__rq_nw:" << canceled__rq_nw << std::endl);}
              if(canceled__rq_md)   {++num_touched; last_result += MTK_SS("canceled__rq_md:" << canceled__rq_md << std::endl);}
              if(canceled__rq_cc)   {++num_touched; last_result += MTK_SS("canceled__rq_cc:" << canceled__rq_cc << std::endl);}
              if(canceled__cf_nw)   {++num_touched; last_result += MTK_SS("canceled__cf_nw:" << canceled__cf_nw << std::endl);}
              if(canceled__cf_md)   {++num_touched; last_result += MTK_SS("canceled__cf_md:" << canceled__cf_md << std::endl);}
              if(canceled__cf_cc)   {++num_touched; last_result += MTK_SS("canceled__cf_cc:" << canceled__cf_cc << std::endl);}
              if(canceled__rj_nw)   {++num_touched; last_result += MTK_SS("canceled__rj_nw:" << canceled__rj_nw << std::endl);}
              if(canceled__rj_md)   {++num_touched; last_result += MTK_SS("canceled__rj_md:" << canceled__rj_md << std::endl);}
              if(canceled__rj_cc)   {++num_touched; last_result += MTK_SS("canceled__rj_cc:" << canceled__rj_cc << std::endl);}
              if(canceled__cf_tr)   {++num_touched; last_result += MTK_SS("canceled__cf_tr:" << canceled__cf_tr << std::endl);}
              if(canceled__cf_st)   {++num_touched; last_result += MTK_SS("canceled__cf_st:" << canceled__cf_st << std::endl);}
              if(canceled__time_out)   {++num_touched; last_result += MTK_SS("canceled__time_out:" << canceled__time_out << std::endl);}
              if(triggered__rq_nw)   {++num_touched; last_result += MTK_SS("triggered__rq_nw:" << triggered__rq_nw << std::endl);}
              if(triggered__rq_md)   {++num_touched; last_result += MTK_SS("triggered__rq_md:" << triggered__rq_md << std::endl);}
              if(triggered__rq_cc)   {++num_touched; last_result += MTK_SS("triggered__rq_cc:" << triggered__rq_cc << std::endl);}
              if(triggered__cf_nw)   {++num_touched; last_result += MTK_SS("triggered__cf_nw:" << triggered__cf_nw << std::endl);}
              if(triggered__cf_md)   {++num_touched; last_result += MTK_SS("triggered__cf_md:" << triggered__cf_md << std::endl);}
              if(triggered__cf_cc)   {++num_touched; last_result += MTK_SS("triggered__cf_cc:" << triggered__cf_cc << std::endl);}
              if(triggered__rj_nw)   {++num_touched; last_result += MTK_SS("triggered__rj_nw:" << triggered__rj_nw << std::endl);}
              if(triggered__rj_md)   {++num_touched; last_result += MTK_SS("triggered__rj_md:" << triggered__rj_md << std::endl);}
              if(triggered__rj_cc)   {++num_touched; last_result += MTK_SS("triggered__rj_cc:" << triggered__rj_cc << std::endl);}
              if(triggered__cf_tr)   {++num_touched; last_result += MTK_SS("triggered__cf_tr:" << triggered__cf_tr << std::endl);}
              if(triggered__cf_st)   {++num_touched; last_result += MTK_SS("triggered__cf_st:" << triggered__cf_st << std::endl);}
              if(triggered__time_out)   {++num_touched; last_result += MTK_SS("triggered__time_out:" << triggered__time_out << std::endl);}
              if(error__rq_nw)   {++num_touched; last_result += MTK_SS("error__rq_nw:" << error__rq_nw << std::endl);}
              if(error__rq_md)   {++num_touched; last_result += MTK_SS("error__rq_md:" << error__rq_md << std::endl);}
              if(error__rq_cc)   {++num_touched; last_result += MTK_SS("error__rq_cc:" << error__rq_cc << std::endl);}
              if(error__cf_nw)   {++num_touched; last_result += MTK_SS("error__cf_nw:" << error__cf_nw << std::endl);}
              if(error__cf_md)   {++num_touched; last_result += MTK_SS("error__cf_md:" << error__cf_md << std::endl);}
              if(error__cf_cc)   {++num_touched; last_result += MTK_SS("error__cf_cc:" << error__cf_cc << std::endl);}
              if(error__rj_nw)   {++num_touched; last_result += MTK_SS("error__rj_nw:" << error__rj_nw << std::endl);}
              if(error__rj_md)   {++num_touched; last_result += MTK_SS("error__rj_md:" << error__rj_md << std::endl);}
              if(error__rj_cc)   {++num_touched; last_result += MTK_SS("error__rj_cc:" << error__rj_cc << std::endl);}
              if(error__cf_tr)   {++num_touched; last_result += MTK_SS("error__cf_tr:" << error__cf_tr << std::endl);}
              if(error__cf_st)   {++num_touched; last_result += MTK_SS("error__cf_st:" << error__cf_st << std::endl);}
              if(error__time_out)   {++num_touched; last_result += MTK_SS("error__time_out:" << error__time_out << std::endl);}

        last_result += MTK_SS("__num_touched__:"  <<  num_touched);
        return last_result;

    }
};


// -----------------------------------------------------------------------
//      s t a t u s _ c o m m o n _ i n f o

struct  status_common_info
{
    status_common_info ( mtk::Signal<const mtk::trd::msg::RQ_NW_SL&   /*rq*/         >& _sig_rq_nw, mtk::Signal<const mtk::trd::msg::RQ_MD_SL&   /*rq*/         >& _sig_rq_md, mtk::Signal<const mtk::trd::msg::RQ_CC_SL&   /*rq*/         >& _sig_rq_cc, mtk::Signal<const mtk::trd::msg::RJ_NW_SL&   /*rj*/         >& _sig_rj_nw, mtk::Signal<const mtk::trd::msg::RJ_MD_SL&   /*rj*/         >& _sig_rj_md, mtk::Signal<const mtk::trd::msg::RJ_CC_SL&   /*rj*/         >& _sig_rj_cc, mtk::Signal<const mtk::trd::msg::CF_NW_SL&   /*cf*/         >& _sig_cf_nw, mtk::Signal<const mtk::trd::msg::CF_MD_SL&   /*cf*/         >& _sig_cf_md, mtk::Signal<const mtk::trd::msg::CF_CC_SL&   /*cf*/         >& _sig_cf_cc, mtk::Signal<const mtk::trd::msg::CF_TR_SL&   /*trg*/        >& _sig_cf_tr, mtk::Signal<const mtk::trd::msg::CF_ST_SL&   /*st*/         >& _sig_cf_st, mtk::Signal<>& _sig_changed)
        :  
        __last_confirmation(mtk::nullable<mtk::trd::msg::CF_XX_SL>() ),
        __last_request(mtk::nullable<mtk::trd::msg::RQ_XX_SL>() ),
        __history(mtk::make_cptr(new mtk::trd::hist::order_historic_dangerous_not_signal_warped)       ),
        __serrors(""), 
        sig_rq_nw (_sig_rq_nw), 
        sig_rq_md (_sig_rq_md), 
        sig_rq_cc (_sig_rq_cc), 
        sig_rj_nw (_sig_rj_nw), 
        sig_rj_md (_sig_rj_md), 
        sig_rj_cc (_sig_rj_cc), 
        sig_cf_nw (_sig_cf_nw), 
        sig_cf_md (_sig_cf_md), 
        sig_cf_cc (_sig_cf_cc), 
        sig_cf_tr (_sig_cf_tr), 
        sig_cf_st (_sig_cf_st), 
        sig_changed (_sig_changed)
        {};
    virtual ~status_common_info(){};

    // PROPERTIES AND SIGNALS
    mtk::nullable<mtk::trd::msg::CF_XX_SL>           __last_confirmation;
    virtual const mtk::nullable<mtk::trd::msg::CF_XX_SL>          &  last_confirmation() const {  return __last_confirmation; };
    virtual void set_last_confirmation(const mtk::nullable<mtk::trd::msg::CF_XX_SL>          &  _prop) {  __last_confirmation = _prop;  };
    mtk::nullable<mtk::trd::msg::RQ_XX_SL>           __last_request;
    virtual const mtk::nullable<mtk::trd::msg::RQ_XX_SL>          &  last_request() const {  return __last_request; };
    virtual void set_last_request(const mtk::nullable<mtk::trd::msg::RQ_XX_SL>          &  _prop) {  __last_request = _prop;  };
    mtk::CountPtr<mtk::trd::hist::order_historic_dangerous_not_signal_warped      >   __history;
    virtual const mtk::CountPtr<mtk::trd::hist::order_historic_dangerous_not_signal_warped      >  &  history() const {  return __history; };
    virtual void set_history(const mtk::CountPtr<mtk::trd::hist::order_historic_dangerous_not_signal_warped      >  &  _prop) {  __history = _prop;  };
    virtual const bool                                             &  in_market_no_pend() const {  static bool                                             result(false);   return result; };
    virtual void set_in_market_no_pend(const bool                                            & ) {  throw mtk::Alarm(MTK_HERE, "fsm_gen.set_property", "property not valid in current status", mtk::alPriorError);  };
    virtual const bool                                             &  is_canceled() const {  static bool                                             result(false);   return result; };
    virtual void set_is_canceled(const bool                                            & ) {  throw mtk::Alarm(MTK_HERE, "fsm_gen.set_property", "property not valid in current status", mtk::alPriorError);  };
    virtual const bool                                             &  is_triggered() const {  static bool                                             result(false);   return result; };
    virtual void set_is_triggered(const bool                                            & ) {  throw mtk::Alarm(MTK_HERE, "fsm_gen.set_property", "property not valid in current status", mtk::alPriorError);  };
    virtual const bool                                             &  is_alive() const {  static bool                                             result(true );   return result; };
    virtual void set_is_alive(const bool                                            & ) {  throw mtk::Alarm(MTK_HERE, "fsm_gen.set_property", "property not valid in current status", mtk::alPriorError);  };
    virtual const bool                                             &  has_pending_rq() const {  static bool                                             result(false);   return result; };
    virtual void set_has_pending_rq(const bool                                            & ) {  throw mtk::Alarm(MTK_HERE, "fsm_gen.set_property", "property not valid in current status", mtk::alPriorError);  };
    std::string                                      __serrors;
    virtual const std::string                                     &  serrors() const {  return __serrors; };
    virtual void set_serrors(const std::string                                     &  _prop) {  __serrors = _prop;  };
    mtk::Signal<const mtk::trd::msg::RQ_NW_SL&   /*rq*/         >& sig_rq_nw;
    mtk::Signal<const mtk::trd::msg::RQ_MD_SL&   /*rq*/         >& sig_rq_md;
    mtk::Signal<const mtk::trd::msg::RQ_CC_SL&   /*rq*/         >& sig_rq_cc;
    mtk::Signal<const mtk::trd::msg::RJ_NW_SL&   /*rj*/         >& sig_rj_nw;
    mtk::Signal<const mtk::trd::msg::RJ_MD_SL&   /*rj*/         >& sig_rj_md;
    mtk::Signal<const mtk::trd::msg::RJ_CC_SL&   /*rj*/         >& sig_rj_cc;
    mtk::Signal<const mtk::trd::msg::CF_NW_SL&   /*cf*/         >& sig_cf_nw;
    mtk::Signal<const mtk::trd::msg::CF_MD_SL&   /*cf*/         >& sig_cf_md;
    mtk::Signal<const mtk::trd::msg::CF_CC_SL&   /*cf*/         >& sig_cf_cc;
    mtk::Signal<const mtk::trd::msg::CF_TR_SL&   /*trg*/        >& sig_cf_tr;
    mtk::Signal<const mtk::trd::msg::CF_ST_SL&   /*st*/         >& sig_cf_st;
    mtk::Signal<>& sig_changed;


    mtk::Signal<mtk::CountPtr<abstract_status> > signal_new_status;
    mtk::Signal<> signal_keep_temp_status;
    mtk::Signal<> signal_remove_temp_status;


    //  STATS AND COVERAGE
    static  scoverage     coverage;
};

scoverage status_common_info::coverage;





// -----------------------------------------------------------------------
//      abstract_status
class abstract_status  : public mtk::SignalReceptor
{
    mtk::non_copyable  nc;

public:
    abstract_status (mtk::CountPtr<status_common_info> _ci)
        : ci (_ci) {};
    virtual ~abstract_status() {};
    
    mtk::CountPtr<status_common_info> ci;
    
    virtual std::string  GetStatusName() = 0;

    //  INPUTS
    virtual void rq_nw ( const mtk::trd::msg::RQ_NW_SL&   rq           )=0;
    virtual void rq_md ( const mtk::trd::msg::RQ_MD_SL&   rq           )=0;
    virtual void rq_cc ( const mtk::trd::msg::RQ_CC_SL&   rq           )=0;
    virtual void cf_nw ( const mtk::trd::msg::CF_NW_SL&   cf           )=0;
    virtual void cf_md ( const mtk::trd::msg::CF_MD_SL&   cf           )=0;
    virtual void cf_cc ( const mtk::trd::msg::CF_CC_SL&   cf           )=0;
    virtual void rj_nw ( const mtk::trd::msg::RJ_NW_SL&   rj           )=0;
    virtual void rj_md ( const mtk::trd::msg::RJ_MD_SL&   rj           )=0;
    virtual void rj_cc ( const mtk::trd::msg::RJ_CC_SL&   rj           )=0;
    virtual void cf_tr ( const mtk::trd::msg::CF_TR_SL&   tr           )=0;
    virtual void cf_st ( const mtk::trd::msg::CF_ST_SL&   st           )=0;
    virtual void time_out ( const int&          _            )=0;


    //  ACCESS
    virtual const mtk::nullable<mtk::trd::msg::CF_XX_SL>           &  last_confirmation (void) const { return ci->last_confirmation(); }; 
    virtual const mtk::nullable<mtk::trd::msg::RQ_XX_SL>           &  last_request (void) const { return ci->last_request(); }; 
    virtual const mtk::CountPtr<mtk::trd::hist::order_historic_dangerous_not_signal_warped      >   &  history (void) const { return ci->history(); }; 
    virtual const bool                                             &  in_market_no_pend (void) const { return ci->in_market_no_pend(); }; 
    virtual const bool                                             &  is_canceled (void) const { return ci->is_canceled(); }; 
    virtual const bool                                             &  is_triggered (void) const { return ci->is_triggered(); }; 
    virtual const bool                                             &  is_alive (void) const { return ci->is_alive(); }; 
    virtual const bool                                             &  has_pending_rq (void) const { return ci->has_pending_rq(); }; 
    virtual const std::string                                      &  serrors (void) const { return ci->serrors(); }; 


    //  COVERAGE
    std::string  get_coverage_string(void)  { return ci->coverage.get_string(); };
};





// -----------------------------------------------------------------------
//      init
class init  :   public  abstract_status
{
    mtk::non_copyable  nc;

public:
    init (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci),
        __is_alive(false)
        {  };
    
    std::string  GetStatusName()  {  return "init"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    bool                                         __is_alive;
    virtual const bool                                        &  is_alive() const {  return __is_alive; };
    virtual void set_is_alive(const bool                                        &  _prop) {  __is_alive = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_SL&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_SL&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_SL&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_SL&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_SL&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_SL&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_SL&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_SL&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_SL&   rj           );
    void cf_tr (const mtk::trd::msg::CF_TR_SL&   tr           );
    void cf_st (const mtk::trd::msg::CF_ST_SL&   st           );
    void time_out (const int&          _            );


};



// -----------------------------------------------------------------------
//      w_cfnw
class w_cfnw  :   public  abstract_status
{
    mtk::non_copyable  nc;

public:
    w_cfnw (mtk::CountPtr<status_common_info> _ci,  const mtk::dtTimeQuantity                         & _check_time_out)
        : 
        abstract_status(_ci),
        __check_time_out(_check_time_out),
        __has_pending_rq(true)
        { 
            try
            {
                  if(check_time_out() > mtk::dtSeconds(0))        MTK_CALL_LATER1S_THIS(mtk::dtSeconds(2), 0, time_out);   
            }
            MTK_CATCH_RETHROW("w_cfnw_ctor", "rethrowed") };
    
    std::string  GetStatusName()  {  return "w_cfnw"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    mtk::dtTimeQuantity                          __check_time_out;
    virtual const mtk::dtTimeQuantity                         &  check_time_out() const {  return __check_time_out; };
    virtual void set_check_time_out(const mtk::dtTimeQuantity                         &  _prop) {  __check_time_out = _prop;  };
    bool                                         __has_pending_rq;
    virtual const bool                                        &  has_pending_rq() const {  return __has_pending_rq; };
    virtual void set_has_pending_rq(const bool                                        &  _prop) {  __has_pending_rq = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_SL&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_SL&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_SL&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_SL&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_SL&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_SL&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_SL&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_SL&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_SL&   rj           );
    void cf_tr (const mtk::trd::msg::CF_TR_SL&   tr           );
    void cf_st (const mtk::trd::msg::CF_ST_SL&   st           );
    void time_out (const int&          _            );


};



// -----------------------------------------------------------------------
//      market
class market  :   public  abstract_status
{
    mtk::non_copyable  nc;

public:
    market (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci),
        __in_market_no_pend(true)
        {  };
    
    std::string  GetStatusName()  {  return "market"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    bool                                         __in_market_no_pend;
    virtual const bool                                        &  in_market_no_pend() const {  return __in_market_no_pend; };
    virtual void set_in_market_no_pend(const bool                                        &  _prop) {  __in_market_no_pend = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_SL&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_SL&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_SL&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_SL&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_SL&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_SL&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_SL&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_SL&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_SL&   rj           );
    void cf_tr (const mtk::trd::msg::CF_TR_SL&   tr           );
    void cf_st (const mtk::trd::msg::CF_ST_SL&   st           );
    void time_out (const int&          _            );


};



// -----------------------------------------------------------------------
//      w_cfmd
class w_cfmd  :   public  abstract_status
{
    mtk::non_copyable  nc;

public:
    w_cfmd (mtk::CountPtr<status_common_info> _ci,  const mtk::dtTimeQuantity                         & _check_time_out)
        : 
        abstract_status(_ci),
        __check_time_out(_check_time_out),
        __has_pending_rq(true)
        { 
            try
            {
                  if(check_time_out() > mtk::dtSeconds(0))        MTK_CALL_LATER1S_THIS(mtk::dtSeconds(2), 0, time_out);   
            }
            MTK_CATCH_RETHROW("w_cfmd_ctor", "rethrowed") };
    
    std::string  GetStatusName()  {  return "w_cfmd"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    mtk::dtTimeQuantity                          __check_time_out;
    virtual const mtk::dtTimeQuantity                         &  check_time_out() const {  return __check_time_out; };
    virtual void set_check_time_out(const mtk::dtTimeQuantity                         &  _prop) {  __check_time_out = _prop;  };
    bool                                         __has_pending_rq;
    virtual const bool                                        &  has_pending_rq() const {  return __has_pending_rq; };
    virtual void set_has_pending_rq(const bool                                        &  _prop) {  __has_pending_rq = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_SL&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_SL&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_SL&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_SL&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_SL&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_SL&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_SL&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_SL&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_SL&   rj           );
    void cf_tr (const mtk::trd::msg::CF_TR_SL&   tr           );
    void cf_st (const mtk::trd::msg::CF_ST_SL&   st           );
    void time_out (const int&          _            );


};



// -----------------------------------------------------------------------
//      w_cfcc
class w_cfcc  :   public  abstract_status
{
    mtk::non_copyable  nc;

public:
    w_cfcc (mtk::CountPtr<status_common_info> _ci,  const mtk::dtTimeQuantity                         & _check_time_out)
        : 
        abstract_status(_ci),
        __check_time_out(_check_time_out),
        __has_pending_rq(true)
        { 
            try
            {
                  if(check_time_out() > mtk::dtSeconds(0))        MTK_CALL_LATER1S_THIS(mtk::dtSeconds(2), 0, time_out);   
            }
            MTK_CATCH_RETHROW("w_cfcc_ctor", "rethrowed") };
    
    std::string  GetStatusName()  {  return "w_cfcc"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    mtk::dtTimeQuantity                          __check_time_out;
    virtual const mtk::dtTimeQuantity                         &  check_time_out() const {  return __check_time_out; };
    virtual void set_check_time_out(const mtk::dtTimeQuantity                         &  _prop) {  __check_time_out = _prop;  };
    bool                                         __has_pending_rq;
    virtual const bool                                        &  has_pending_rq() const {  return __has_pending_rq; };
    virtual void set_has_pending_rq(const bool                                        &  _prop) {  __has_pending_rq = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_SL&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_SL&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_SL&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_SL&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_SL&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_SL&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_SL&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_SL&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_SL&   rj           );
    void cf_tr (const mtk::trd::msg::CF_TR_SL&   tr           );
    void cf_st (const mtk::trd::msg::CF_ST_SL&   st           );
    void time_out (const int&          _            );


};



// -----------------------------------------------------------------------
//      w_cfmdcc
class w_cfmdcc  :   public  abstract_status
{
    mtk::non_copyable  nc;

public:
    w_cfmdcc (mtk::CountPtr<status_common_info> _ci,  const mtk::dtTimeQuantity                         & _check_time_out)
        : 
        abstract_status(_ci),
        __check_time_out(_check_time_out),
        __has_pending_rq(true)
        { 
            try
            {
                  if(check_time_out() > mtk::dtSeconds(0))        MTK_CALL_LATER1S_THIS(mtk::dtSeconds(2), 0, time_out);   
            }
            MTK_CATCH_RETHROW("w_cfmdcc_ctor", "rethrowed") };
    
    std::string  GetStatusName()  {  return "w_cfmdcc"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    mtk::dtTimeQuantity                          __check_time_out;
    virtual const mtk::dtTimeQuantity                         &  check_time_out() const {  return __check_time_out; };
    virtual void set_check_time_out(const mtk::dtTimeQuantity                         &  _prop) {  __check_time_out = _prop;  };
    bool                                         __has_pending_rq;
    virtual const bool                                        &  has_pending_rq() const {  return __has_pending_rq; };
    virtual void set_has_pending_rq(const bool                                        &  _prop) {  __has_pending_rq = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_SL&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_SL&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_SL&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_SL&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_SL&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_SL&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_SL&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_SL&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_SL&   rj           );
    void cf_tr (const mtk::trd::msg::CF_TR_SL&   tr           );
    void cf_st (const mtk::trd::msg::CF_ST_SL&   st           );
    void time_out (const int&          _            );


};



// -----------------------------------------------------------------------
//      w_cfnwmd
class w_cfnwmd  :   public  abstract_status
{
    mtk::non_copyable  nc;

public:
    w_cfnwmd (mtk::CountPtr<status_common_info> _ci,  const mtk::dtTimeQuantity                         & _check_time_out)
        : 
        abstract_status(_ci),
        __check_time_out(_check_time_out),
        __has_pending_rq(true)
        { 
            try
            {
                  if(check_time_out() > mtk::dtSeconds(0))        MTK_CALL_LATER1S_THIS(mtk::dtSeconds(2), 0, time_out);   
            }
            MTK_CATCH_RETHROW("w_cfnwmd_ctor", "rethrowed") };
    
    std::string  GetStatusName()  {  return "w_cfnwmd"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    mtk::dtTimeQuantity                          __check_time_out;
    virtual const mtk::dtTimeQuantity                         &  check_time_out() const {  return __check_time_out; };
    virtual void set_check_time_out(const mtk::dtTimeQuantity                         &  _prop) {  __check_time_out = _prop;  };
    bool                                         __has_pending_rq;
    virtual const bool                                        &  has_pending_rq() const {  return __has_pending_rq; };
    virtual void set_has_pending_rq(const bool                                        &  _prop) {  __has_pending_rq = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_SL&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_SL&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_SL&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_SL&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_SL&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_SL&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_SL&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_SL&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_SL&   rj           );
    void cf_tr (const mtk::trd::msg::CF_TR_SL&   tr           );
    void cf_st (const mtk::trd::msg::CF_ST_SL&   st           );
    void time_out (const int&          _            );


};



// -----------------------------------------------------------------------
//      w_cfnwcc
class w_cfnwcc  :   public  abstract_status
{
    mtk::non_copyable  nc;

public:
    w_cfnwcc (mtk::CountPtr<status_common_info> _ci,  const mtk::dtTimeQuantity                         & _check_time_out)
        : 
        abstract_status(_ci),
        __check_time_out(_check_time_out),
        __has_pending_rq(true)
        { 
            try
            {
                  if(check_time_out() > mtk::dtSeconds(0))        MTK_CALL_LATER1S_THIS(mtk::dtSeconds(2), 0, time_out);   
            }
            MTK_CATCH_RETHROW("w_cfnwcc_ctor", "rethrowed") };
    
    std::string  GetStatusName()  {  return "w_cfnwcc"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    mtk::dtTimeQuantity                          __check_time_out;
    virtual const mtk::dtTimeQuantity                         &  check_time_out() const {  return __check_time_out; };
    virtual void set_check_time_out(const mtk::dtTimeQuantity                         &  _prop) {  __check_time_out = _prop;  };
    bool                                         __has_pending_rq;
    virtual const bool                                        &  has_pending_rq() const {  return __has_pending_rq; };
    virtual void set_has_pending_rq(const bool                                        &  _prop) {  __has_pending_rq = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_SL&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_SL&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_SL&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_SL&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_SL&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_SL&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_SL&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_SL&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_SL&   rj           );
    void cf_tr (const mtk::trd::msg::CF_TR_SL&   tr           );
    void cf_st (const mtk::trd::msg::CF_ST_SL&   st           );
    void time_out (const int&          _            );


};



// -----------------------------------------------------------------------
//      canceled
class canceled  :   public  abstract_status
{
    mtk::non_copyable  nc;

public:
    canceled (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci),
        __is_canceled(true),
        __is_alive(false)
        {  };
    
    std::string  GetStatusName()  {  return "canceled"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    bool                                         __is_canceled;
    virtual const bool                                        &  is_canceled() const {  return __is_canceled; };
    virtual void set_is_canceled(const bool                                        &  _prop) {  __is_canceled = _prop;  };
    bool                                         __is_alive;
    virtual const bool                                        &  is_alive() const {  return __is_alive; };
    virtual void set_is_alive(const bool                                        &  _prop) {  __is_alive = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_SL&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_SL&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_SL&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_SL&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_SL&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_SL&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_SL&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_SL&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_SL&   rj           );
    void cf_tr (const mtk::trd::msg::CF_TR_SL&   tr           );
    void cf_st (const mtk::trd::msg::CF_ST_SL&   st           );
    void time_out (const int&          _            );


};



// -----------------------------------------------------------------------
//      triggered
class triggered  :   public  abstract_status
{
    mtk::non_copyable  nc;

public:
    triggered (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci),
        __is_triggered(true),
        __is_alive(false)
        {  };
    
    std::string  GetStatusName()  {  return "triggered"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    bool                                         __is_triggered;
    virtual const bool                                        &  is_triggered() const {  return __is_triggered; };
    virtual void set_is_triggered(const bool                                        &  _prop) {  __is_triggered = _prop;  };
    bool                                         __is_alive;
    virtual const bool                                        &  is_alive() const {  return __is_alive; };
    virtual void set_is_alive(const bool                                        &  _prop) {  __is_alive = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_SL&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_SL&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_SL&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_SL&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_SL&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_SL&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_SL&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_SL&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_SL&   rj           );
    void cf_tr (const mtk::trd::msg::CF_TR_SL&   tr           );
    void cf_st (const mtk::trd::msg::CF_ST_SL&   st           );
    void time_out (const int&          _            );


};



// -----------------------------------------------------------------------
//      error
class error  :   public  abstract_status
{
    mtk::non_copyable  nc;

public:
    error (mtk::CountPtr<status_common_info> _ci,  const std::string                                      & _description)
        : 
        abstract_status(_ci),
        __is_alive(false),
        __description(_description)
        { 
            try
            {
                
            ci->__serrors += std::string(", ") + description();
            mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", description(), mtk::alPriorCritic, mtk::alTypeNoPermisions));
      
            }
            MTK_CATCH_RETHROW("error_ctor", "rethrowed") };
    
    std::string  GetStatusName()  {  return "error"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    bool                                         __is_alive;
    virtual const bool                                        &  is_alive() const {  return __is_alive; };
    virtual void set_is_alive(const bool                                        &  _prop) {  __is_alive = _prop;  };
    std::string                                       __description;
    virtual const std::string                                      &  description() const {  return __description; };
    virtual void set_description(const std::string                                      &  _prop) {  __description = _prop;  };


    //  INPUTS
public:
    void rq_nw (const mtk::trd::msg::RQ_NW_SL&   rq           );
    void rq_md (const mtk::trd::msg::RQ_MD_SL&   rq           );
    void rq_cc (const mtk::trd::msg::RQ_CC_SL&   rq           );
    void cf_nw (const mtk::trd::msg::CF_NW_SL&   cf           );
    void cf_md (const mtk::trd::msg::CF_MD_SL&   cf           );
    void cf_cc (const mtk::trd::msg::CF_CC_SL&   cf           );
    void rj_nw (const mtk::trd::msg::RJ_NW_SL&   rj           );
    void rj_md (const mtk::trd::msg::RJ_MD_SL&   rj           );
    void rj_cc (const mtk::trd::msg::RJ_CC_SL&   rj           );
    void cf_tr (const mtk::trd::msg::CF_TR_SL&   tr           );
    void cf_st (const mtk::trd::msg::CF_ST_SL&   st           );
    void time_out (const int&          _            );


};






void init::rq_nw ( const mtk::trd::msg::RQ_NW_SL&   rq            )
{
    //  coverage
    ++status_common_info::coverage.init__rq_nw;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "init::rq_nw";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_rq

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid rqnw ")       ));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 CREATE_AND_SEND_REJECT(sig_rj_nw, RJ_NW_SL, MTK_SS(ci->__serrors << " in " << method_name))      ADD_HIST_RJ(csr_rj, nw)      ci->sig_changed();  

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnw (ci, (mtk::dtSeconds(2))));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_rqnw
  ADD_HIST_RQ(rq, nw)     ci->sig_rq_nw(rq);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::rq_md ( const mtk::trd::msg::RQ_MD_SL&   rq            )
{
    //  coverage
    ++status_common_info::coverage.init__rq_md;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "init::rq_md";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_MOD_AND_WRITE_LAST_REQ  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 std::string rj_message = MTK_SS(ci->__serrors << " in " << method_name);
                       if(qty_lower_exec)
                            rj_message =  " quantity lower or equal than executed quantity  " +  rj_message;
                        CREATE_AND_SEND_REJECT(sig_rj_md, RJ_MD_SL, rj_message) ADD_HIST_RJ(csr_rj, md)      ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::rq_cc ( const mtk::trd::msg::RQ_CC_SL&   rq            )
{
    //  coverage
    ++status_common_info::coverage.init__rq_cc;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "init::rq_cc";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqcc
 CREATE_AND_SEND_REJECT(sig_rj_cc, RJ_CC_SL, MTK_SS(ci->__serrors << " in " << method_name))      ADD_HIST_RJ(csr_rj, cc)      ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::cf_nw ( const mtk::trd::msg::CF_NW_SL&   cf            )
{
    //  coverage
    ++status_common_info::coverage.init__cf_nw;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "init::cf_nw";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::cf_md ( const mtk::trd::msg::CF_MD_SL&   cf            )
{
    //  coverage
    ++status_common_info::coverage.init__cf_md;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "init::cf_md";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::cf_cc ( const mtk::trd::msg::CF_CC_SL&   cf            )
{
    //  coverage
    ++status_common_info::coverage.init__cf_cc;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "init::cf_cc";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::rj_nw ( const mtk::trd::msg::RJ_NW_SL&   rj            )
{
    //  coverage
    ++status_common_info::coverage.init__rj_nw;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "init::rj_nw";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::rj_md ( const mtk::trd::msg::RJ_MD_SL&   rj            )
{
    //  coverage
    ++status_common_info::coverage.init__rj_md;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "init::rj_md";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::rj_cc ( const mtk::trd::msg::RJ_CC_SL&   rj            )
{
    //  coverage
    ++status_common_info::coverage.init__rj_cc;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "init::rj_cc";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::cf_tr ( const mtk::trd::msg::CF_TR_SL&   tr            )
{
    //  coverage
    ++status_common_info::coverage.init__cf_tr;

    //  remove unused warning
    (void) tr;

    
	static const char* method_name = "init::cf_tr";

    
                                int nerrors=0;
                                const mtk::trd::msg::CF_XX_SL& cf(tr);
                                CHECK_CONFIRM_AND_WRITE_LAST_CONF
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new triggered (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cftr
  ADD_HIST_CFTR(tr)       ci->sig_cf_tr(tr);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::cf_st ( const mtk::trd::msg::CF_ST_SL&   st            )
{
    //  coverage
    ++status_common_info::coverage.init__cf_st;

    //  remove unused warning
    (void) st;

    
	static const char* method_name = "init::cf_st";

      IF_LAST_CONF_ISNULL__WRITE_IT         

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfst
                          ci->sig_cf_st(st);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::time_out ( const int&          _             )
{
    //  coverage
    ++status_common_info::coverage.init__time_out;

    //  remove unused warning
    (void) _;

    
	static const char* method_name = "init::time_out";

      mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", MTK_SS("time out order " << method_name  << "  "  << last_request()), mtk::alPriorError));  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::rq_nw ( const mtk::trd::msg::RQ_NW_SL&   rq            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnw__rq_nw;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfnw::rq_nw";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 CREATE_AND_SEND_REJECT(sig_rj_nw, RJ_NW_SL, MTK_SS(ci->__serrors << " in " << method_name))      ADD_HIST_RJ(csr_rj, nw)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::rq_md ( const mtk::trd::msg::RQ_MD_SL&   rq            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnw__rq_md;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfnw::rq_md";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_MOD_AND_WRITE_LAST_REQ  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_rq

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new w_cfnwcc (ci, (mtk::dtSeconds(2))));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 std::string rj_message = MTK_SS(ci->__serrors << " in " << method_name);
                       if(qty_lower_exec)
                            rj_message =  " quantity lower or equal than executed quantity  " +  rj_message;
                        CREATE_AND_SEND_REJECT(sig_rj_md, RJ_MD_SL, rj_message) ADD_HIST_RJ(csr_rj, md)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnwmd (ci, (mtk::dtSeconds(2))));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_rqmd
  ADD_HIST_RQ(rq, md)     ci->sig_rq_md(rq);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::rq_cc ( const mtk::trd::msg::RQ_CC_SL&   rq            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnw__rq_cc;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfnw::rq_cc";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnwcc (ci, (mtk::dtSeconds(2))));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::cf_nw ( const mtk::trd::msg::CF_NW_SL&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnw__cf_nw;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfnw::cf_nw";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_cf

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid cfnw ")       ));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::cf_md ( const mtk::trd::msg::CF_MD_SL&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnw__cf_md;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfnw::cf_md";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::cf_cc ( const mtk::trd::msg::CF_CC_SL&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnw__cf_cc;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfnw::cf_cc";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::rj_nw ( const mtk::trd::msg::RJ_NW_SL&   rj            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnw__rj_nw;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfnw::rj_nw";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ADD_HIST_RJ(rj, nw)     ci->sig_rj_nw(rj);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::rj_md ( const mtk::trd::msg::RJ_MD_SL&   rj            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnw__rj_md;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfnw::rj_md";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ADD_HIST_RJ(rj, md)     ci->sig_rj_md(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::rj_cc ( const mtk::trd::msg::RJ_CC_SL&   rj            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnw__rj_cc;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfnw::rj_cc";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ADD_HIST_RJ(rj, cc)     ci->sig_rj_cc(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::cf_tr ( const mtk::trd::msg::CF_TR_SL&   tr            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnw__cf_tr;

    //  remove unused warning
    (void) tr;

    
	static const char* method_name = "w_cfnw::cf_tr";

    
                                int nerrors=0;
                                const mtk::trd::msg::CF_XX_SL& cf(tr);
                                CHECK_CONFIRM_AND_WRITE_LAST_CONF
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cftr
  ADD_HIST_CFTR(tr)       ci->sig_cf_tr(tr);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::cf_st ( const mtk::trd::msg::CF_ST_SL&   st            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnw__cf_st;

    //  remove unused warning
    (void) st;

    
	static const char* method_name = "w_cfnw::cf_st";

      IF_LAST_CONF_ISNULL__WRITE_IT         

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnw (ci, (mtk::dtSeconds(2))));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnw::time_out ( const int&          _             )
{
    //  coverage
    ++status_common_info::coverage.w_cfnw__time_out;

    //  remove unused warning
    (void) _;

    
	static const char* method_name = "w_cfnw::time_out";

      mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", MTK_SS("time out order " << method_name  << "  "  << last_request()), mtk::alPriorError));  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnw (ci, (mtk::dtSeconds(0))));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::rq_nw ( const mtk::trd::msg::RQ_NW_SL&   rq            )
{
    //  coverage
    ++status_common_info::coverage.market__rq_nw;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "market::rq_nw";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 CREATE_AND_SEND_REJECT(sig_rj_nw, RJ_NW_SL, MTK_SS(ci->__serrors << " in " << method_name))      ADD_HIST_RJ(csr_rj, nw)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::rq_md ( const mtk::trd::msg::RQ_MD_SL&   rq            )
{
    //  coverage
    ++status_common_info::coverage.market__rq_md;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "market::rq_md";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_MOD_AND_WRITE_LAST_REQ  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_rq

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new w_cfcc (ci, (mtk::dtSeconds(2))));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 std::string rj_message = MTK_SS(ci->__serrors << " in " << method_name);
                       if(qty_lower_exec)
                            rj_message =  " quantity lower or equal than executed quantity  " +  rj_message;
                        CREATE_AND_SEND_REJECT(sig_rj_md, RJ_MD_SL, rj_message) ADD_HIST_RJ(csr_rj, md)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmd (ci, (mtk::dtSeconds(2))));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_rqmd
  ADD_HIST_RQ(rq, md)     ci->sig_rq_md(rq);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::rq_cc ( const mtk::trd::msg::RQ_CC_SL&   rq            )
{
    //  coverage
    ++status_common_info::coverage.market__rq_cc;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "market::rq_cc";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfcc (ci, (mtk::dtSeconds(2))));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::cf_nw ( const mtk::trd::msg::CF_NW_SL&   cf            )
{
    //  coverage
    ++status_common_info::coverage.market__cf_nw;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "market::cf_nw";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::cf_md ( const mtk::trd::msg::CF_MD_SL&   cf            )
{
    //  coverage
    ++status_common_info::coverage.market__cf_md;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "market::cf_md";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd_nr
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::cf_cc ( const mtk::trd::msg::CF_CC_SL&   cf            )
{
    //  coverage
    ++status_common_info::coverage.market__cf_cc;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "market::cf_cc";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_cf

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid cfcc")   ));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc_nr
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc_nr
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::rj_nw ( const mtk::trd::msg::RJ_NW_SL&   rj            )
{
    //  coverage
    ++status_common_info::coverage.market__rj_nw;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "market::rj_nw";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ADD_HIST_RJ(rj, nw)     ci->sig_rj_nw(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::rj_md ( const mtk::trd::msg::RJ_MD_SL&   rj            )
{
    //  coverage
    ++status_common_info::coverage.market__rj_md;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "market::rj_md";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ADD_HIST_RJ(rj, md)     ci->sig_rj_md(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::rj_cc ( const mtk::trd::msg::RJ_CC_SL&   rj            )
{
    //  coverage
    ++status_common_info::coverage.market__rj_cc;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "market::rj_cc";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ADD_HIST_RJ(rj, cc)     ci->sig_rj_cc(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::cf_tr ( const mtk::trd::msg::CF_TR_SL&   tr            )
{
    //  coverage
    ++status_common_info::coverage.market__cf_tr;

    //  remove unused warning
    (void) tr;

    
	static const char* method_name = "market::cf_tr";

    
                                int nerrors=0;
                                const mtk::trd::msg::CF_XX_SL& cf(tr);
                                CHECK_CONFIRM_AND_WRITE_LAST_CONF
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new triggered (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cftr
  ADD_HIST_CFTR(tr)       ci->sig_cf_tr(tr);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::cf_st ( const mtk::trd::msg::CF_ST_SL&   st            )
{
    //  coverage
    ++status_common_info::coverage.market__cf_st;

    //  remove unused warning
    (void) st;

    
	static const char* method_name = "market::cf_st";

      IF_LAST_CONF_ISNULL__WRITE_IT         

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::time_out ( const int&          _             )
{
    //  coverage
    ++status_common_info::coverage.market__time_out;

    //  remove unused warning
    (void) _;

    
	static const char* method_name = "market::time_out";

      mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", MTK_SS("time out order " << method_name  << "  "  << last_request()), mtk::alPriorError));  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::rq_nw ( const mtk::trd::msg::RQ_NW_SL&   rq            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmd__rq_nw;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfmd::rq_nw";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 CREATE_AND_SEND_REJECT(sig_rj_nw, RJ_NW_SL, MTK_SS(ci->__serrors << " in " << method_name))      ADD_HIST_RJ(csr_rj, nw)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::rq_md ( const mtk::trd::msg::RQ_MD_SL&   rq            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmd__rq_md;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfmd::rq_md";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_MOD_AND_WRITE_LAST_REQ  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_rq

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid rqmd")));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 std::string rj_message = MTK_SS(ci->__serrors << " in " << method_name);
                       if(qty_lower_exec)
                            rj_message =  " quantity lower or equal than executed quantity  " +  rj_message;
                        CREATE_AND_SEND_REJECT(sig_rj_md, RJ_MD_SL, rj_message) ADD_HIST_RJ(csr_rj, md)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmd (ci, (mtk::dtSeconds(2))));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_rqmd
  ADD_HIST_RQ(rq, md)     ci->sig_rq_md(rq);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::rq_cc ( const mtk::trd::msg::RQ_CC_SL&   rq            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmd__rq_cc;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfmd::rq_cc";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmdcc (ci, (mtk::dtSeconds(2))));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::cf_nw ( const mtk::trd::msg::CF_NW_SL&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmd__cf_nw;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfmd::cf_nw";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::cf_md ( const mtk::trd::msg::CF_MD_SL&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmd__cf_md;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfmd::cf_md";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_cf

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid cfmd")));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (//  inserting macro: is_conf_last_rqmd

                    ({  bool result = false;
                        if (ci->last_request().HasValue())
                            result = (cf.req_id == ci->last_request().Get().request_info.req_id);
                        else
                            result = false;
                        result;
                    })
                 ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmd (ci, (mtk::dtSeconds(2))));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd_pend
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::cf_cc ( const mtk::trd::msg::CF_CC_SL&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmd__cf_cc;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfmd::cf_cc";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_cf

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid cfcc")  ));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc_nr
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc_nr
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::rj_nw ( const mtk::trd::msg::RJ_NW_SL&   rj            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmd__rj_nw;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfmd::rj_nw";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ADD_HIST_RJ(rj, nw)     ci->sig_rj_nw(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::rj_md ( const mtk::trd::msg::RJ_MD_SL&   rj            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmd__rj_md;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfmd::rj_md";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ADD_HIST_RJ(rj, md)     ci->sig_rj_md(rj);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::rj_cc ( const mtk::trd::msg::RJ_CC_SL&   rj            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmd__rj_cc;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfmd::rj_cc";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ADD_HIST_RJ(rj, cc)     ci->sig_rj_cc(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::cf_tr ( const mtk::trd::msg::CF_TR_SL&   tr            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmd__cf_tr;

    //  remove unused warning
    (void) tr;

    
	static const char* method_name = "w_cfmd::cf_tr";

    
                                int nerrors=0;
                                const mtk::trd::msg::CF_XX_SL& cf(tr);
                                CHECK_CONFIRM_AND_WRITE_LAST_CONF
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new triggered (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cftr
  ADD_HIST_CFTR(tr)       ci->sig_cf_tr(tr);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::cf_st ( const mtk::trd::msg::CF_ST_SL&   st            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmd__cf_st;

    //  remove unused warning
    (void) st;

    
	static const char* method_name = "w_cfmd::cf_st";

      IF_LAST_CONF_ISNULL__WRITE_IT         

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmd (ci, (mtk::dtSeconds(2))));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmd::time_out ( const int&          _             )
{
    //  coverage
    ++status_common_info::coverage.w_cfmd__time_out;

    //  remove unused warning
    (void) _;

    
	static const char* method_name = "w_cfmd::time_out";

      mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", MTK_SS("time out order " << method_name  << "  "  << last_request()), mtk::alPriorError));  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmd (ci, (mtk::dtSeconds(0))));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::rq_nw ( const mtk::trd::msg::RQ_NW_SL&   rq            )
{
    //  coverage
    ++status_common_info::coverage.w_cfcc__rq_nw;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfcc::rq_nw";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 CREATE_AND_SEND_REJECT(sig_rj_nw, RJ_NW_SL, MTK_SS(ci->__serrors << " in " << method_name))      ADD_HIST_RJ(csr_rj, nw)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::rq_md ( const mtk::trd::msg::RQ_MD_SL&   rq            )
{
    //  coverage
    ++status_common_info::coverage.w_cfcc__rq_md;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfcc::rq_md";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_MOD_AND_WRITE_LAST_REQ  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfcc (ci, (mtk::dtSeconds(2))));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 std::string rj_message = MTK_SS(ci->__serrors << " in " << method_name);
                       if(qty_lower_exec)
                            rj_message =  " quantity lower or equal than executed quantity  " +  rj_message;
                        CREATE_AND_SEND_REJECT(sig_rj_md, RJ_MD_SL, rj_message) ADD_HIST_RJ(csr_rj, md)      ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::rq_cc ( const mtk::trd::msg::RQ_CC_SL&   rq            )
{
    //  coverage
    ++status_common_info::coverage.w_cfcc__rq_cc;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfcc::rq_cc";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfcc (ci, (mtk::dtSeconds(2))));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::cf_nw ( const mtk::trd::msg::CF_NW_SL&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_cfcc__cf_nw;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfcc::cf_nw";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::cf_md ( const mtk::trd::msg::CF_MD_SL&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_cfcc__cf_md;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfcc::cf_md";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfcc (ci, (mtk::dtSeconds(2))));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::cf_cc ( const mtk::trd::msg::CF_CC_SL&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_cfcc__cf_cc;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfcc::cf_cc";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_cf

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid cfcc")  ));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc_nr
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::rj_nw ( const mtk::trd::msg::RJ_NW_SL&   rj            )
{
    //  coverage
    ++status_common_info::coverage.w_cfcc__rj_nw;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfcc::rj_nw";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ADD_HIST_RJ(rj, nw)     ci->sig_rj_nw(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::rj_md ( const mtk::trd::msg::RJ_MD_SL&   rj            )
{
    //  coverage
    ++status_common_info::coverage.w_cfcc__rj_md;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfcc::rj_md";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ADD_HIST_RJ(rj, md)     ci->sig_rj_md(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::rj_cc ( const mtk::trd::msg::RJ_CC_SL&   rj            )
{
    //  coverage
    ++status_common_info::coverage.w_cfcc__rj_cc;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfcc::rj_cc";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ADD_HIST_RJ(rj, cc)     ci->sig_rj_cc(rj);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::cf_tr ( const mtk::trd::msg::CF_TR_SL&   tr            )
{
    //  coverage
    ++status_common_info::coverage.w_cfcc__cf_tr;

    //  remove unused warning
    (void) tr;

    
	static const char* method_name = "w_cfcc::cf_tr";

    
                                int nerrors=0;
                                const mtk::trd::msg::CF_XX_SL& cf(tr);
                                CHECK_CONFIRM_AND_WRITE_LAST_CONF
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new triggered (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cftr
  ADD_HIST_CFTR(tr)       ci->sig_cf_tr(tr);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::cf_st ( const mtk::trd::msg::CF_ST_SL&   st            )
{
    //  coverage
    ++status_common_info::coverage.w_cfcc__cf_st;

    //  remove unused warning
    (void) st;

    
	static const char* method_name = "w_cfcc::cf_st";

      IF_LAST_CONF_ISNULL__WRITE_IT         

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfcc (ci, (mtk::dtSeconds(2))));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfcc::time_out ( const int&          _             )
{
    //  coverage
    ++status_common_info::coverage.w_cfcc__time_out;

    //  remove unused warning
    (void) _;

    
	static const char* method_name = "w_cfcc::time_out";

      mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", MTK_SS("time out order " << method_name  << "  "  << last_request()), mtk::alPriorError));  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfcc (ci, (mtk::dtSeconds(0))));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::rq_nw ( const mtk::trd::msg::RQ_NW_SL&   rq            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmdcc__rq_nw;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfmdcc::rq_nw";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 CREATE_AND_SEND_REJECT(sig_rj_nw, RJ_NW_SL, MTK_SS(ci->__serrors << " in " << method_name))      ADD_HIST_RJ(csr_rj, nw)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::rq_md ( const mtk::trd::msg::RQ_MD_SL&   rq            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmdcc__rq_md;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfmdcc::rq_md";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_MOD_AND_WRITE_LAST_REQ  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_rq

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new w_cfmdcc (ci, (mtk::dtSeconds(2))));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 std::string rj_message = MTK_SS(ci->__serrors << " in " << method_name);
                       if(qty_lower_exec)
                            rj_message =  " quantity lower or equal than executed quantity  " +  rj_message;
                        CREATE_AND_SEND_REJECT(sig_rj_md, RJ_MD_SL, rj_message) ADD_HIST_RJ(csr_rj, md)      ci->sig_changed();  

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmdcc (ci, (mtk::dtSeconds(2))));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 std::string rj_message = MTK_SS(ci->__serrors << " in " << method_name);
                       if(qty_lower_exec)
                            rj_message =  " quantity lower or equal than executed quantity  " +  rj_message;
                        CREATE_AND_SEND_REJECT(sig_rj_md, RJ_MD_SL, rj_message) ADD_HIST_RJ(csr_rj, md)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::rq_cc ( const mtk::trd::msg::RQ_CC_SL&   rq            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmdcc__rq_cc;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfmdcc::rq_cc";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmdcc (ci, (mtk::dtSeconds(2))));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::cf_nw ( const mtk::trd::msg::CF_NW_SL&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmdcc__cf_nw;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfmdcc::cf_nw";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::cf_md ( const mtk::trd::msg::CF_MD_SL&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmdcc__cf_md;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfmdcc::cf_md";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_cf

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid cfmd")));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (//  inserting macro: is_conf_last_rqmd

                    ({  bool result = false;
                        if (ci->last_request().HasValue())
                            result = (cf.req_id == ci->last_request().Get().request_info.req_id);
                        else
                            result = false;
                        result;
                    })
                 ) {

            new_status = mtk::make_cptr(new w_cfcc (ci, (mtk::dtSeconds(2))));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmdcc (ci, (mtk::dtSeconds(2))));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd_pend
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::cf_cc ( const mtk::trd::msg::CF_CC_SL&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmdcc__cf_cc;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfmdcc::cf_cc";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_cf

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid cfcc")  ));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc_nr
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::rj_nw ( const mtk::trd::msg::RJ_NW_SL&   rj            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmdcc__rj_nw;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfmdcc::rj_nw";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ADD_HIST_RJ(rj, nw)     ci->sig_rj_nw(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::rj_md ( const mtk::trd::msg::RJ_MD_SL&   rj            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmdcc__rj_md;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfmdcc::rj_md";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfcc (ci, (mtk::dtSeconds(2))));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ADD_HIST_RJ(rj, md)     ci->sig_rj_md(rj);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::rj_cc ( const mtk::trd::msg::RJ_CC_SL&   rj            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmdcc__rj_cc;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfmdcc::rj_cc";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmd (ci, (mtk::dtSeconds(2))));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ADD_HIST_RJ(rj, cc)     ci->sig_rj_cc(rj);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::cf_tr ( const mtk::trd::msg::CF_TR_SL&   tr            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmdcc__cf_tr;

    //  remove unused warning
    (void) tr;

    
	static const char* method_name = "w_cfmdcc::cf_tr";

    
                                int nerrors=0;
                                const mtk::trd::msg::CF_XX_SL& cf(tr);
                                CHECK_CONFIRM_AND_WRITE_LAST_CONF
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new triggered (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cftr
  ADD_HIST_CFTR(tr)       ci->sig_cf_tr(tr);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::cf_st ( const mtk::trd::msg::CF_ST_SL&   st            )
{
    //  coverage
    ++status_common_info::coverage.w_cfmdcc__cf_st;

    //  remove unused warning
    (void) st;

    
	static const char* method_name = "w_cfmdcc::cf_st";

      IF_LAST_CONF_ISNULL__WRITE_IT         

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmdcc (ci, (mtk::dtSeconds(2))));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfmdcc::time_out ( const int&          _             )
{
    //  coverage
    ++status_common_info::coverage.w_cfmdcc__time_out;

    //  remove unused warning
    (void) _;

    
	static const char* method_name = "w_cfmdcc::time_out";

      mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", MTK_SS("time out order " << method_name  << "  "  << last_request()), mtk::alPriorError));  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmdcc (ci, (mtk::dtSeconds(0))));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::rq_nw ( const mtk::trd::msg::RQ_NW_SL&   rq            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwmd__rq_nw;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfnwmd::rq_nw";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 CREATE_AND_SEND_REJECT(sig_rj_nw, RJ_NW_SL, MTK_SS(ci->__serrors << " in " << method_name))      ADD_HIST_RJ(csr_rj, nw)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::rq_md ( const mtk::trd::msg::RQ_MD_SL&   rq            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwmd__rq_md;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfnwmd::rq_md";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_MOD_AND_WRITE_LAST_REQ  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_rq

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new w_cfnwcc (ci, (mtk::dtSeconds(2))));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 std::string rj_message = MTK_SS(ci->__serrors << " in " << method_name);
                       if(qty_lower_exec)
                            rj_message =  " quantity lower or equal than executed quantity  " +  rj_message;
                        CREATE_AND_SEND_REJECT(sig_rj_md, RJ_MD_SL, rj_message) ADD_HIST_RJ(csr_rj, md)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnwmd (ci, (mtk::dtSeconds(2))));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_rqmd
  ADD_HIST_RQ(rq, md)     ci->sig_rq_md(rq);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::rq_cc ( const mtk::trd::msg::RQ_CC_SL&   rq            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwmd__rq_cc;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfnwmd::rq_cc";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnwcc (ci, (mtk::dtSeconds(2))));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::cf_nw ( const mtk::trd::msg::CF_NW_SL&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwmd__cf_nw;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfnwmd::cf_nw";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_cf

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid cfnw")));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfmd (ci, (mtk::dtSeconds(2))));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::cf_md ( const mtk::trd::msg::CF_MD_SL&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwmd__cf_md;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfnwmd::cf_md";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::cf_cc ( const mtk::trd::msg::CF_CC_SL&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwmd__cf_cc;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfnwmd::cf_cc";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::rj_nw ( const mtk::trd::msg::RJ_NW_SL&   rj            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwmd__rj_nw;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfnwmd::rj_nw";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ADD_HIST_RJ(rj, nw)     ci->sig_rj_nw(rj);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::rj_md ( const mtk::trd::msg::RJ_MD_SL&   rj            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwmd__rj_md;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfnwmd::rj_md";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ADD_HIST_RJ(rj, md)     ci->sig_rj_md(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::rj_cc ( const mtk::trd::msg::RJ_CC_SL&   rj            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwmd__rj_cc;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfnwmd::rj_cc";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ADD_HIST_RJ(rj, cc)     ci->sig_rj_cc(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::cf_tr ( const mtk::trd::msg::CF_TR_SL&   tr            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwmd__cf_tr;

    //  remove unused warning
    (void) tr;

    
	static const char* method_name = "w_cfnwmd::cf_tr";

    
                                int nerrors=0;
                                const mtk::trd::msg::CF_XX_SL& cf(tr);
                                CHECK_CONFIRM_AND_WRITE_LAST_CONF
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cftr
  ADD_HIST_CFTR(tr)       ci->sig_cf_tr(tr);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::cf_st ( const mtk::trd::msg::CF_ST_SL&   st            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwmd__cf_st;

    //  remove unused warning
    (void) st;

    
	static const char* method_name = "w_cfnwmd::cf_st";

      IF_LAST_CONF_ISNULL__WRITE_IT         

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnwmd (ci, (mtk::dtSeconds(2))));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwmd::time_out ( const int&          _             )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwmd__time_out;

    //  remove unused warning
    (void) _;

    
	static const char* method_name = "w_cfnwmd::time_out";

      mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", MTK_SS("time out order " << method_name  << "  "  << last_request()), mtk::alPriorError));  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnwmd (ci, (mtk::dtSeconds(0))));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::rq_nw ( const mtk::trd::msg::RQ_NW_SL&   rq            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwcc__rq_nw;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfnwcc::rq_nw";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 CREATE_AND_SEND_REJECT(sig_rj_nw, RJ_NW_SL, MTK_SS(ci->__serrors << " in " << method_name))      ADD_HIST_RJ(csr_rj, nw)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::rq_md ( const mtk::trd::msg::RQ_MD_SL&   rq            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwcc__rq_md;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfnwcc::rq_md";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_MOD_AND_WRITE_LAST_REQ  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnwcc (ci, (mtk::dtSeconds(2))));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_rqmd
  ADD_HIST_RQ(rq, md)     ci->sig_rq_md(rq);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::rq_cc ( const mtk::trd::msg::RQ_CC_SL&   rq            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwcc__rq_cc;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "w_cfnwcc::rq_cc";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnwcc (ci, (mtk::dtSeconds(2))));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::cf_nw ( const mtk::trd::msg::CF_NW_SL&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwcc__cf_nw;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfnwcc::cf_nw";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_cf

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new error (ci, ("invalid cfnw")));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new w_cfcc (ci, (mtk::dtSeconds(2))));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::cf_md ( const mtk::trd::msg::CF_MD_SL&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwcc__cf_md;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfnwcc::cf_md";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::cf_cc ( const mtk::trd::msg::CF_CC_SL&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwcc__cf_cc;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_cfnwcc::cf_cc";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::rj_nw ( const mtk::trd::msg::RJ_NW_SL&   rj            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwcc__rj_nw;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfnwcc::rj_nw";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ADD_HIST_RJ(rj, nw)     ci->sig_rj_nw(rj);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::rj_md ( const mtk::trd::msg::RJ_MD_SL&   rj            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwcc__rj_md;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfnwcc::rj_md";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ADD_HIST_RJ(rj, md)     ci->sig_rj_md(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::rj_cc ( const mtk::trd::msg::RJ_CC_SL&   rj            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwcc__rj_cc;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "w_cfnwcc::rj_cc";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ADD_HIST_RJ(rj, cc)     ci->sig_rj_cc(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::cf_tr ( const mtk::trd::msg::CF_TR_SL&   tr            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwcc__cf_tr;

    //  remove unused warning
    (void) tr;

    
	static const char* method_name = "w_cfnwcc::cf_tr";

    
                                int nerrors=0;
                                const mtk::trd::msg::CF_XX_SL& cf(tr);
                                CHECK_CONFIRM_AND_WRITE_LAST_CONF
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cftr
  ADD_HIST_CFTR(tr)       ci->sig_cf_tr(tr);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::cf_st ( const mtk::trd::msg::CF_ST_SL&   st            )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwcc__cf_st;

    //  remove unused warning
    (void) st;

    
	static const char* method_name = "w_cfnwcc::cf_st";

      IF_LAST_CONF_ISNULL__WRITE_IT         

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnwcc (ci, (mtk::dtSeconds(2))));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_cfnwcc::time_out ( const int&          _             )
{
    //  coverage
    ++status_common_info::coverage.w_cfnwcc__time_out;

    //  remove unused warning
    (void) _;

    
	static const char* method_name = "w_cfnwcc::time_out";

      mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", MTK_SS("time out order " << method_name  << "  "  << last_request()), mtk::alPriorError));  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new w_cfnwcc (ci, (mtk::dtSeconds(0))));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::rq_nw ( const mtk::trd::msg::RQ_NW_SL&   rq            )
{
    //  coverage
    ++status_common_info::coverage.canceled__rq_nw;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "canceled::rq_nw";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 CREATE_AND_SEND_REJECT(sig_rj_nw, RJ_NW_SL, MTK_SS(ci->__serrors << " in " << method_name))      ADD_HIST_RJ(csr_rj, nw)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::rq_md ( const mtk::trd::msg::RQ_MD_SL&   rq            )
{
    //  coverage
    ++status_common_info::coverage.canceled__rq_md;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "canceled::rq_md";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_MOD_AND_WRITE_LAST_REQ  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 std::string rj_message = MTK_SS(ci->__serrors << " in " << method_name);
                       if(qty_lower_exec)
                            rj_message =  " quantity lower or equal than executed quantity  " +  rj_message;
                        CREATE_AND_SEND_REJECT(sig_rj_md, RJ_MD_SL, rj_message) ADD_HIST_RJ(csr_rj, md)      ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::rq_cc ( const mtk::trd::msg::RQ_CC_SL&   rq            )
{
    //  coverage
    ++status_common_info::coverage.canceled__rq_cc;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "canceled::rq_cc";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqcc
 CREATE_AND_SEND_REJECT(sig_rj_cc, RJ_CC_SL, MTK_SS(ci->__serrors << " in " << method_name))      ADD_HIST_RJ(csr_rj, cc)      ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::cf_nw ( const mtk::trd::msg::CF_NW_SL&   cf            )
{
    //  coverage
    ++status_common_info::coverage.canceled__cf_nw;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "canceled::cf_nw";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::cf_md ( const mtk::trd::msg::CF_MD_SL&   cf            )
{
    //  coverage
    ++status_common_info::coverage.canceled__cf_md;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "canceled::cf_md";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::cf_cc ( const mtk::trd::msg::CF_CC_SL&   cf            )
{
    //  coverage
    ++status_common_info::coverage.canceled__cf_cc;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "canceled::cf_cc";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::rj_nw ( const mtk::trd::msg::RJ_NW_SL&   rj            )
{
    //  coverage
    ++status_common_info::coverage.canceled__rj_nw;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "canceled::rj_nw";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ADD_HIST_RJ(rj, nw)     ci->sig_rj_nw(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::rj_md ( const mtk::trd::msg::RJ_MD_SL&   rj            )
{
    //  coverage
    ++status_common_info::coverage.canceled__rj_md;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "canceled::rj_md";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ADD_HIST_RJ(rj, md)     ci->sig_rj_md(rj);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::rj_cc ( const mtk::trd::msg::RJ_CC_SL&   rj            )
{
    //  coverage
    ++status_common_info::coverage.canceled__rj_cc;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "canceled::rj_cc";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ADD_HIST_RJ(rj, cc)     ci->sig_rj_cc(rj);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::cf_tr ( const mtk::trd::msg::CF_TR_SL&   tr            )
{
    //  coverage
    ++status_common_info::coverage.canceled__cf_tr;

    //  remove unused warning
    (void) tr;

    
	static const char* method_name = "canceled::cf_tr";

    
                                int nerrors=0;
                                const mtk::trd::msg::CF_XX_SL& cf(tr);
                                CHECK_CONFIRM_AND_WRITE_LAST_CONF
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cftr
  ADD_HIST_CFTR(tr)       ci->sig_cf_tr(tr);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::cf_st ( const mtk::trd::msg::CF_ST_SL&   st            )
{
    //  coverage
    ++status_common_info::coverage.canceled__cf_st;

    //  remove unused warning
    (void) st;

    
	static const char* method_name = "canceled::cf_st";

      IF_LAST_CONF_ISNULL__WRITE_IT         

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::time_out ( const int&          _             )
{
    //  coverage
    ++status_common_info::coverage.canceled__time_out;

    //  remove unused warning
    (void) _;

    
	static const char* method_name = "canceled::time_out";

      mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", MTK_SS("time out order " << method_name  << "  "  << last_request()), mtk::alPriorError));  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void triggered::rq_nw ( const mtk::trd::msg::RQ_NW_SL&   rq            )
{
    //  coverage
    ++status_common_info::coverage.triggered__rq_nw;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "triggered::rq_nw";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 CREATE_AND_SEND_REJECT(sig_rj_nw, RJ_NW_SL, MTK_SS(ci->__serrors << " in " << method_name))      ADD_HIST_RJ(csr_rj, nw)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void triggered::rq_md ( const mtk::trd::msg::RQ_MD_SL&   rq            )
{
    //  coverage
    ++status_common_info::coverage.triggered__rq_md;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "triggered::rq_md";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_MOD_AND_WRITE_LAST_REQ  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new triggered (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 std::string rj_message = MTK_SS(ci->__serrors << " in " << method_name);
                       if(qty_lower_exec)
                            rj_message =  " quantity lower or equal than executed quantity  " +  rj_message;
                        CREATE_AND_SEND_REJECT(sig_rj_md, RJ_MD_SL, rj_message) ADD_HIST_RJ(csr_rj, md)      ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void triggered::rq_cc ( const mtk::trd::msg::RQ_CC_SL&   rq            )
{
    //  coverage
    ++status_common_info::coverage.triggered__rq_cc;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "triggered::rq_cc";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new triggered (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqcc
 CREATE_AND_SEND_REJECT(sig_rj_cc, RJ_CC_SL, MTK_SS(ci->__serrors << " in " << method_name))      ADD_HIST_RJ(csr_rj, cc)      ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void triggered::cf_nw ( const mtk::trd::msg::CF_NW_SL&   cf            )
{
    //  coverage
    ++status_common_info::coverage.triggered__cf_nw;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "triggered::cf_nw";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void triggered::cf_md ( const mtk::trd::msg::CF_MD_SL&   cf            )
{
    //  coverage
    ++status_common_info::coverage.triggered__cf_md;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "triggered::cf_md";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void triggered::cf_cc ( const mtk::trd::msg::CF_CC_SL&   cf            )
{
    //  coverage
    ++status_common_info::coverage.triggered__cf_cc;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "triggered::cf_cc";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void triggered::rj_nw ( const mtk::trd::msg::RJ_NW_SL&   rj            )
{
    //  coverage
    ++status_common_info::coverage.triggered__rj_nw;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "triggered::rj_nw";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ADD_HIST_RJ(rj, nw)     ci->sig_rj_nw(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void triggered::rj_md ( const mtk::trd::msg::RJ_MD_SL&   rj            )
{
    //  coverage
    ++status_common_info::coverage.triggered__rj_md;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "triggered::rj_md";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new triggered (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ADD_HIST_RJ(rj, md)     ci->sig_rj_md(rj);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void triggered::rj_cc ( const mtk::trd::msg::RJ_CC_SL&   rj            )
{
    //  coverage
    ++status_common_info::coverage.triggered__rj_cc;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "triggered::rj_cc";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new triggered (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ADD_HIST_RJ(rj, cc)     ci->sig_rj_cc(rj);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void triggered::cf_tr ( const mtk::trd::msg::CF_TR_SL&   tr            )
{
    //  coverage
    ++status_common_info::coverage.triggered__cf_tr;

    //  remove unused warning
    (void) tr;

    
	static const char* method_name = "triggered::cf_tr";

    
                                int nerrors=0;
                                const mtk::trd::msg::CF_XX_SL& cf(tr);
                                CHECK_CONFIRM_AND_WRITE_LAST_CONF
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cftr
  ADD_HIST_CFTR(tr)       ci->sig_cf_tr(tr);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void triggered::cf_st ( const mtk::trd::msg::CF_ST_SL&   st            )
{
    //  coverage
    ++status_common_info::coverage.triggered__cf_st;

    //  remove unused warning
    (void) st;

    
	static const char* method_name = "triggered::cf_st";

      IF_LAST_CONF_ISNULL__WRITE_IT         

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new triggered (ci));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void triggered::time_out ( const int&          _             )
{
    //  coverage
    ++status_common_info::coverage.triggered__time_out;

    //  remove unused warning
    (void) _;

    
	static const char* method_name = "triggered::time_out";

      mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", MTK_SS("time out order " << method_name  << "  "  << last_request()), mtk::alPriorError));  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::rq_nw ( const mtk::trd::msg::RQ_NW_SL&   rq            )
{
    //  coverage
    ++status_common_info::coverage.error__rq_nw;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "error::rq_nw";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
 CREATE_AND_SEND_REJECT(sig_rj_nw, RJ_NW_SL, MTK_SS(ci->__serrors << " in " << method_name))      ADD_HIST_RJ(csr_rj, nw)      ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::rq_md ( const mtk::trd::msg::RQ_MD_SL&   rq            )
{
    //  coverage
    ++status_common_info::coverage.error__rq_md;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "error::rq_md";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_MOD_AND_WRITE_LAST_REQ  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
 std::string rj_message = MTK_SS(ci->__serrors << " in " << method_name);
                       if(qty_lower_exec)
                            rj_message =  " quantity lower or equal than executed quantity  " +  rj_message;
                        CREATE_AND_SEND_REJECT(sig_rj_md, RJ_MD_SL, rj_message) ADD_HIST_RJ(csr_rj, md)      ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::rq_cc ( const mtk::trd::msg::RQ_CC_SL&   rq            )
{
    //  coverage
    ++status_common_info::coverage.error__rq_cc;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "error::rq_cc";

      int nerrors=0;  bool qty_lower_exec=false;(void)qty_lower_exec;  CHECK_REQUEST_AND_WRITE_LAST_REQ      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::cf_nw ( const mtk::trd::msg::CF_NW_SL&   cf            )
{
    //  coverage
    ++status_common_info::coverage.error__cf_nw;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "error::cf_nw";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfnw
  ADD_HIST_CF(cf, nw)     ci->sig_cf_nw(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::cf_md ( const mtk::trd::msg::CF_MD_SL&   cf            )
{
    //  coverage
    ++status_common_info::coverage.error__cf_md;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "error::cf_md";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfmd
  ADD_HIST_CF(cf, md)     ci->sig_cf_md(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::cf_cc ( const mtk::trd::msg::CF_CC_SL&   cf            )
{
    //  coverage
    ++status_common_info::coverage.error__cf_cc;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "error::cf_cc";

      int nerrors=0;  CHECK_CONFIRM_AND_WRITE_LAST_CONF     

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cfcc
  ADD_HIST_CF(cf, cc)     ci->sig_cf_cc(cf);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::rj_nw ( const mtk::trd::msg::RJ_NW_SL&   rj            )
{
    //  coverage
    ++status_common_info::coverage.error__rj_nw;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "error::rj_nw";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjnw
  ADD_HIST_RJ(rj, nw)     ci->sig_rj_nw(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::rj_md ( const mtk::trd::msg::RJ_MD_SL&   rj            )
{
    //  coverage
    ++status_common_info::coverage.error__rj_md;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "error::rj_md";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjmd
  ADD_HIST_RJ(rj, md)     ci->sig_rj_md(rj);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::rj_cc ( const mtk::trd::msg::RJ_CC_SL&   rj            )
{
    //  coverage
    ++status_common_info::coverage.error__rj_cc;

    //  remove unused warning
    (void) rj;

    
	static const char* method_name = "error::rj_cc";

      int nerrors=0;  CHECK_REJECT_AND_WRITE_LAST_CONF      

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_rjcc
  ADD_HIST_RJ(rj, cc)     ci->sig_rj_cc(rj);  ci->sig_changed();  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::cf_tr ( const mtk::trd::msg::CF_TR_SL&   tr            )
{
    //  coverage
    ++status_common_info::coverage.error__cf_tr;

    //  remove unused warning
    (void) tr;

    
	static const char* method_name = "error::cf_tr";

    
                                int nerrors=0;
                                const mtk::trd::msg::CF_XX_SL& cf(tr);
                                CHECK_CONFIRM_AND_WRITE_LAST_CONF
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cftr
  ADD_HIST_CFTR(tr)       ci->sig_cf_tr(tr);  ci->sig_changed();  
//  inserting macro: rq_cc

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::RQ_XX     rqxx(last_confirmation().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL  rqxxls(rqxx, last_confirmation().Get().market_pos);
                        mtk::trd::msg::RQ_CC_SL  rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else if (last_request().HasValue())
                    {
                        mtk::trd::msg::RQ_XX    rqxx(last_request().Get().invariant, mtk::admin::get_request_info(), mtk::admin::get_control_fluct_info());
                        mtk::trd::msg::RQ_XX_SL rqxxls(rqxx, last_request().Get().request_pos);
                        mtk::trd::msg::RQ_CC_SL rqccls(rqxxls);
                        ADD_HIST_RQ(rqccls, cc)
                        ci->sig_rq_cc(rqccls);
                        ci->sig_changed();
                    }
                    else
                        throw mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", "Cannot request a cancelation with no previus request or previus confirmation", mtk::alPriorCritic, mtk::alTypeNoPermisions);
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::cf_st ( const mtk::trd::msg::CF_ST_SL&   st            )
{
    //  coverage
    ++status_common_info::coverage.error__cf_st;

    //  remove unused warning
    (void) st;

    
	static const char* method_name = "error::cf_st";

      IF_LAST_CONF_ISNULL__WRITE_IT         

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void error::time_out ( const int&          _             )
{
    //  coverage
    ++status_common_info::coverage.error__time_out;

    //  remove unused warning
    (void) _;

    
	static const char* method_name = "error::time_out";

      mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "trd_cli_sl.fsm", MTK_SS("time out order " << method_name  << "  "  << last_request()), mtk::alPriorError));  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new error (ci, (method_name)));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}


};  // end   namespace fsmgen_trd_cli_sl {

mtk::trd::trd_cli_sl_dangerous_signals_not_warped::trd_cli_sl_dangerous_signals_not_warped()
{
    mtk::CountPtr<fsmgen_trd_cli_sl::status_common_info> ci = mtk::make_cptr(
                            new fsmgen_trd_cli_sl::status_common_info ( sig_rq_nw,sig_rq_md,sig_rq_cc,sig_rj_nw,sig_rj_md,sig_rj_cc,sig_cf_nw,sig_cf_md,sig_cf_cc,sig_cf_tr,sig_cf_st,sig_changed));

    current_status = mtk::make_cptr(new fsmgen_trd_cli_sl::init(ci ) );
    MTK_CONNECT_THIS(ci->signal_new_status, on_new_status)
    MTK_CONNECT_THIS(ci->signal_keep_temp_status, on_keep_temp_status)
    MTK_CONNECT_THIS(ci->signal_remove_temp_status, on_remove_temp_status)
}


mtk::trd::trd_cli_sl_dangerous_signals_not_warped::~trd_cli_sl_dangerous_signals_not_warped()
{
}

void mtk::trd::trd_cli_sl_dangerous_signals_not_warped::on_new_status (mtk::CountPtr<fsmgen_trd_cli_sl::abstract_status>  new_status)
{
    current_status = new_status;
}

void mtk::trd::trd_cli_sl_dangerous_signals_not_warped::on_keep_temp_status (void)
{
    queue_temp_status.push_back(current_status);
}
void mtk::trd::trd_cli_sl_dangerous_signals_not_warped::on_remove_temp_status (void)
{
    queue_temp_status.pop_front();
}


std::string  mtk::trd::trd_cli_sl_dangerous_signals_not_warped::get_coverage_string(void)
{
    return current_status->get_coverage_string();
}

void mtk::trd::trd_cli_sl_dangerous_signals_not_warped::rq_nw (const mtk::trd::msg::RQ_NW_SL&   rq           )
{
    mtk::CountPtr<fsmgen_trd_cli_sl::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->rq_nw(rq);
}
void mtk::trd::trd_cli_sl_dangerous_signals_not_warped::rq_md (const mtk::trd::msg::RQ_MD_SL&   rq           )
{
    mtk::CountPtr<fsmgen_trd_cli_sl::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->rq_md(rq);
}
void mtk::trd::trd_cli_sl_dangerous_signals_not_warped::rq_cc (const mtk::trd::msg::RQ_CC_SL&   rq           )
{
    mtk::CountPtr<fsmgen_trd_cli_sl::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->rq_cc(rq);
}
void mtk::trd::trd_cli_sl_dangerous_signals_not_warped::cf_nw (const mtk::trd::msg::CF_NW_SL&   cf           )
{
    mtk::CountPtr<fsmgen_trd_cli_sl::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->cf_nw(cf);
}
void mtk::trd::trd_cli_sl_dangerous_signals_not_warped::cf_md (const mtk::trd::msg::CF_MD_SL&   cf           )
{
    mtk::CountPtr<fsmgen_trd_cli_sl::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->cf_md(cf);
}
void mtk::trd::trd_cli_sl_dangerous_signals_not_warped::cf_cc (const mtk::trd::msg::CF_CC_SL&   cf           )
{
    mtk::CountPtr<fsmgen_trd_cli_sl::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->cf_cc(cf);
}
void mtk::trd::trd_cli_sl_dangerous_signals_not_warped::rj_nw (const mtk::trd::msg::RJ_NW_SL&   rj           )
{
    mtk::CountPtr<fsmgen_trd_cli_sl::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->rj_nw(rj);
}
void mtk::trd::trd_cli_sl_dangerous_signals_not_warped::rj_md (const mtk::trd::msg::RJ_MD_SL&   rj           )
{
    mtk::CountPtr<fsmgen_trd_cli_sl::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->rj_md(rj);
}
void mtk::trd::trd_cli_sl_dangerous_signals_not_warped::rj_cc (const mtk::trd::msg::RJ_CC_SL&   rj           )
{
    mtk::CountPtr<fsmgen_trd_cli_sl::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->rj_cc(rj);
}
void mtk::trd::trd_cli_sl_dangerous_signals_not_warped::cf_tr (const mtk::trd::msg::CF_TR_SL&   tr           )
{
    mtk::CountPtr<fsmgen_trd_cli_sl::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->cf_tr(tr);
}
void mtk::trd::trd_cli_sl_dangerous_signals_not_warped::cf_st (const mtk::trd::msg::CF_ST_SL&   st           )
{
    mtk::CountPtr<fsmgen_trd_cli_sl::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->cf_st(st);
}
void mtk::trd::trd_cli_sl_dangerous_signals_not_warped::time_out (const int&          _            )
{
    mtk::CountPtr<fsmgen_trd_cli_sl::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->time_out(_);
}
const mtk::nullable<mtk::trd::msg::CF_XX_SL>           & mtk::trd::trd_cli_sl_dangerous_signals_not_warped::last_confirmation (void) const
{
    return current_status->last_confirmation();
}
const mtk::nullable<mtk::trd::msg::RQ_XX_SL>           & mtk::trd::trd_cli_sl_dangerous_signals_not_warped::last_request (void) const
{
    return current_status->last_request();
}
const mtk::CountPtr<mtk::trd::hist::order_historic_dangerous_not_signal_warped      >   & mtk::trd::trd_cli_sl_dangerous_signals_not_warped::history (void) const
{
    return current_status->history();
}
const bool                                             & mtk::trd::trd_cli_sl_dangerous_signals_not_warped::in_market_no_pend (void) const
{
    return current_status->in_market_no_pend();
}
const bool                                             & mtk::trd::trd_cli_sl_dangerous_signals_not_warped::is_canceled (void) const
{
    return current_status->is_canceled();
}
const bool                                             & mtk::trd::trd_cli_sl_dangerous_signals_not_warped::is_triggered (void) const
{
    return current_status->is_triggered();
}
const bool                                             & mtk::trd::trd_cli_sl_dangerous_signals_not_warped::is_alive (void) const
{
    return current_status->is_alive();
}
const bool                                             & mtk::trd::trd_cli_sl_dangerous_signals_not_warped::has_pending_rq (void) const
{
    return current_status->has_pending_rq();
}
const std::string                                      & mtk::trd::trd_cli_sl_dangerous_signals_not_warped::serrors (void) const
{
    return current_status->serrors();
}

//  warper RAII with signals and repository
mtk::trd::trd_cli_sl::trd_cli_sl (void)
    : ptr (new trd_cli_sl_dangerous_signals_not_warped())
{
    ptr->sig_rq_nw.connect(&sig_rq_nw);
    ptr->sig_rq_md.connect(&sig_rq_md);
    ptr->sig_rq_cc.connect(&sig_rq_cc);
    ptr->sig_rj_nw.connect(&sig_rj_nw);
    ptr->sig_rj_md.connect(&sig_rj_md);
    ptr->sig_rj_cc.connect(&sig_rj_cc);
    ptr->sig_cf_nw.connect(&sig_cf_nw);
    ptr->sig_cf_md.connect(&sig_cf_md);
    ptr->sig_cf_cc.connect(&sig_cf_cc);
    ptr->sig_cf_tr.connect(&sig_cf_tr);
    ptr->sig_cf_st.connect(&sig_cf_st);
    ptr->sig_changed.connect(&sig_changed);
}
mtk::trd::trd_cli_sl::trd_cli_sl (const mtk::CountPtr<trd_cli_sl_dangerous_signals_not_warped>& _ptr)
    :   ptr(_ptr)
{
    try
    {
    ptr->sig_rq_nw.connect(&sig_rq_nw);
    ptr->sig_rq_md.connect(&sig_rq_md);
    ptr->sig_rq_cc.connect(&sig_rq_cc);
    ptr->sig_rj_nw.connect(&sig_rj_nw);
    ptr->sig_rj_md.connect(&sig_rj_md);
    ptr->sig_rj_cc.connect(&sig_rj_cc);
    ptr->sig_cf_nw.connect(&sig_cf_nw);
    ptr->sig_cf_md.connect(&sig_cf_md);
    ptr->sig_cf_cc.connect(&sig_cf_cc);
    ptr->sig_cf_tr.connect(&sig_cf_tr);
    ptr->sig_cf_st.connect(&sig_cf_st);
    ptr->sig_changed.connect(&sig_changed);
    } MTK_CATCH_RETHROW("trd_cli_sl","connecting signals")
}

void mtk::trd::trd_cli_sl::set (const mtk::CountPtr<trd_cli_sl_dangerous_signals_not_warped>& _ptr)
{
ptr = _ptr;
    ptr->sig_rq_nw.connect(&sig_rq_nw);
    ptr->sig_rq_md.connect(&sig_rq_md);
    ptr->sig_rq_cc.connect(&sig_rq_cc);
    ptr->sig_rj_nw.connect(&sig_rj_nw);
    ptr->sig_rj_md.connect(&sig_rj_md);
    ptr->sig_rj_cc.connect(&sig_rj_cc);
    ptr->sig_cf_nw.connect(&sig_cf_nw);
    ptr->sig_cf_md.connect(&sig_cf_md);
    ptr->sig_cf_cc.connect(&sig_cf_cc);
    ptr->sig_cf_tr.connect(&sig_cf_tr);
    ptr->sig_cf_st.connect(&sig_cf_st);
    ptr->sig_changed.connect(&sig_changed);
}


void mtk::trd::trd_cli_sl::rq_nw (const mtk::trd::msg::RQ_NW_SL&   rq           )
{
    ptr->rq_nw(rq);
}
void mtk::trd::trd_cli_sl::rq_md (const mtk::trd::msg::RQ_MD_SL&   rq           )
{
    ptr->rq_md(rq);
}
void mtk::trd::trd_cli_sl::rq_cc (const mtk::trd::msg::RQ_CC_SL&   rq           )
{
    ptr->rq_cc(rq);
}
void mtk::trd::trd_cli_sl::cf_nw (const mtk::trd::msg::CF_NW_SL&   cf           )
{
    ptr->cf_nw(cf);
}
void mtk::trd::trd_cli_sl::cf_md (const mtk::trd::msg::CF_MD_SL&   cf           )
{
    ptr->cf_md(cf);
}
void mtk::trd::trd_cli_sl::cf_cc (const mtk::trd::msg::CF_CC_SL&   cf           )
{
    ptr->cf_cc(cf);
}
void mtk::trd::trd_cli_sl::rj_nw (const mtk::trd::msg::RJ_NW_SL&   rj           )
{
    ptr->rj_nw(rj);
}
void mtk::trd::trd_cli_sl::rj_md (const mtk::trd::msg::RJ_MD_SL&   rj           )
{
    ptr->rj_md(rj);
}
void mtk::trd::trd_cli_sl::rj_cc (const mtk::trd::msg::RJ_CC_SL&   rj           )
{
    ptr->rj_cc(rj);
}
void mtk::trd::trd_cli_sl::cf_tr (const mtk::trd::msg::CF_TR_SL&   tr           )
{
    ptr->cf_tr(tr);
}
void mtk::trd::trd_cli_sl::cf_st (const mtk::trd::msg::CF_ST_SL&   st           )
{
    ptr->cf_st(st);
}
void mtk::trd::trd_cli_sl::time_out (const int&          _            )
{
    ptr->time_out(_);
}
const mtk::nullable<mtk::trd::msg::CF_XX_SL>           & mtk::trd::trd_cli_sl::last_confirmation (void) const
{
    return  ptr->last_confirmation();
}
const mtk::nullable<mtk::trd::msg::RQ_XX_SL>           & mtk::trd::trd_cli_sl::last_request (void) const
{
    return  ptr->last_request();
}
const mtk::CountPtr<mtk::trd::hist::order_historic_dangerous_not_signal_warped      >   & mtk::trd::trd_cli_sl::history (void) const
{
    return  ptr->history();
}
const bool                                             & mtk::trd::trd_cli_sl::in_market_no_pend (void) const
{
    return  ptr->in_market_no_pend();
}
const bool                                             & mtk::trd::trd_cli_sl::is_canceled (void) const
{
    return  ptr->is_canceled();
}
const bool                                             & mtk::trd::trd_cli_sl::is_triggered (void) const
{
    return  ptr->is_triggered();
}
const bool                                             & mtk::trd::trd_cli_sl::is_alive (void) const
{
    return  ptr->is_alive();
}
const bool                                             & mtk::trd::trd_cli_sl::has_pending_rq (void) const
{
    return  ptr->has_pending_rq();
}
const std::string                                      & mtk::trd::trd_cli_sl::serrors (void) const
{
    return  ptr->serrors();
}
std::string  mtk::trd::trd_cli_sl::get_coverage_string (void)
{
    return ptr->get_coverage_string();
}
