//  code generated by fsm_gen
// generated automatically
// coded last modification:        $CODED_LAST_MODIF  desactivated, lots of false notifications
// pythonscript last modification: $SCRIPT_LAST_MODIF

#include "support/mtk_string.h"




namespace fsmgen_fsm_cli_acs {


class abstract_status;


// -----------------------------------------------------------------------
//      c o v e r a g e
struct   scoverage
{
    scoverage(void) :

          logout__user_rq_login (0)
        , logout__user_rq_logout (0)
        , logout__user_rq_changepass (0)
        , logout__srv_rs_login_key (0)
        , logout__srv_rs_login (0)
        , logout__srv_cf_logout (0)
        , logout__timeout (0)
        , logout__srv_rs_chpwd (0)
        , w_key__user_rq_login (0)
        , w_key__user_rq_logout (0)
        , w_key__user_rq_changepass (0)
        , w_key__srv_rs_login_key (0)
        , w_key__srv_rs_login (0)
        , w_key__srv_cf_logout (0)
        , w_key__timeout (0)
        , w_key__srv_rs_chpwd (0)
        , w_login__user_rq_login (0)
        , w_login__user_rq_logout (0)
        , w_login__user_rq_changepass (0)
        , w_login__srv_rs_login_key (0)
        , w_login__srv_rs_login (0)
        , w_login__srv_cf_logout (0)
        , w_login__timeout (0)
        , w_login__srv_rs_chpwd (0)
        , login_ok__user_rq_login (0)
        , login_ok__user_rq_logout (0)
        , login_ok__user_rq_changepass (0)
        , login_ok__srv_rs_login_key (0)
        , login_ok__srv_rs_login (0)
        , login_ok__srv_cf_logout (0)
        , login_ok__timeout (0)
        , login_ok__srv_rs_chpwd (0)
        , w_k_chp__user_rq_login (0)
        , w_k_chp__user_rq_logout (0)
        , w_k_chp__user_rq_changepass (0)
        , w_k_chp__srv_rs_login_key (0)
        , w_k_chp__srv_rs_login (0)
        , w_k_chp__srv_cf_logout (0)
        , w_k_chp__timeout (0)
        , w_k_chp__srv_rs_chpwd (0)
        , w_chpwd__user_rq_login (0)
        , w_chpwd__user_rq_logout (0)
        , w_chpwd__user_rq_changepass (0)
        , w_chpwd__srv_rs_login_key (0)
        , w_chpwd__srv_rs_login (0)
        , w_chpwd__srv_cf_logout (0)
        , w_chpwd__timeout (0)
        , w_chpwd__srv_rs_chpwd (0)
    {}

    int   logout__user_rq_login;
    int   logout__user_rq_logout;
    int   logout__user_rq_changepass;
    int   logout__srv_rs_login_key;
    int   logout__srv_rs_login;
    int   logout__srv_cf_logout;
    int   logout__timeout;
    int   logout__srv_rs_chpwd;
    int   w_key__user_rq_login;
    int   w_key__user_rq_logout;
    int   w_key__user_rq_changepass;
    int   w_key__srv_rs_login_key;
    int   w_key__srv_rs_login;
    int   w_key__srv_cf_logout;
    int   w_key__timeout;
    int   w_key__srv_rs_chpwd;
    int   w_login__user_rq_login;
    int   w_login__user_rq_logout;
    int   w_login__user_rq_changepass;
    int   w_login__srv_rs_login_key;
    int   w_login__srv_rs_login;
    int   w_login__srv_cf_logout;
    int   w_login__timeout;
    int   w_login__srv_rs_chpwd;
    int   login_ok__user_rq_login;
    int   login_ok__user_rq_logout;
    int   login_ok__user_rq_changepass;
    int   login_ok__srv_rs_login_key;
    int   login_ok__srv_rs_login;
    int   login_ok__srv_cf_logout;
    int   login_ok__timeout;
    int   login_ok__srv_rs_chpwd;
    int   w_k_chp__user_rq_login;
    int   w_k_chp__user_rq_logout;
    int   w_k_chp__user_rq_changepass;
    int   w_k_chp__srv_rs_login_key;
    int   w_k_chp__srv_rs_login;
    int   w_k_chp__srv_cf_logout;
    int   w_k_chp__timeout;
    int   w_k_chp__srv_rs_chpwd;
    int   w_chpwd__user_rq_login;
    int   w_chpwd__user_rq_logout;
    int   w_chpwd__user_rq_changepass;
    int   w_chpwd__srv_rs_login_key;
    int   w_chpwd__srv_rs_login;
    int   w_chpwd__srv_cf_logout;
    int   w_chpwd__timeout;
    int   w_chpwd__srv_rs_chpwd;

    std::string  get_string(void)
    {

        static mtk::dtDateTime  last_result_date_time = mtk::dtNowLocal() - mtk::dtDays(1);
        static std::string last_result = "";
        int num_touched=0;
        if(last_result_date_time + mtk::dtSeconds(30) > mtk::dtNowLocal())
            last_result = "";
              if(logout__user_rq_login)   {++num_touched; last_result += MTK_SS("logout__user_rq_login:" << logout__user_rq_login << std::endl);}
              if(logout__user_rq_logout)   {++num_touched; last_result += MTK_SS("logout__user_rq_logout:" << logout__user_rq_logout << std::endl);}
              if(logout__user_rq_changepass)   {++num_touched; last_result += MTK_SS("logout__user_rq_changepass:" << logout__user_rq_changepass << std::endl);}
              if(logout__srv_rs_login_key)   {++num_touched; last_result += MTK_SS("logout__srv_rs_login_key:" << logout__srv_rs_login_key << std::endl);}
              if(logout__srv_rs_login)   {++num_touched; last_result += MTK_SS("logout__srv_rs_login:" << logout__srv_rs_login << std::endl);}
              if(logout__srv_cf_logout)   {++num_touched; last_result += MTK_SS("logout__srv_cf_logout:" << logout__srv_cf_logout << std::endl);}
              if(logout__timeout)   {++num_touched; last_result += MTK_SS("logout__timeout:" << logout__timeout << std::endl);}
              if(logout__srv_rs_chpwd)   {++num_touched; last_result += MTK_SS("logout__srv_rs_chpwd:" << logout__srv_rs_chpwd << std::endl);}
              if(w_key__user_rq_login)   {++num_touched; last_result += MTK_SS("w_key__user_rq_login:" << w_key__user_rq_login << std::endl);}
              if(w_key__user_rq_logout)   {++num_touched; last_result += MTK_SS("w_key__user_rq_logout:" << w_key__user_rq_logout << std::endl);}
              if(w_key__user_rq_changepass)   {++num_touched; last_result += MTK_SS("w_key__user_rq_changepass:" << w_key__user_rq_changepass << std::endl);}
              if(w_key__srv_rs_login_key)   {++num_touched; last_result += MTK_SS("w_key__srv_rs_login_key:" << w_key__srv_rs_login_key << std::endl);}
              if(w_key__srv_rs_login)   {++num_touched; last_result += MTK_SS("w_key__srv_rs_login:" << w_key__srv_rs_login << std::endl);}
              if(w_key__srv_cf_logout)   {++num_touched; last_result += MTK_SS("w_key__srv_cf_logout:" << w_key__srv_cf_logout << std::endl);}
              if(w_key__timeout)   {++num_touched; last_result += MTK_SS("w_key__timeout:" << w_key__timeout << std::endl);}
              if(w_key__srv_rs_chpwd)   {++num_touched; last_result += MTK_SS("w_key__srv_rs_chpwd:" << w_key__srv_rs_chpwd << std::endl);}
              if(w_login__user_rq_login)   {++num_touched; last_result += MTK_SS("w_login__user_rq_login:" << w_login__user_rq_login << std::endl);}
              if(w_login__user_rq_logout)   {++num_touched; last_result += MTK_SS("w_login__user_rq_logout:" << w_login__user_rq_logout << std::endl);}
              if(w_login__user_rq_changepass)   {++num_touched; last_result += MTK_SS("w_login__user_rq_changepass:" << w_login__user_rq_changepass << std::endl);}
              if(w_login__srv_rs_login_key)   {++num_touched; last_result += MTK_SS("w_login__srv_rs_login_key:" << w_login__srv_rs_login_key << std::endl);}
              if(w_login__srv_rs_login)   {++num_touched; last_result += MTK_SS("w_login__srv_rs_login:" << w_login__srv_rs_login << std::endl);}
              if(w_login__srv_cf_logout)   {++num_touched; last_result += MTK_SS("w_login__srv_cf_logout:" << w_login__srv_cf_logout << std::endl);}
              if(w_login__timeout)   {++num_touched; last_result += MTK_SS("w_login__timeout:" << w_login__timeout << std::endl);}
              if(w_login__srv_rs_chpwd)   {++num_touched; last_result += MTK_SS("w_login__srv_rs_chpwd:" << w_login__srv_rs_chpwd << std::endl);}
              if(login_ok__user_rq_login)   {++num_touched; last_result += MTK_SS("login_ok__user_rq_login:" << login_ok__user_rq_login << std::endl);}
              if(login_ok__user_rq_logout)   {++num_touched; last_result += MTK_SS("login_ok__user_rq_logout:" << login_ok__user_rq_logout << std::endl);}
              if(login_ok__user_rq_changepass)   {++num_touched; last_result += MTK_SS("login_ok__user_rq_changepass:" << login_ok__user_rq_changepass << std::endl);}
              if(login_ok__srv_rs_login_key)   {++num_touched; last_result += MTK_SS("login_ok__srv_rs_login_key:" << login_ok__srv_rs_login_key << std::endl);}
              if(login_ok__srv_rs_login)   {++num_touched; last_result += MTK_SS("login_ok__srv_rs_login:" << login_ok__srv_rs_login << std::endl);}
              if(login_ok__srv_cf_logout)   {++num_touched; last_result += MTK_SS("login_ok__srv_cf_logout:" << login_ok__srv_cf_logout << std::endl);}
              if(login_ok__timeout)   {++num_touched; last_result += MTK_SS("login_ok__timeout:" << login_ok__timeout << std::endl);}
              if(login_ok__srv_rs_chpwd)   {++num_touched; last_result += MTK_SS("login_ok__srv_rs_chpwd:" << login_ok__srv_rs_chpwd << std::endl);}
              if(w_k_chp__user_rq_login)   {++num_touched; last_result += MTK_SS("w_k_chp__user_rq_login:" << w_k_chp__user_rq_login << std::endl);}
              if(w_k_chp__user_rq_logout)   {++num_touched; last_result += MTK_SS("w_k_chp__user_rq_logout:" << w_k_chp__user_rq_logout << std::endl);}
              if(w_k_chp__user_rq_changepass)   {++num_touched; last_result += MTK_SS("w_k_chp__user_rq_changepass:" << w_k_chp__user_rq_changepass << std::endl);}
              if(w_k_chp__srv_rs_login_key)   {++num_touched; last_result += MTK_SS("w_k_chp__srv_rs_login_key:" << w_k_chp__srv_rs_login_key << std::endl);}
              if(w_k_chp__srv_rs_login)   {++num_touched; last_result += MTK_SS("w_k_chp__srv_rs_login:" << w_k_chp__srv_rs_login << std::endl);}
              if(w_k_chp__srv_cf_logout)   {++num_touched; last_result += MTK_SS("w_k_chp__srv_cf_logout:" << w_k_chp__srv_cf_logout << std::endl);}
              if(w_k_chp__timeout)   {++num_touched; last_result += MTK_SS("w_k_chp__timeout:" << w_k_chp__timeout << std::endl);}
              if(w_k_chp__srv_rs_chpwd)   {++num_touched; last_result += MTK_SS("w_k_chp__srv_rs_chpwd:" << w_k_chp__srv_rs_chpwd << std::endl);}
              if(w_chpwd__user_rq_login)   {++num_touched; last_result += MTK_SS("w_chpwd__user_rq_login:" << w_chpwd__user_rq_login << std::endl);}
              if(w_chpwd__user_rq_logout)   {++num_touched; last_result += MTK_SS("w_chpwd__user_rq_logout:" << w_chpwd__user_rq_logout << std::endl);}
              if(w_chpwd__user_rq_changepass)   {++num_touched; last_result += MTK_SS("w_chpwd__user_rq_changepass:" << w_chpwd__user_rq_changepass << std::endl);}
              if(w_chpwd__srv_rs_login_key)   {++num_touched; last_result += MTK_SS("w_chpwd__srv_rs_login_key:" << w_chpwd__srv_rs_login_key << std::endl);}
              if(w_chpwd__srv_rs_login)   {++num_touched; last_result += MTK_SS("w_chpwd__srv_rs_login:" << w_chpwd__srv_rs_login << std::endl);}
              if(w_chpwd__srv_cf_logout)   {++num_touched; last_result += MTK_SS("w_chpwd__srv_cf_logout:" << w_chpwd__srv_cf_logout << std::endl);}
              if(w_chpwd__timeout)   {++num_touched; last_result += MTK_SS("w_chpwd__timeout:" << w_chpwd__timeout << std::endl);}
              if(w_chpwd__srv_rs_chpwd)   {++num_touched; last_result += MTK_SS("w_chpwd__srv_rs_chpwd:" << w_chpwd__srv_rs_chpwd << std::endl);}

        last_result += MTK_SS("__num_touched__:"  <<  num_touched);
        return last_result;

    }
};


// -----------------------------------------------------------------------
//      s t a t u s _ c o m m o n _ i n f o

struct  status_common_info
{
    status_common_info ( mtk::Signal<const mtk::acs::msg::res_login::IC_session_info&   /*login_conf*/  >& _sig_confirm_login_ok, mtk::Signal<const std::string&   /*description*/  >& _sig_reject_login, mtk::Signal<const std::string&   /*description*/  >& _sig_logout_login, mtk::Signal<>& _sig_password_changed, mtk::Signal<>& _sig_password_change_rj)
        :  
        __user_name("" ), 
        sig_confirm_login_ok (_sig_confirm_login_ok), 
        sig_reject_login (_sig_reject_login), 
        sig_logout_login (_sig_logout_login), 
        sig_password_changed (_sig_password_changed), 
        sig_password_change_rj (_sig_password_change_rj)
        {};
    virtual ~status_common_info(){};

    // PROPERTIES AND SIGNALS
    std::string                         __user_name;
    virtual const std::string                        &  user_name() const {  return __user_name; };
    virtual void set_user_name(const std::string                        &  _prop) {  __user_name = _prop;  };
    mtk::Signal<const mtk::acs::msg::res_login::IC_session_info&   /*login_conf*/  >& sig_confirm_login_ok;
    mtk::Signal<const std::string&   /*description*/  >& sig_reject_login;
    mtk::Signal<const std::string&   /*description*/  >& sig_logout_login;
    mtk::Signal<>& sig_password_changed;
    mtk::Signal<>& sig_password_change_rj;


    mtk::Signal<mtk::CountPtr<abstract_status> > signal_new_status;
    mtk::Signal<> signal_keep_temp_status;
    mtk::Signal<> signal_remove_temp_status;


    //  STATS AND COVERAGE
    static  scoverage     coverage;
};

scoverage status_common_info::coverage;





// -----------------------------------------------------------------------
//      abstract_status
class abstract_status  : public mtk::SignalReceptor
{
    mtk::non_copyable  nc;

public:
    abstract_status (mtk::CountPtr<status_common_info> _ci)
        : ci (_ci) {};
    virtual ~abstract_status() {};
    
    mtk::CountPtr<status_common_info> ci;
    
    virtual std::string  GetStatusName() = 0;

    //  INPUTS
    virtual void user_rq_login ( const std::string&   _user_name , const std::string&   _password    )=0;
    virtual void user_rq_logout ( )=0;
    virtual void user_rq_changepass ( const std::string&   _old_password, const std::string&   _new_password  )=0;
    virtual void srv_rs_login_key ( const mtk::acs::msg::res_login_key&   rs           )=0;
    virtual void srv_rs_login ( const mtk::acs::msg::res_login&   rs           )=0;
    virtual void srv_cf_logout ( const mtk::acs::msg::conf_logout&   cf           )=0;
    virtual void timeout ( const int&          __           )=0;
    virtual void srv_rs_chpwd ( const mtk::acs::msg::res_change_password&   rs           )=0;


    //  ACCESS
    virtual const std::string                         &  user_name (void) const { return ci->user_name(); }; 


    //  COVERAGE
    std::string  get_coverage_string(void)  { return ci->coverage.get_string(); };
};





// -----------------------------------------------------------------------
//      logout
class logout  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef logout  CLASS_NAME;

public:
    logout (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci)

        { 
            try
            {
                
        ci->set_user_name("");
    
            }
            MTK_CATCH_RETHROW("logout_ctor", "rethrowed") };
    
    std::string  GetStatusName()  {  return "logout"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)


    //  INPUTS
public:
    void user_rq_login (const std::string&   _user_name , const std::string&   _password    );
    void user_rq_logout ();
    void user_rq_changepass (const std::string&   _old_password, const std::string&   _new_password  );
protected:
    void srv_rs_login_key (const mtk::acs::msg::res_login_key&   rs           );
    void srv_rs_login (const mtk::acs::msg::res_login&   rs           );
    void srv_cf_logout (const mtk::acs::msg::conf_logout&   cf           );
    void timeout (const int&          __           );
    void srv_rs_chpwd (const mtk::acs::msg::res_change_password&   rs           );


};



// -----------------------------------------------------------------------
//      w_key
class w_key  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef w_key  CLASS_NAME;

public:
    w_key (mtk::CountPtr<status_common_info> _ci,  const mtk::acs::msg::req_login_key                                                            & _req_key, const std::string                                                                             & _password)
        : 
        abstract_status(_ci),
        __req_key(_req_key),
        __password(_password),
        __hqpid_confirm_login_key()
        { 
            try
            {
                
            MTK_QPID_RECEIVER_CONNECT_THIS(
                                    __hqpid_confirm_login_key,
                                    mtk::admin::get_url("client"),
                                    mtk::acs::msg::res_login_key::get_in_subject(SUBJECT_RESPONSE_IN(req_key().request_info)),
                                    mtk::acs::msg::res_login_key,
                                    srv_rs_login_key)

            MTK_CALL_LATER1S_THIS(mtk::dtSeconds(8), 0, timeout);
    
            }
            MTK_CATCH_RETHROW("w_key_ctor", "rethrowed") };
    
    std::string  GetStatusName()  {  return "w_key"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    mtk::acs::msg::req_login_key                                                             __req_key;
    virtual const mtk::acs::msg::req_login_key                                                            &  req_key() const {  return __req_key; };
    virtual void set_req_key(const mtk::acs::msg::req_login_key                                                            &  _prop) {  __req_key = _prop;  };
    std::string                                                                              __password;
    virtual const std::string                                                                             &  password() const {  return __password; };
    virtual void set_password(const std::string                                                                             &  _prop) {  __password = _prop;  };
    mtk::CountPtr< mtk::handle_qpid_exchange_receiverMT<mtk::acs::msg::res_login_key> >      __hqpid_confirm_login_key;
    virtual const mtk::CountPtr< mtk::handle_qpid_exchange_receiverMT<mtk::acs::msg::res_login_key> >     &  hqpid_confirm_login_key() const {  return __hqpid_confirm_login_key; };
    virtual void set_hqpid_confirm_login_key(const mtk::CountPtr< mtk::handle_qpid_exchange_receiverMT<mtk::acs::msg::res_login_key> >     &  _prop) {  __hqpid_confirm_login_key = _prop;  };


    //  INPUTS
public:
    void user_rq_login (const std::string&   _user_name , const std::string&   _password    );
    void user_rq_logout ();
    void user_rq_changepass (const std::string&   _old_password, const std::string&   _new_password  );
protected:
    void srv_rs_login_key (const mtk::acs::msg::res_login_key&   rs           );
    void srv_rs_login (const mtk::acs::msg::res_login&   rs           );
    void srv_cf_logout (const mtk::acs::msg::conf_logout&   cf           );
    void timeout (const int&          __           );
    void srv_rs_chpwd (const mtk::acs::msg::res_change_password&   rs           );


};



// -----------------------------------------------------------------------
//      w_login
class w_login  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef w_login  CLASS_NAME;

public:
    w_login (mtk::CountPtr<status_common_info> _ci,  const mtk::acs::msg::req_login                                                               & _req_login)
        : 
        abstract_status(_ci),
        __req_login(_req_login),
        __hqpid_confirm_login()
        { 
            try
            {
                
            MTK_QPID_RECEIVER_CONNECT_THIS(
                                    __hqpid_confirm_login,
                                    mtk::admin::get_url("client"),
                                    mtk::acs::msg::res_login::get_in_subject(SUBJECT_RESPONSE_IN(req_login().request_info)),
                                    mtk::acs::msg::res_login,
                                    srv_rs_login)

            MTK_CALL_LATER1S_THIS(mtk::dtSeconds(8), 0, timeout);
    
            }
            MTK_CATCH_RETHROW("w_login_ctor", "rethrowed") };
    
    std::string  GetStatusName()  {  return "w_login"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    mtk::acs::msg::req_login                                                                __req_login;
    virtual const mtk::acs::msg::req_login                                                               &  req_login() const {  return __req_login; };
    virtual void set_req_login(const mtk::acs::msg::req_login                                                               &  _prop) {  __req_login = _prop;  };
    mtk::CountPtr< mtk::handle_qpid_exchange_receiverMT<mtk::acs::msg::res_login> >         __hqpid_confirm_login;
    virtual const mtk::CountPtr< mtk::handle_qpid_exchange_receiverMT<mtk::acs::msg::res_login> >        &  hqpid_confirm_login() const {  return __hqpid_confirm_login; };
    virtual void set_hqpid_confirm_login(const mtk::CountPtr< mtk::handle_qpid_exchange_receiverMT<mtk::acs::msg::res_login> >        &  _prop) {  __hqpid_confirm_login = _prop;  };


    //  INPUTS
public:
    void user_rq_login (const std::string&   _user_name , const std::string&   _password    );
    void user_rq_logout ();
    void user_rq_changepass (const std::string&   _old_password, const std::string&   _new_password  );
protected:
    void srv_rs_login_key (const mtk::acs::msg::res_login_key&   rs           );
    void srv_rs_login (const mtk::acs::msg::res_login&   rs           );
    void srv_cf_logout (const mtk::acs::msg::conf_logout&   cf           );
    void timeout (const int&          __           );
    void srv_rs_chpwd (const mtk::acs::msg::res_change_password&   rs           );


};



// -----------------------------------------------------------------------
//      login_ok
class login_ok  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef login_ok  CLASS_NAME;

public:
    login_ok (mtk::CountPtr<status_common_info> _ci,  const mtk::acs::msg::res_login                                                               & _login_confirmed)
        : 
        abstract_status(_ci),
        __login_confirmed(_login_confirmed),
        __hqpid_logout()
        { 
            try
            {
                
            std::string  client_code        = login_confirmed().response_info.request_info.process_info.location.broker_code;
            std::string  location_machine   = login_confirmed().response_info.request_info.process_info.location.machine;
            std::string  session_id         = login_confirmed().session_info.session_id;
            MTK_QPID_RECEIVER_CONNECT_THIS(
                                    __hqpid_logout,
                                    mtk::admin::get_url("client"),
                                    mtk::acs::msg::conf_logout::get_in_subject(client_code, location_machine, session_id),
                                    mtk::acs::msg::conf_logout,
                                    srv_cf_logout)
    
            }
            MTK_CATCH_RETHROW("login_ok_ctor", "rethrowed") };
    
    std::string  GetStatusName()  {  return "login_ok"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    mtk::acs::msg::res_login                                                                __login_confirmed;
    virtual const mtk::acs::msg::res_login                                                               &  login_confirmed() const {  return __login_confirmed; };
    virtual void set_login_confirmed(const mtk::acs::msg::res_login                                                               &  _prop) {  __login_confirmed = _prop;  };
    mtk::CountPtr< mtk::handle_qpid_exchange_receiverMT<mtk::acs::msg::conf_logout> >         __hqpid_logout;
    virtual const mtk::CountPtr< mtk::handle_qpid_exchange_receiverMT<mtk::acs::msg::conf_logout> >        &  hqpid_logout() const {  return __hqpid_logout; };
    virtual void set_hqpid_logout(const mtk::CountPtr< mtk::handle_qpid_exchange_receiverMT<mtk::acs::msg::conf_logout> >        &  _prop) {  __hqpid_logout = _prop;  };


    //  INPUTS
public:
    void user_rq_login (const std::string&   _user_name , const std::string&   _password    );
    void user_rq_logout ();
    void user_rq_changepass (const std::string&   _old_password, const std::string&   _new_password  );
protected:
    void srv_rs_login_key (const mtk::acs::msg::res_login_key&   rs           );
    void srv_rs_login (const mtk::acs::msg::res_login&   rs           );
    void srv_cf_logout (const mtk::acs::msg::conf_logout&   cf           );
    void timeout (const int&          __           );
    void srv_rs_chpwd (const mtk::acs::msg::res_change_password&   rs           );


};



// -----------------------------------------------------------------------
//      w_k_chp
class w_k_chp  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef w_k_chp  CLASS_NAME;

public:
    w_k_chp (mtk::CountPtr<status_common_info> _ci,  const mtk::acs::msg::res_login                                                                & _login_confirmed, const mtk::acs::msg::req_login_key                                                            & _req_key, const std::string                                                                             & _old_password, const std::string                                                                             & _new_password)
        : 
        abstract_status(_ci),
        __login_confirmed(_login_confirmed),
        __req_key(_req_key),
        __old_password(_old_password),
        __new_password(_new_password),
        __hqpid_confirm_login_key(),
        __hqpid_logout()
        { 
            try
            {
                
            MTK_QPID_RECEIVER_CONNECT_THIS(
                                    __hqpid_confirm_login_key,
                                    mtk::admin::get_url("client"),
                                    mtk::acs::msg::res_login_key::get_in_subject(SUBJECT_RESPONSE_IN(req_key().request_info)),
                                    mtk::acs::msg::res_login_key,
                                    srv_rs_login_key)

            std::string  client_code        = login_confirmed().response_info.request_info.process_info.location.broker_code;
            std::string  location_machine   = login_confirmed().response_info.request_info.process_info.location.machine;
            std::string  session_id         = login_confirmed().session_info.session_id;
            MTK_QPID_RECEIVER_CONNECT_THIS(
                                    __hqpid_logout,
                                    mtk::admin::get_url("client"),
                                    mtk::acs::msg::conf_logout::get_in_subject(client_code, location_machine, session_id),
                                    mtk::acs::msg::conf_logout,
                                    srv_cf_logout)

            MTK_CALL_LATER1S_THIS(mtk::dtSeconds(8), 0, timeout);
    
            }
            MTK_CATCH_RETHROW("w_k_chp_ctor", "rethrowed") };
    
    std::string  GetStatusName()  {  return "w_k_chp"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    mtk::acs::msg::res_login                                                                 __login_confirmed;
    virtual const mtk::acs::msg::res_login                                                                &  login_confirmed() const {  return __login_confirmed; };
    virtual void set_login_confirmed(const mtk::acs::msg::res_login                                                                &  _prop) {  __login_confirmed = _prop;  };
    mtk::acs::msg::req_login_key                                                             __req_key;
    virtual const mtk::acs::msg::req_login_key                                                            &  req_key() const {  return __req_key; };
    virtual void set_req_key(const mtk::acs::msg::req_login_key                                                            &  _prop) {  __req_key = _prop;  };
    std::string                                                                              __old_password;
    virtual const std::string                                                                             &  old_password() const {  return __old_password; };
    virtual void set_old_password(const std::string                                                                             &  _prop) {  __old_password = _prop;  };
    std::string                                                                              __new_password;
    virtual const std::string                                                                             &  new_password() const {  return __new_password; };
    virtual void set_new_password(const std::string                                                                             &  _prop) {  __new_password = _prop;  };
    mtk::CountPtr< mtk::handle_qpid_exchange_receiverMT<mtk::acs::msg::res_login_key> >      __hqpid_confirm_login_key;
    virtual const mtk::CountPtr< mtk::handle_qpid_exchange_receiverMT<mtk::acs::msg::res_login_key> >     &  hqpid_confirm_login_key() const {  return __hqpid_confirm_login_key; };
    virtual void set_hqpid_confirm_login_key(const mtk::CountPtr< mtk::handle_qpid_exchange_receiverMT<mtk::acs::msg::res_login_key> >     &  _prop) {  __hqpid_confirm_login_key = _prop;  };
    mtk::CountPtr< mtk::handle_qpid_exchange_receiverMT<mtk::acs::msg::conf_logout> >        __hqpid_logout;
    virtual const mtk::CountPtr< mtk::handle_qpid_exchange_receiverMT<mtk::acs::msg::conf_logout> >       &  hqpid_logout() const {  return __hqpid_logout; };
    virtual void set_hqpid_logout(const mtk::CountPtr< mtk::handle_qpid_exchange_receiverMT<mtk::acs::msg::conf_logout> >       &  _prop) {  __hqpid_logout = _prop;  };


    //  INPUTS
public:
    void user_rq_login (const std::string&   _user_name , const std::string&   _password    );
    void user_rq_logout ();
    void user_rq_changepass (const std::string&   _old_password, const std::string&   _new_password  );
protected:
    void srv_rs_login_key (const mtk::acs::msg::res_login_key&   rs           );
    void srv_rs_login (const mtk::acs::msg::res_login&   rs           );
    void srv_cf_logout (const mtk::acs::msg::conf_logout&   cf           );
    void timeout (const int&          __           );
    void srv_rs_chpwd (const mtk::acs::msg::res_change_password&   rs           );


};



// -----------------------------------------------------------------------
//      w_chpwd
class w_chpwd  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef w_chpwd  CLASS_NAME;

public:
    w_chpwd (mtk::CountPtr<status_common_info> _ci,  const mtk::acs::msg::res_login                                                                  & _login_confirmed, const mtk::acs::msg::req_change_password                                                        & _req_change_password)
        : 
        abstract_status(_ci),
        __login_confirmed(_login_confirmed),
        __req_change_password(_req_change_password),
        __hqpid_confirm_change_password(),
        __hqpid_logout()
        { 
            try
            {
                
            MTK_QPID_RECEIVER_CONNECT_THIS(
                                    __hqpid_confirm_change_password,
                                    mtk::admin::get_url("client"),
                                    mtk::acs::msg::res_change_password::get_in_subject(SUBJECT_RESPONSE_IN(req_change_password().request_info)),
                                    mtk::acs::msg::res_change_password,
                                    srv_rs_chpwd)

            std::string  client_code        = login_confirmed().response_info.request_info.process_info.location.broker_code;
            std::string  location_machine   = login_confirmed().response_info.request_info.process_info.location.machine;
            std::string  session_id         = login_confirmed().session_info.session_id;
            MTK_QPID_RECEIVER_CONNECT_THIS(
                                    __hqpid_logout,
                                    mtk::admin::get_url("client"),
                                    mtk::acs::msg::conf_logout::get_in_subject(client_code, location_machine, session_id),
                                    mtk::acs::msg::conf_logout,
                                    srv_cf_logout)

            MTK_CALL_LATER1S_THIS(mtk::dtSeconds(8), 0, timeout);
    
            }
            MTK_CATCH_RETHROW("w_chpwd_ctor", "rethrowed") };
    
    std::string  GetStatusName()  {  return "w_chpwd"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)
    mtk::acs::msg::res_login                                                                   __login_confirmed;
    virtual const mtk::acs::msg::res_login                                                                  &  login_confirmed() const {  return __login_confirmed; };
    virtual void set_login_confirmed(const mtk::acs::msg::res_login                                                                  &  _prop) {  __login_confirmed = _prop;  };
    mtk::acs::msg::req_change_password                                                         __req_change_password;
    virtual const mtk::acs::msg::req_change_password                                                        &  req_change_password() const {  return __req_change_password; };
    virtual void set_req_change_password(const mtk::acs::msg::req_change_password                                                        &  _prop) {  __req_change_password = _prop;  };
    mtk::CountPtr< mtk::handle_qpid_exchange_receiverMT<mtk::acs::msg::res_change_password> >  __hqpid_confirm_change_password;
    virtual const mtk::CountPtr< mtk::handle_qpid_exchange_receiverMT<mtk::acs::msg::res_change_password> > &  hqpid_confirm_change_password() const {  return __hqpid_confirm_change_password; };
    virtual void set_hqpid_confirm_change_password(const mtk::CountPtr< mtk::handle_qpid_exchange_receiverMT<mtk::acs::msg::res_change_password> > &  _prop) {  __hqpid_confirm_change_password = _prop;  };
    mtk::CountPtr< mtk::handle_qpid_exchange_receiverMT<mtk::acs::msg::conf_logout> >          __hqpid_logout;
    virtual const mtk::CountPtr< mtk::handle_qpid_exchange_receiverMT<mtk::acs::msg::conf_logout> >         &  hqpid_logout() const {  return __hqpid_logout; };
    virtual void set_hqpid_logout(const mtk::CountPtr< mtk::handle_qpid_exchange_receiverMT<mtk::acs::msg::conf_logout> >         &  _prop) {  __hqpid_logout = _prop;  };


    //  INPUTS
public:
    void user_rq_login (const std::string&   _user_name , const std::string&   _password    );
    void user_rq_logout ();
    void user_rq_changepass (const std::string&   _old_password, const std::string&   _new_password  );
protected:
    void srv_rs_login_key (const mtk::acs::msg::res_login_key&   rs           );
    void srv_rs_login (const mtk::acs::msg::res_login&   rs           );
    void srv_cf_logout (const mtk::acs::msg::conf_logout&   cf           );
    void timeout (const int&          __           );
    void srv_rs_chpwd (const mtk::acs::msg::res_change_password&   rs           );


};






void logout::user_rq_login ( const std::string&   _user_name , const std::string&   _password     )
{
    //  coverage
    ++status_common_info::coverage.logout__user_rq_login;

    //  remove unused warning
    (void) _user_name;
(void) _password;

    
	static const char* method_name = "logout::user_rq_login";

      ci->set_user_name(_user_name);  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
//  inserting macro: prep_rq_login_key

        mtk::acs::msg::req_login_key req(mtk::admin::get_request_info(), ci->user_name());
    

            new_status = mtk::make_cptr(new w_key (ci, req, _password    ));
            ci->signal_new_status.emit(new_status);
//  inserting macro: srv_rq

        mtk_send_message("client", req);
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void logout::user_rq_logout (  )
{
    //  coverage
    ++status_common_info::coverage.logout__user_rq_logout;

    //  remove unused warning
    
    
	static const char* method_name = "logout::user_rq_logout";

      std::string description =    "requested by user";  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new logout (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: error

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS(method_name << "  invalid call for this status"), mtk::alPriorError, mtk::alTypeNoPermisions));
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void logout::user_rq_changepass ( const std::string&   _old_password, const std::string&   _new_password   )
{
    //  coverage
    ++status_common_info::coverage.logout__user_rq_changepass;

    //  remove unused warning
    (void) _old_password;
(void) _new_password;

    
	static const char* method_name = "logout::user_rq_changepass";

    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new logout (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: error

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS(method_name << "  invalid call for this status"), mtk::alPriorError, mtk::alTypeNoPermisions));
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void logout::srv_rs_login_key ( const mtk::acs::msg::res_login_key&   rs            )
{
    //  coverage
    ++status_common_info::coverage.logout__srv_rs_login_key;

    //  remove unused warning
    (void) rs;

    
	static const char* method_name = "logout::srv_rs_login_key";

    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new logout (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: error

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS(method_name << "  invalid call for this status"), mtk::alPriorError, mtk::alTypeNoPermisions));
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void logout::srv_rs_login ( const mtk::acs::msg::res_login&   rs            )
{
    //  coverage
    ++status_common_info::coverage.logout__srv_rs_login;

    //  remove unused warning
    (void) rs;

    
	static const char* method_name = "logout::srv_rs_login";

      std::string description =    "";  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new logout (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: error

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS(method_name << "  invalid call for this status"), mtk::alPriorError, mtk::alTypeNoPermisions));
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void logout::srv_cf_logout ( const mtk::acs::msg::conf_logout&   cf            )
{
    //  coverage
    ++status_common_info::coverage.logout__srv_cf_logout;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "logout::srv_cf_logout";

      std::string description =    cf.description;  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new logout (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: error

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS(method_name << "  invalid call for this status"), mtk::alPriorError, mtk::alTypeNoPermisions));
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void logout::timeout ( const int&          __            )
{
    //  coverage
    ++status_common_info::coverage.logout__timeout;

    //  remove unused warning
    (void) __;

    
	static const char* method_name = "logout::timeout";

      std::string description =    "time out";  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new logout (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: error

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS(method_name << "  invalid call for this status"), mtk::alPriorError, mtk::alTypeNoPermisions));
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void logout::srv_rs_chpwd ( const mtk::acs::msg::res_change_password&   rs            )
{
    //  coverage
    ++status_common_info::coverage.logout__srv_rs_chpwd;

    //  remove unused warning
    (void) rs;

    
	static const char* method_name = "logout::srv_rs_chpwd";

      std::string description =    "";  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new logout (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: error

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS(method_name << "  invalid call for this status"), mtk::alPriorError, mtk::alTypeNoPermisions));
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_key::user_rq_login ( const std::string&   _user_name , const std::string&   _password     )
{
    //  coverage
    ++status_common_info::coverage.w_key__user_rq_login;

    //  remove unused warning
    (void) _user_name;
(void) _password;

    
	static const char* method_name = "w_key::user_rq_login";

      ci->set_user_name(_user_name);  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new logout (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: error

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS(method_name << "  invalid call for this status"), mtk::alPriorError, mtk::alTypeNoPermisions));
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_key::user_rq_logout (  )
{
    //  coverage
    ++status_common_info::coverage.w_key__user_rq_logout;

    //  remove unused warning
    
    
	static const char* method_name = "w_key::user_rq_logout";

      std::string description =    "requested by user";  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new logout (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: error

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS(method_name << "  invalid call for this status"), mtk::alPriorError, mtk::alTypeNoPermisions));
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_key::user_rq_changepass ( const std::string&   _old_password, const std::string&   _new_password   )
{
    //  coverage
    ++status_common_info::coverage.w_key__user_rq_changepass;

    //  remove unused warning
    (void) _old_password;
(void) _new_password;

    
	static const char* method_name = "w_key::user_rq_changepass";

    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new logout (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: error

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS(method_name << "  invalid call for this status"), mtk::alPriorError, mtk::alTypeNoPermisions));
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_key::srv_rs_login_key ( const mtk::acs::msg::res_login_key&   rs            )
{
    //  coverage
    ++status_common_info::coverage.w_key__srv_rs_login_key;

    //  remove unused warning
    (void) rs;

    
	static const char* method_name = "w_key::srv_rs_login_key";

    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
//  inserting macro: prep_rq_login

        std::string  coded_pass = mtk::crc32_as_string(MTK_SS(mtk::s_toUpper(req_key().user_name) <<mtk::crc32_as_string(password())<<rs.key));
        mtk::acs::msg::req_login req(mtk::admin::get_request_info(), req_key().user_name, rs.key, coded_pass);
    

            new_status = mtk::make_cptr(new w_login (ci, req));
            ci->signal_new_status.emit(new_status);
//  inserting macro: srv_rq

        mtk_send_message("client", req);
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_key::srv_rs_login ( const mtk::acs::msg::res_login&   rs            )
{
    //  coverage
    ++status_common_info::coverage.w_key__srv_rs_login;

    //  remove unused warning
    (void) rs;

    
	static const char* method_name = "w_key::srv_rs_login";

      std::string description =    "";  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new logout (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: error

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS(method_name << "  invalid call for this status"), mtk::alPriorError, mtk::alTypeNoPermisions));
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_key::srv_cf_logout ( const mtk::acs::msg::conf_logout&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_key__srv_cf_logout;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_key::srv_cf_logout";

      std::string description =    cf.description;  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new logout (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: error

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS(method_name << "  invalid call for this status"), mtk::alPriorError, mtk::alTypeNoPermisions));
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_key::timeout ( const int&          __            )
{
    //  coverage
    ++status_common_info::coverage.w_key__timeout;

    //  remove unused warning
    (void) __;

    
	static const char* method_name = "w_key::timeout";

      std::string description =    "time out";  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new logout (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: sig_login_rj

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS("login rejected "  << description), mtk::alPriorError, mtk::alTypeNoPermisions));
        ci->sig_reject_login.emit(description);
        mtk::admin::client_logout_confirmation(description);
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_key::srv_rs_chpwd ( const mtk::acs::msg::res_change_password&   rs            )
{
    //  coverage
    ++status_common_info::coverage.w_key__srv_rs_chpwd;

    //  remove unused warning
    (void) rs;

    
	static const char* method_name = "w_key::srv_rs_chpwd";

      std::string description =    "";  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new logout (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: error

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS(method_name << "  invalid call for this status"), mtk::alPriorError, mtk::alTypeNoPermisions));
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_login::user_rq_login ( const std::string&   _user_name , const std::string&   _password     )
{
    //  coverage
    ++status_common_info::coverage.w_login__user_rq_login;

    //  remove unused warning
    (void) _user_name;
(void) _password;

    
	static const char* method_name = "w_login::user_rq_login";

      ci->set_user_name(_user_name);  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new logout (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: error

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS(method_name << "  invalid call for this status"), mtk::alPriorError, mtk::alTypeNoPermisions));
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_login::user_rq_logout (  )
{
    //  coverage
    ++status_common_info::coverage.w_login__user_rq_logout;

    //  remove unused warning
    
    
	static const char* method_name = "w_login::user_rq_logout";

      std::string description =    "requested by user";  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new logout (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: error

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS(method_name << "  invalid call for this status"), mtk::alPriorError, mtk::alTypeNoPermisions));
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_login::user_rq_changepass ( const std::string&   _old_password, const std::string&   _new_password   )
{
    //  coverage
    ++status_common_info::coverage.w_login__user_rq_changepass;

    //  remove unused warning
    (void) _old_password;
(void) _new_password;

    
	static const char* method_name = "w_login::user_rq_changepass";

    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new logout (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: error

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS(method_name << "  invalid call for this status"), mtk::alPriorError, mtk::alTypeNoPermisions));
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_login::srv_rs_login_key ( const mtk::acs::msg::res_login_key&   rs            )
{
    //  coverage
    ++status_common_info::coverage.w_login__srv_rs_login_key;

    //  remove unused warning
    (void) rs;

    
	static const char* method_name = "w_login::srv_rs_login_key";

    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new logout (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: error

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS(method_name << "  invalid call for this status"), mtk::alPriorError, mtk::alTypeNoPermisions));
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_login::srv_rs_login ( const mtk::acs::msg::res_login&   rs            )
{
    //  coverage
    ++status_common_info::coverage.w_login__srv_rs_login;

    //  remove unused warning
    (void) rs;

    
	static const char* method_name = "w_login::srv_rs_login";

      std::string description =    "";  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: rlok

        rs.session_info.user_name != ""
     ) {

            new_status = mtk::make_cptr(new login_ok (ci, rs));
            ci->signal_new_status.emit(new_status);
//  inserting macro: sig_login_ok

        mtk::admin::client_login_ok_confirmation(rs.session_info);
        ci->sig_confirm_login_ok.emit(rs.session_info);
    

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new logout (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: sig_login_rj

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS("login rejected "  << description), mtk::alPriorError, mtk::alTypeNoPermisions));
        ci->sig_reject_login.emit(description);
        mtk::admin::client_logout_confirmation(description);
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_login::srv_cf_logout ( const mtk::acs::msg::conf_logout&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_login__srv_cf_logout;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_login::srv_cf_logout";

      std::string description =    cf.description;  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new logout (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: error

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS(method_name << "  invalid call for this status"), mtk::alPriorError, mtk::alTypeNoPermisions));
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_login::timeout ( const int&          __            )
{
    //  coverage
    ++status_common_info::coverage.w_login__timeout;

    //  remove unused warning
    (void) __;

    
	static const char* method_name = "w_login::timeout";

      std::string description =    "time out";  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new logout (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: sig_login_rj

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS("login rejected "  << description), mtk::alPriorError, mtk::alTypeNoPermisions));
        ci->sig_reject_login.emit(description);
        mtk::admin::client_logout_confirmation(description);
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_login::srv_rs_chpwd ( const mtk::acs::msg::res_change_password&   rs            )
{
    //  coverage
    ++status_common_info::coverage.w_login__srv_rs_chpwd;

    //  remove unused warning
    (void) rs;

    
	static const char* method_name = "w_login::srv_rs_chpwd";

      std::string description =    "";  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new logout (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: error

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS(method_name << "  invalid call for this status"), mtk::alPriorError, mtk::alTypeNoPermisions));
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void login_ok::user_rq_login ( const std::string&   _user_name , const std::string&   _password     )
{
    //  coverage
    ++status_common_info::coverage.login_ok__user_rq_login;

    //  remove unused warning
    (void) _user_name;
(void) _password;

    
	static const char* method_name = "login_ok::user_rq_login";

      ci->set_user_name(_user_name);  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
//  inserting macro: prep_rq_logout

        mtk::acs::msg::req_logout req(mtk::admin::get_request_info());
    

            new_status = mtk::make_cptr(new logout (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: error

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS(method_name << "  invalid call for this status"), mtk::alPriorError, mtk::alTypeNoPermisions));
    
//  inserting macro: srv_rq

        mtk_send_message("client", req);
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void login_ok::user_rq_logout (  )
{
    //  coverage
    ++status_common_info::coverage.login_ok__user_rq_logout;

    //  remove unused warning
    
    
	static const char* method_name = "login_ok::user_rq_logout";

      std::string description =    "requested by user";  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
//  inserting macro: prep_rq_logout

        mtk::acs::msg::req_logout req(mtk::admin::get_request_info());
    

            new_status = mtk::make_cptr(new logout (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: srv_rq

        mtk_send_message("client", req);
    
//  inserting macro: sig_logout

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS("received logout  " << description), mtk::alPriorError, mtk::alTypeNoPermisions));
        ci->sig_logout_login.emit(description);
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void login_ok::user_rq_changepass ( const std::string&   _old_password, const std::string&   _new_password   )
{
    //  coverage
    ++status_common_info::coverage.login_ok__user_rq_changepass;

    //  remove unused warning
    (void) _old_password;
(void) _new_password;

    
	static const char* method_name = "login_ok::user_rq_changepass";

    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
//  inserting macro: prep_rq_login_key

        mtk::acs::msg::req_login_key req(mtk::admin::get_request_info(), ci->user_name());
    

            new_status = mtk::make_cptr(new w_k_chp (ci, login_confirmed(), req, _old_password, _new_password));
            ci->signal_new_status.emit(new_status);
//  inserting macro: srv_rq

        mtk_send_message("client", req);
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void login_ok::srv_rs_login_key ( const mtk::acs::msg::res_login_key&   rs            )
{
    //  coverage
    ++status_common_info::coverage.login_ok__srv_rs_login_key;

    //  remove unused warning
    (void) rs;

    
	static const char* method_name = "login_ok::srv_rs_login_key";

    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
//  inserting macro: prep_rq_logout

        mtk::acs::msg::req_logout req(mtk::admin::get_request_info());
    

            new_status = mtk::make_cptr(new logout (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: error

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS(method_name << "  invalid call for this status"), mtk::alPriorError, mtk::alTypeNoPermisions));
    
//  inserting macro: srv_rq

        mtk_send_message("client", req);
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void login_ok::srv_rs_login ( const mtk::acs::msg::res_login&   rs            )
{
    //  coverage
    ++status_common_info::coverage.login_ok__srv_rs_login;

    //  remove unused warning
    (void) rs;

    
	static const char* method_name = "login_ok::srv_rs_login";

      std::string description =    "";  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
//  inserting macro: prep_rq_logout

        mtk::acs::msg::req_logout req(mtk::admin::get_request_info());
    

            new_status = mtk::make_cptr(new logout (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: error

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS(method_name << "  invalid call for this status"), mtk::alPriorError, mtk::alTypeNoPermisions));
    
//  inserting macro: srv_rq

        mtk_send_message("client", req);
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void login_ok::srv_cf_logout ( const mtk::acs::msg::conf_logout&   cf            )
{
    //  coverage
    ++status_common_info::coverage.login_ok__srv_cf_logout;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "login_ok::srv_cf_logout";

      std::string description =    cf.description;  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new logout (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: sig_logout

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS("received logout  " << description), mtk::alPriorError, mtk::alTypeNoPermisions));
        ci->sig_logout_login.emit(description);
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void login_ok::timeout ( const int&          __            )
{
    //  coverage
    ++status_common_info::coverage.login_ok__timeout;

    //  remove unused warning
    (void) __;

    
	static const char* method_name = "login_ok::timeout";

      std::string description =    "time out";  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
//  inserting macro: prep_rq_logout

        mtk::acs::msg::req_logout req(mtk::admin::get_request_info());
    

            new_status = mtk::make_cptr(new logout (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: error

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS(method_name << "  invalid call for this status"), mtk::alPriorError, mtk::alTypeNoPermisions));
    
//  inserting macro: srv_rq

        mtk_send_message("client", req);
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void login_ok::srv_rs_chpwd ( const mtk::acs::msg::res_change_password&   rs            )
{
    //  coverage
    ++status_common_info::coverage.login_ok__srv_rs_chpwd;

    //  remove unused warning
    (void) rs;

    
	static const char* method_name = "login_ok::srv_rs_chpwd";

      std::string description =    "";  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
//  inserting macro: prep_rq_logout

        mtk::acs::msg::req_logout req(mtk::admin::get_request_info());
    

            new_status = mtk::make_cptr(new logout (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: error

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS(method_name << "  invalid call for this status"), mtk::alPriorError, mtk::alTypeNoPermisions));
    
//  inserting macro: srv_rq

        mtk_send_message("client", req);
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_k_chp::user_rq_login ( const std::string&   _user_name , const std::string&   _password     )
{
    //  coverage
    ++status_common_info::coverage.w_k_chp__user_rq_login;

    //  remove unused warning
    (void) _user_name;
(void) _password;

    
	static const char* method_name = "w_k_chp::user_rq_login";

      ci->set_user_name(_user_name);  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
//  inserting macro: prep_rq_logout

        mtk::acs::msg::req_logout req(mtk::admin::get_request_info());
    

            new_status = mtk::make_cptr(new login_ok (ci, login_confirmed()));
            ci->signal_new_status.emit(new_status);
//  inserting macro: error

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS(method_name << "  invalid call for this status"), mtk::alPriorError, mtk::alTypeNoPermisions));
    
//  inserting macro: srv_rq

        mtk_send_message("client", req);
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_k_chp::user_rq_logout (  )
{
    //  coverage
    ++status_common_info::coverage.w_k_chp__user_rq_logout;

    //  remove unused warning
    
    
	static const char* method_name = "w_k_chp::user_rq_logout";

      std::string description =    "requested by user";  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
//  inserting macro: prep_rq_logout

        mtk::acs::msg::req_logout req(mtk::admin::get_request_info());
    

            new_status = mtk::make_cptr(new logout (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: srv_rq

        mtk_send_message("client", req);
    
//  inserting macro: sig_logout

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS("received logout  " << description), mtk::alPriorError, mtk::alTypeNoPermisions));
        ci->sig_logout_login.emit(description);
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_k_chp::user_rq_changepass ( const std::string&   _old_password, const std::string&   _new_password   )
{
    //  coverage
    ++status_common_info::coverage.w_k_chp__user_rq_changepass;

    //  remove unused warning
    (void) _old_password;
(void) _new_password;

    
	static const char* method_name = "w_k_chp::user_rq_changepass";

    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
//  inserting macro: prep_rq_logout

        mtk::acs::msg::req_logout req(mtk::admin::get_request_info());
    

            new_status = mtk::make_cptr(new login_ok (ci, login_confirmed()));
            ci->signal_new_status.emit(new_status);
//  inserting macro: error

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS(method_name << "  invalid call for this status"), mtk::alPriorError, mtk::alTypeNoPermisions));
    
//  inserting macro: srv_rq

        mtk_send_message("client", req);
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_k_chp::srv_rs_login_key ( const mtk::acs::msg::res_login_key&   rs            )
{
    //  coverage
    ++status_common_info::coverage.w_k_chp__srv_rs_login_key;

    //  remove unused warning
    (void) rs;

    
	static const char* method_name = "w_k_chp::srv_rs_login_key";

    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
//  inserting macro: prep_rq_chpwd

        std::string     old_password_crc32 = mtk::crc32_as_string(old_password());
        std::string     old_password_coded = mtk::crc32_as_string(MTK_SS(mtk::s_toUpper(req_key().user_name) << old_password_crc32 <<rs.key));
        std::string     new_password_crc32 = mtk::crc32_as_string(new_password());
        mtk::list<int32_t>  new_password_coded;
        for(unsigned i=0; i<new_password_crc32.size(); ++i)
            new_password_coded.push_back(new_password_crc32[i] + old_password_crc32[i%(old_password_crc32.size()-1)]
                                                               + rs.key[i%(rs.key.size()-1)] );
        mtk::acs::msg::req_change_password req(mtk::admin::get_request_info(), req_key().user_name, rs.key, old_password_coded, new_password_coded);
    

            new_status = mtk::make_cptr(new w_chpwd (ci, login_confirmed(), req));
            ci->signal_new_status.emit(new_status);
//  inserting macro: srv_rq

        mtk_send_message("client", req);
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_k_chp::srv_rs_login ( const mtk::acs::msg::res_login&   rs            )
{
    //  coverage
    ++status_common_info::coverage.w_k_chp__srv_rs_login;

    //  remove unused warning
    (void) rs;

    
	static const char* method_name = "w_k_chp::srv_rs_login";

      std::string description =    "";  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
//  inserting macro: prep_rq_logout

        mtk::acs::msg::req_logout req(mtk::admin::get_request_info());
    

            new_status = mtk::make_cptr(new login_ok (ci, login_confirmed()));
            ci->signal_new_status.emit(new_status);
//  inserting macro: error

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS(method_name << "  invalid call for this status"), mtk::alPriorError, mtk::alTypeNoPermisions));
    
//  inserting macro: srv_rq

        mtk_send_message("client", req);
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_k_chp::srv_cf_logout ( const mtk::acs::msg::conf_logout&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_k_chp__srv_cf_logout;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_k_chp::srv_cf_logout";

      std::string description =    cf.description;  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new logout (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: sig_logout

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS("received logout  " << description), mtk::alPriorError, mtk::alTypeNoPermisions));
        ci->sig_logout_login.emit(description);
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_k_chp::timeout ( const int&          __            )
{
    //  coverage
    ++status_common_info::coverage.w_k_chp__timeout;

    //  remove unused warning
    (void) __;

    
	static const char* method_name = "w_k_chp::timeout";

      std::string description =    "time out";  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new login_ok (ci, login_confirmed()));
            ci->signal_new_status.emit(new_status);
//  inserting macro: sig_chpwd_rj

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS("change password rejected"), mtk::alPriorDebug));
        ci->sig_password_change_rj.emit();
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_k_chp::srv_rs_chpwd ( const mtk::acs::msg::res_change_password&   rs            )
{
    //  coverage
    ++status_common_info::coverage.w_k_chp__srv_rs_chpwd;

    //  remove unused warning
    (void) rs;

    
	static const char* method_name = "w_k_chp::srv_rs_chpwd";

      std::string description =    "";  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
//  inserting macro: prep_rq_logout

        mtk::acs::msg::req_logout req(mtk::admin::get_request_info());
    

            new_status = mtk::make_cptr(new login_ok (ci, login_confirmed()));
            ci->signal_new_status.emit(new_status);
//  inserting macro: error

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS(method_name << "  invalid call for this status"), mtk::alPriorError, mtk::alTypeNoPermisions));
    
//  inserting macro: srv_rq

        mtk_send_message("client", req);
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_chpwd::user_rq_login ( const std::string&   _user_name , const std::string&   _password     )
{
    //  coverage
    ++status_common_info::coverage.w_chpwd__user_rq_login;

    //  remove unused warning
    (void) _user_name;
(void) _password;

    
	static const char* method_name = "w_chpwd::user_rq_login";

      ci->set_user_name(_user_name);  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
//  inserting macro: prep_rq_logout

        mtk::acs::msg::req_logout req(mtk::admin::get_request_info());
    

            new_status = mtk::make_cptr(new login_ok (ci, login_confirmed()));
            ci->signal_new_status.emit(new_status);
//  inserting macro: error

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS(method_name << "  invalid call for this status"), mtk::alPriorError, mtk::alTypeNoPermisions));
    
//  inserting macro: srv_rq

        mtk_send_message("client", req);
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_chpwd::user_rq_logout (  )
{
    //  coverage
    ++status_common_info::coverage.w_chpwd__user_rq_logout;

    //  remove unused warning
    
    
	static const char* method_name = "w_chpwd::user_rq_logout";

      std::string description =    "requested by user";  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
//  inserting macro: prep_rq_logout

        mtk::acs::msg::req_logout req(mtk::admin::get_request_info());
    

            new_status = mtk::make_cptr(new logout (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: srv_rq

        mtk_send_message("client", req);
    
//  inserting macro: sig_logout

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS("received logout  " << description), mtk::alPriorError, mtk::alTypeNoPermisions));
        ci->sig_logout_login.emit(description);
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_chpwd::user_rq_changepass ( const std::string&   _old_password, const std::string&   _new_password   )
{
    //  coverage
    ++status_common_info::coverage.w_chpwd__user_rq_changepass;

    //  remove unused warning
    (void) _old_password;
(void) _new_password;

    
	static const char* method_name = "w_chpwd::user_rq_changepass";

    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
//  inserting macro: prep_rq_logout

        mtk::acs::msg::req_logout req(mtk::admin::get_request_info());
    

            new_status = mtk::make_cptr(new login_ok (ci, login_confirmed()));
            ci->signal_new_status.emit(new_status);
//  inserting macro: error

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS(method_name << "  invalid call for this status"), mtk::alPriorError, mtk::alTypeNoPermisions));
    
//  inserting macro: srv_rq

        mtk_send_message("client", req);
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_chpwd::srv_rs_login_key ( const mtk::acs::msg::res_login_key&   rs            )
{
    //  coverage
    ++status_common_info::coverage.w_chpwd__srv_rs_login_key;

    //  remove unused warning
    (void) rs;

    
	static const char* method_name = "w_chpwd::srv_rs_login_key";

    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
//  inserting macro: prep_rq_logout

        mtk::acs::msg::req_logout req(mtk::admin::get_request_info());
    

            new_status = mtk::make_cptr(new login_ok (ci, login_confirmed()));
            ci->signal_new_status.emit(new_status);
//  inserting macro: error

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS(method_name << "  invalid call for this status"), mtk::alPriorError, mtk::alTypeNoPermisions));
    
//  inserting macro: srv_rq

        mtk_send_message("client", req);
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_chpwd::srv_rs_login ( const mtk::acs::msg::res_login&   rs            )
{
    //  coverage
    ++status_common_info::coverage.w_chpwd__srv_rs_login;

    //  remove unused warning
    (void) rs;

    
	static const char* method_name = "w_chpwd::srv_rs_login";

      std::string description =    "";  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
//  inserting macro: prep_rq_logout

        mtk::acs::msg::req_logout req(mtk::admin::get_request_info());
    

            new_status = mtk::make_cptr(new login_ok (ci, login_confirmed()));
            ci->signal_new_status.emit(new_status);
//  inserting macro: error

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS(method_name << "  invalid call for this status"), mtk::alPriorError, mtk::alTypeNoPermisions));
    
//  inserting macro: srv_rq

        mtk_send_message("client", req);
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_chpwd::srv_cf_logout ( const mtk::acs::msg::conf_logout&   cf            )
{
    //  coverage
    ++status_common_info::coverage.w_chpwd__srv_cf_logout;

    //  remove unused warning
    (void) cf;

    
	static const char* method_name = "w_chpwd::srv_cf_logout";

      std::string description =    cf.description;  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new logout (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: sig_logout

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS("received logout  " << description), mtk::alPriorError, mtk::alTypeNoPermisions));
        ci->sig_logout_login.emit(description);
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_chpwd::timeout ( const int&          __            )
{
    //  coverage
    ++status_common_info::coverage.w_chpwd__timeout;

    //  remove unused warning
    (void) __;

    
	static const char* method_name = "w_chpwd::timeout";

      std::string description =    "time out";  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {

            new_status = mtk::make_cptr(new login_ok (ci, login_confirmed()));
            ci->signal_new_status.emit(new_status);
//  inserting macro: sig_chpwd_rj

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS("change password rejected"), mtk::alPriorDebug));
        ci->sig_password_change_rj.emit();
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void w_chpwd::srv_rs_chpwd ( const mtk::acs::msg::res_change_password&   rs            )
{
    //  coverage
    ++status_common_info::coverage.w_chpwd__srv_rs_chpwd;

    //  remove unused warning
    (void) rs;

    
	static const char* method_name = "w_chpwd::srv_rs_chpwd";

      std::string description =    "";  

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: rchpwok

        rs.change_password_info.accepted
     ) {

            new_status = mtk::make_cptr(new login_ok (ci, login_confirmed()));
            ci->signal_new_status.emit(new_status);
//  inserting macro: sig_chpwd_ok

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS("change password confirmed"), mtk::alPriorDebug));
        ci->sig_password_changed.emit();
    

        }
    else 
        if (true ) {

            new_status = mtk::make_cptr(new login_ok (ci, login_confirmed()));
            ci->signal_new_status.emit(new_status);
//  inserting macro: sig_chpwd_rj

        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, "fsm_cli_acs", MTK_SS("change password rejected"), mtk::alPriorDebug));
        ci->sig_password_change_rj.emit();
    

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}


};  // end   namespace fsmgen_fsm_cli_acs {

mtk::acs_cli::fsm_cli_acs_dangerous_signals_not_warped::fsm_cli_acs_dangerous_signals_not_warped()
{
    mtk::CountPtr<fsmgen_fsm_cli_acs::status_common_info> ci = mtk::make_cptr(
                            new fsmgen_fsm_cli_acs::status_common_info ( sig_confirm_login_ok,sig_reject_login,sig_logout_login,sig_password_changed,sig_password_change_rj));

    current_status = mtk::make_cptr(new fsmgen_fsm_cli_acs::logout(ci ) );
    MTK_CONNECT_THIS(ci->signal_new_status, on_new_status)
    MTK_CONNECT_THIS(ci->signal_keep_temp_status, on_keep_temp_status)
    MTK_CONNECT_THIS(ci->signal_remove_temp_status, on_remove_temp_status)
}


mtk::acs_cli::fsm_cli_acs_dangerous_signals_not_warped::~fsm_cli_acs_dangerous_signals_not_warped()
{
}

void mtk::acs_cli::fsm_cli_acs_dangerous_signals_not_warped::on_new_status (mtk::CountPtr<fsmgen_fsm_cli_acs::abstract_status>  new_status)
{
    current_status = new_status;
}

void mtk::acs_cli::fsm_cli_acs_dangerous_signals_not_warped::on_keep_temp_status (void)
{
    queue_temp_status.push_back(current_status);
}
void mtk::acs_cli::fsm_cli_acs_dangerous_signals_not_warped::on_remove_temp_status (void)
{
    queue_temp_status.pop_front();
}


std::string  mtk::acs_cli::fsm_cli_acs_dangerous_signals_not_warped::get_coverage_string(void)
{
    return current_status->get_coverage_string();
}

void mtk::acs_cli::fsm_cli_acs_dangerous_signals_not_warped::user_rq_login (const std::string&   _user_name , const std::string&   _password    )
{
    mtk::CountPtr<fsmgen_fsm_cli_acs::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->user_rq_login(_user_name, _password);
}
void mtk::acs_cli::fsm_cli_acs_dangerous_signals_not_warped::user_rq_logout ()
{
    mtk::CountPtr<fsmgen_fsm_cli_acs::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->user_rq_logout();
}
void mtk::acs_cli::fsm_cli_acs_dangerous_signals_not_warped::user_rq_changepass (const std::string&   _old_password, const std::string&   _new_password  )
{
    mtk::CountPtr<fsmgen_fsm_cli_acs::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->user_rq_changepass(_old_password, _new_password);
}
const std::string                         & mtk::acs_cli::fsm_cli_acs_dangerous_signals_not_warped::user_name (void) const
{
    return current_status->user_name();
}

//  warper RAII with signals and repository
mtk::acs_cli::fsm_cli_acs::fsm_cli_acs (void)
    : ptr (new fsm_cli_acs_dangerous_signals_not_warped())
{
    ptr->sig_confirm_login_ok.connect(&sig_confirm_login_ok);
    ptr->sig_reject_login.connect(&sig_reject_login);
    ptr->sig_logout_login.connect(&sig_logout_login);
    ptr->sig_password_changed.connect(&sig_password_changed);
    ptr->sig_password_change_rj.connect(&sig_password_change_rj);
}
mtk::acs_cli::fsm_cli_acs::fsm_cli_acs (const mtk::CountPtr<fsm_cli_acs_dangerous_signals_not_warped>& _ptr)
    :   ptr(_ptr)
{
    try
    {
    ptr->sig_confirm_login_ok.connect(&sig_confirm_login_ok);
    ptr->sig_reject_login.connect(&sig_reject_login);
    ptr->sig_logout_login.connect(&sig_logout_login);
    ptr->sig_password_changed.connect(&sig_password_changed);
    ptr->sig_password_change_rj.connect(&sig_password_change_rj);
    } MTK_CATCH_RETHROW("fsm_cli_acs","connecting signals")
}

void mtk::acs_cli::fsm_cli_acs::set (const mtk::CountPtr<fsm_cli_acs_dangerous_signals_not_warped>& _ptr)
{
ptr = _ptr;
    ptr->sig_confirm_login_ok.connect(&sig_confirm_login_ok);
    ptr->sig_reject_login.connect(&sig_reject_login);
    ptr->sig_logout_login.connect(&sig_logout_login);
    ptr->sig_password_changed.connect(&sig_password_changed);
    ptr->sig_password_change_rj.connect(&sig_password_change_rj);
}


void mtk::acs_cli::fsm_cli_acs::user_rq_login (const std::string&   _user_name , const std::string&   _password    )
{
    ptr->user_rq_login(_user_name, _password);
}
void mtk::acs_cli::fsm_cli_acs::user_rq_logout ()
{
    ptr->user_rq_logout();
}
void mtk::acs_cli::fsm_cli_acs::user_rq_changepass (const std::string&   _old_password, const std::string&   _new_password  )
{
    ptr->user_rq_changepass(_old_password, _new_password);
}
const std::string                         & mtk::acs_cli::fsm_cli_acs::user_name (void) const
{
    return  ptr->user_name();
}
std::string  mtk::acs_cli::fsm_cli_acs::get_coverage_string (void)
{
    return ptr->get_coverage_string();
}
