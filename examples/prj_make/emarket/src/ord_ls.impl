//  code generated by fsm_gen
// generated automatically
// coded last modification:        $CODED_LAST_MODIF  desactivated, lots of false notifications
// pythonscript last modification: $SCRIPT_LAST_MODIF

#include "support/mtk_string.h"




namespace fsmgen_ord_ls {


class abstract_status;


// -----------------------------------------------------------------------
//      c o v e r a g e
struct   scoverage
{
    scoverage(void) :

          init__cli_rq_nw (0)
        , init__cli_rq_md (0)
        , init__cli_rq_cc (0)
        , init__mkt_cf_ex (0)
        , market__cli_rq_nw (0)
        , market__cli_rq_md (0)
        , market__cli_rq_cc (0)
        , market__mkt_cf_ex (0)
        , canceled__cli_rq_nw (0)
        , canceled__cli_rq_md (0)
        , canceled__cli_rq_cc (0)
        , canceled__mkt_cf_ex (0)
        , executed__cli_rq_nw (0)
        , executed__cli_rq_md (0)
        , executed__cli_rq_cc (0)
        , executed__mkt_cf_ex (0)
    {}

    int   init__cli_rq_nw;
    int   init__cli_rq_md;
    int   init__cli_rq_cc;
    int   init__mkt_cf_ex;
    int   market__cli_rq_nw;
    int   market__cli_rq_md;
    int   market__cli_rq_cc;
    int   market__mkt_cf_ex;
    int   canceled__cli_rq_nw;
    int   canceled__cli_rq_md;
    int   canceled__cli_rq_cc;
    int   canceled__mkt_cf_ex;
    int   executed__cli_rq_nw;
    int   executed__cli_rq_md;
    int   executed__cli_rq_cc;
    int   executed__mkt_cf_ex;

    std::string  get_string(void)
    {

        static mtk::dtDateTime  last_result_date_time = mtk::dtNowLocal() - mtk::dtDays(1);
        static std::string last_result = "";
        int num_touched=0;
        if(last_result_date_time + mtk::dtSeconds(30) > mtk::dtNowLocal())
            last_result = "";
              if(init__cli_rq_nw)   {++num_touched; last_result += MTK_SS("init__cli_rq_nw:" << init__cli_rq_nw << std::endl);}
              if(init__cli_rq_md)   {++num_touched; last_result += MTK_SS("init__cli_rq_md:" << init__cli_rq_md << std::endl);}
              if(init__cli_rq_cc)   {++num_touched; last_result += MTK_SS("init__cli_rq_cc:" << init__cli_rq_cc << std::endl);}
              if(init__mkt_cf_ex)   {++num_touched; last_result += MTK_SS("init__mkt_cf_ex:" << init__mkt_cf_ex << std::endl);}
              if(market__cli_rq_nw)   {++num_touched; last_result += MTK_SS("market__cli_rq_nw:" << market__cli_rq_nw << std::endl);}
              if(market__cli_rq_md)   {++num_touched; last_result += MTK_SS("market__cli_rq_md:" << market__cli_rq_md << std::endl);}
              if(market__cli_rq_cc)   {++num_touched; last_result += MTK_SS("market__cli_rq_cc:" << market__cli_rq_cc << std::endl);}
              if(market__mkt_cf_ex)   {++num_touched; last_result += MTK_SS("market__mkt_cf_ex:" << market__mkt_cf_ex << std::endl);}
              if(canceled__cli_rq_nw)   {++num_touched; last_result += MTK_SS("canceled__cli_rq_nw:" << canceled__cli_rq_nw << std::endl);}
              if(canceled__cli_rq_md)   {++num_touched; last_result += MTK_SS("canceled__cli_rq_md:" << canceled__cli_rq_md << std::endl);}
              if(canceled__cli_rq_cc)   {++num_touched; last_result += MTK_SS("canceled__cli_rq_cc:" << canceled__cli_rq_cc << std::endl);}
              if(canceled__mkt_cf_ex)   {++num_touched; last_result += MTK_SS("canceled__mkt_cf_ex:" << canceled__mkt_cf_ex << std::endl);}
              if(executed__cli_rq_nw)   {++num_touched; last_result += MTK_SS("executed__cli_rq_nw:" << executed__cli_rq_nw << std::endl);}
              if(executed__cli_rq_md)   {++num_touched; last_result += MTK_SS("executed__cli_rq_md:" << executed__cli_rq_md << std::endl);}
              if(executed__cli_rq_cc)   {++num_touched; last_result += MTK_SS("executed__cli_rq_cc:" << executed__cli_rq_cc << std::endl);}
              if(executed__mkt_cf_ex)   {++num_touched; last_result += MTK_SS("executed__mkt_cf_ex:" << executed__mkt_cf_ex << std::endl);}

        last_result += MTK_SS("__num_touched__:"  <<  num_touched);
        return last_result;

    }
};


// -----------------------------------------------------------------------
//      s t a t u s _ c o m m o n _ i n f o

struct  status_common_info
{
    status_common_info ( mtk::Signal<const mtk::trd::msg::CF_XX_LS&   /*order_st*/   >& _sig_ob_add_order, mtk::Signal<const mtk::trd::msg::CF_XX_LS&   /*order_st*/   >& _sig_ob_del_order, mtk::Signal<const mtk::trd::msg::CF_XX_LS&   /*order_st*/   >& _sig_ob_modif_order, mtk::Signal<const mtk::trd::msg::CF_XX_LS&   /*order_st*/   >& _sig_ob_check_execs, mtk::Signal<const mtk::trd::msg::CF_XX_LS&   /*order_st*/   >& _sig_ob_update_prices, mtk::Signal<const mtk::trd::msg::CF_NW_LS&   /*cf*/         >& _sig_cli_cf_nw, mtk::Signal<const mtk::trd::msg::CF_MD_LS&   /*cf*/         >& _sig_cli_cf_md, mtk::Signal<const mtk::trd::msg::CF_CC_LS&   /*cf*/         >& _sig_cli_cf_cc, mtk::Signal<const mtk::trd::msg::RJ_NW_LS&   /*rj*/         >& _sig_cli_rj_nw, mtk::Signal<const mtk::trd::msg::RJ_MD_LS&   /*rj*/         >& _sig_cli_rj_md, mtk::Signal<const mtk::trd::msg::RJ_CC_LS&   /*rj*/         >& _sig_cli_rj_cc, mtk::Signal<const mtk::trd::msg::CF_EX_LS&   /*ex*/         >& _sig_cli_cf_ex, mtk::Signal<const mtk::trd::msg::CF_EXLK&   /*exlk*/       >& _sig_cli_cf_exlk)
        :  
        __last_confirmation(mtk::nullable<mtk::trd::msg::CF_XX_LS>() ),
        __last_request(mtk::nullable<mtk::trd::msg::RQ_XX_LS>() ),
        __sequence(get_sequence() ), 
        sig_ob_add_order (_sig_ob_add_order), 
        sig_ob_del_order (_sig_ob_del_order), 
        sig_ob_modif_order (_sig_ob_modif_order), 
        sig_ob_check_execs (_sig_ob_check_execs), 
        sig_ob_update_prices (_sig_ob_update_prices), 
        sig_cli_cf_nw (_sig_cli_cf_nw), 
        sig_cli_cf_md (_sig_cli_cf_md), 
        sig_cli_cf_cc (_sig_cli_cf_cc), 
        sig_cli_rj_nw (_sig_cli_rj_nw), 
        sig_cli_rj_md (_sig_cli_rj_md), 
        sig_cli_rj_cc (_sig_cli_rj_cc), 
        sig_cli_cf_ex (_sig_cli_cf_ex), 
        sig_cli_cf_exlk (_sig_cli_cf_exlk)
        {};
    virtual ~status_common_info(){};

    // PROPERTIES AND SIGNALS
    mtk::nullable<mtk::trd::msg::CF_XX_LS>       __last_confirmation;
    virtual const mtk::nullable<mtk::trd::msg::CF_XX_LS>      &  last_confirmation() const {  return __last_confirmation; };
    virtual void set_last_confirmation(const mtk::nullable<mtk::trd::msg::CF_XX_LS>      &  _prop) {  __last_confirmation = _prop;  };
    mtk::nullable<mtk::trd::msg::RQ_XX_LS>       __last_request;
    virtual const mtk::nullable<mtk::trd::msg::RQ_XX_LS>      &  last_request() const {  return __last_request; };
    virtual void set_last_request(const mtk::nullable<mtk::trd::msg::RQ_XX_LS>      &  _prop) {  __last_request = _prop;  };
    int                                          __sequence;
    virtual const int                                         &  sequence() const {  return __sequence; };
    virtual void set_sequence(const int                                         &  _prop) {  __sequence = _prop;  };
    mtk::Signal<const mtk::trd::msg::CF_XX_LS&   /*order_st*/   >& sig_ob_add_order;
    mtk::Signal<const mtk::trd::msg::CF_XX_LS&   /*order_st*/   >& sig_ob_del_order;
    mtk::Signal<const mtk::trd::msg::CF_XX_LS&   /*order_st*/   >& sig_ob_modif_order;
    mtk::Signal<const mtk::trd::msg::CF_XX_LS&   /*order_st*/   >& sig_ob_check_execs;
    mtk::Signal<const mtk::trd::msg::CF_XX_LS&   /*order_st*/   >& sig_ob_update_prices;
    mtk::Signal<const mtk::trd::msg::CF_NW_LS&   /*cf*/         >& sig_cli_cf_nw;
    mtk::Signal<const mtk::trd::msg::CF_MD_LS&   /*cf*/         >& sig_cli_cf_md;
    mtk::Signal<const mtk::trd::msg::CF_CC_LS&   /*cf*/         >& sig_cli_cf_cc;
    mtk::Signal<const mtk::trd::msg::RJ_NW_LS&   /*rj*/         >& sig_cli_rj_nw;
    mtk::Signal<const mtk::trd::msg::RJ_MD_LS&   /*rj*/         >& sig_cli_rj_md;
    mtk::Signal<const mtk::trd::msg::RJ_CC_LS&   /*rj*/         >& sig_cli_rj_cc;
    mtk::Signal<const mtk::trd::msg::CF_EX_LS&   /*ex*/         >& sig_cli_cf_ex;
    mtk::Signal<const mtk::trd::msg::CF_EXLK&   /*exlk*/       >& sig_cli_cf_exlk;


    mtk::Signal<mtk::CountPtr<abstract_status> > signal_new_status;
    mtk::Signal<> signal_keep_temp_status;
    mtk::Signal<> signal_remove_temp_status;


    //  STATS AND COVERAGE
    static  scoverage     coverage;
};

scoverage status_common_info::coverage;





// -----------------------------------------------------------------------
//      abstract_status
class abstract_status  : public mtk::SignalReceptor
{
    mtk::non_copyable  nc;

public:
    abstract_status (mtk::CountPtr<status_common_info> _ci)
        : ci (_ci) {};
    virtual ~abstract_status() {};
    
    mtk::CountPtr<status_common_info> ci;
    
    virtual std::string  GetStatusName() = 0;

    //  INPUTS
    virtual void cli_rq_nw ( const mtk::trd::msg::oms_RQ_NW_LS&   rq           )=0;
    virtual void cli_rq_md ( const mtk::trd::msg::oms_RQ_MD_LS&   rq           )=0;
    virtual void cli_rq_cc ( const mtk::trd::msg::oms_RQ_CC_LS&   rq           )=0;
    virtual void mkt_cf_ex ( const mtk::trd::msg::CF_EX_LS&   ex           )=0;


    //  ACCESS
    virtual const mtk::nullable<mtk::trd::msg::CF_XX_LS>       &  last_confirmation (void) const { return ci->last_confirmation(); }; 
    virtual const mtk::nullable<mtk::trd::msg::RQ_XX_LS>       &  last_request (void) const { return ci->last_request(); }; 
    virtual const int                                          &  sequence (void) const { return ci->sequence(); }; 


    //  COVERAGE
    std::string  get_coverage_string(void)  { return ci->coverage.get_string(); };
};





// -----------------------------------------------------------------------
//      init
class init  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef init  CLASS_NAME;

public:
    init (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci)

        {  };
    
    std::string  GetStatusName()  {  return "init"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)


    //  INPUTS
public:
    void cli_rq_nw (const mtk::trd::msg::oms_RQ_NW_LS&   rq           );
    void cli_rq_md (const mtk::trd::msg::oms_RQ_MD_LS&   rq           );
    void cli_rq_cc (const mtk::trd::msg::oms_RQ_CC_LS&   rq           );
    void mkt_cf_ex (const mtk::trd::msg::CF_EX_LS&   ex           );


};



// -----------------------------------------------------------------------
//      market
class market  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef market  CLASS_NAME;

public:
    market (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci)

        {  };
    
    std::string  GetStatusName()  {  return "market"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)


    //  INPUTS
public:
    void cli_rq_nw (const mtk::trd::msg::oms_RQ_NW_LS&   rq           );
    void cli_rq_md (const mtk::trd::msg::oms_RQ_MD_LS&   rq           );
    void cli_rq_cc (const mtk::trd::msg::oms_RQ_CC_LS&   rq           );
    void mkt_cf_ex (const mtk::trd::msg::CF_EX_LS&   ex           );


};



// -----------------------------------------------------------------------
//      canceled
class canceled  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef canceled  CLASS_NAME;

public:
    canceled (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci)

        {  };
    
    std::string  GetStatusName()  {  return "canceled"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)


    //  INPUTS
public:
    void cli_rq_nw (const mtk::trd::msg::oms_RQ_NW_LS&   rq           );
    void cli_rq_md (const mtk::trd::msg::oms_RQ_MD_LS&   rq           );
    void cli_rq_cc (const mtk::trd::msg::oms_RQ_CC_LS&   rq           );
    void mkt_cf_ex (const mtk::trd::msg::CF_EX_LS&   ex           );


};



// -----------------------------------------------------------------------
//      executed
class executed  :   public  abstract_status
{
    mtk::non_copyable  nc;
    typedef executed  CLASS_NAME;

public:
    executed (mtk::CountPtr<status_common_info> _ci)
        : 
        abstract_status(_ci)

        {  };
    
    std::string  GetStatusName()  {  return "executed"; }

//private:   visibility ignored here
    //  specific properties (good for RAII)


    //  INPUTS
public:
    void cli_rq_nw (const mtk::trd::msg::oms_RQ_NW_LS&   rq           );
    void cli_rq_md (const mtk::trd::msg::oms_RQ_MD_LS&   rq           );
    void cli_rq_cc (const mtk::trd::msg::oms_RQ_CC_LS&   rq           );
    void mkt_cf_ex (const mtk::trd::msg::CF_EX_LS&   ex           );


};






void init::cli_rq_nw ( const mtk::trd::msg::oms_RQ_NW_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.init__cli_rq_nw;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "init::cli_rq_nw";

      const mtk::trd::msg::RQ_XX_LS& p(rq);  (void)p; CHECK_REQUEST    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_rq

                    nerrors > 0
                 ) {
//  inserting macro: LE

                    mtk::AlarmMsg(mtk::Alarm(MTK_HERE, method_name, MTK_SS("ERROR: " << serrors  << "Errors on " << method_name << "  from status: " << GetStatusName() << "  received:  "  << "  " << p
                                                                                <<  "  last request: " << last_request()
                                                                                <<  "  last confirmed: " << last_confirmation()),
                                                                                mtk::alPriorError));
                

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
  SEND_REJECT(rq, sig_cli_rj_nw, RJ_NW_LS)  

        }
    else 
        if (true ) {
//  inserting macro: wcf

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::CF_XX_LS lc = last_confirmation().Get();
                        lc.req_id  =   rq.request_info.req_id;
                        lc.market_pos = rq.request_pos;
                        lc.total_execs.remaining_qty.SetDouble(rq.request_pos.quantity.GetDouble() - lc.total_execs.acc_quantity.GetDouble());
                        if (lc.total_execs.remaining_qty.GetIntCode() <= 0)
                            throw mtk::Alarm(MTK_HERE, method_name, MTK_SS("pending quantity lower than executed quantity "
                                                                    << method_name << "  received:  "  << "  " << rq
                                                                    <<  "  last request: " << last_request()
                                                                    <<  "  last confirmed: " << last_confirmation()),
                                                                    mtk::alPriorError);
                        lc.description = MTK_SS("pr:" << last_request());
                        lc.orig_control_fluct = mtk::msg::sub_control_fluct("EMARKET.TRD", mtk::dtNowLocal());
                        ci->set_last_confirmation(mtk::make_nullable(lc));
                    }
                    else
                    {
                        static  int  market_order_id=0;
                        mtk::trd::msg::sub_total_executions  total_execs (
                                          0.
                                        , mtk::FixedNumber(mtk::fnDouble(0) ,  mtk::fnDec(0),  mtk::fnInc(1))
                                        , rq.request_pos.quantity);
                        mtk::trd::msg::CF_XX    cfxx (rq.invariant, MTK_SS("moid::" << ++market_order_id), rq.request_info.req_id, total_execs, MTK_SS("pr:" << rq.request_info.req_id), mtk::msg::sub_control_fluct("EMARKET.TRD", mtk::dtNowLocal()));
                        mtk::trd::msg::CF_XX_LS lc   (cfxx, rq.request_pos);
                        ci->set_last_confirmation(mtk::make_nullable(lc));
                    }
                
//  inserting macro: add_queue

                    if (last_confirmation().HasValue())
                        ci->sig_ob_add_order.emit(last_confirmation().Get());
                    else
                        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, method_name, MTK_SS("Error mising last confirmation trying to add queue. Errors on "
                                                                << method_name << "  received:  "  << "  " << rq
                                                                <<  "  last request: " << last_request()
                                                                <<  "  last confirmed: " << last_confirmation()),
                                                                mtk::alPriorError));
                

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_nw

                    if (last_confirmation().HasValue())
                        ci->sig_cli_cf_nw.emit(mtk::trd::msg::CF_NW_LS(last_confirmation().Get()));
                    else
                        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, method_name, MTK_SS("Error mising last confirmation trying to send confirm new. Errors on "
                                                                << method_name << "  received:  "  << "  " << rq
                                                                <<  "  last request: " << last_request()
                                                                <<  "  last confirmed: " << last_confirmation()),
                                                                mtk::alPriorError));
                
//  inserting macro: check_ex

                    if (last_confirmation().HasValue())
                        ci->sig_ob_check_execs.emit(mtk::trd::msg::CF_NW_LS(last_confirmation().Get()));
                    else
                        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, method_name, MTK_SS("Error mising last confirmation trying to check executions. Errors on "
                                                                << method_name << "  received:  "  << "  " << rq
                                                                <<  "  last request: " << last_request()
                                                                <<  "  last confirmed: " << last_confirmation()),
                                                                mtk::alPriorError));
                
//  inserting macro: upd_pr

                    if (last_confirmation().HasValue())
                        ci->sig_ob_update_prices.emit(last_confirmation().Get());
                    else
                        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, method_name, MTK_SS("Error mising last confirmation trying to check executions. Errors on "
                                                                << method_name << "  received:  "  << "  " << rq
                                                                <<  "  last request: " << last_request()
                                                                <<  "  last confirmed: " << last_confirmation()),
                                                                mtk::alPriorError));
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::cli_rq_md ( const mtk::trd::msg::oms_RQ_MD_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.init__cli_rq_md;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "init::cli_rq_md";

      const mtk::trd::msg::RQ_XX_LS& p(rq);  (void)p; CHECK_REQUEST    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
//  inserting macro: LE

                    mtk::AlarmMsg(mtk::Alarm(MTK_HERE, method_name, MTK_SS("ERROR: " << serrors  << "Errors on " << method_name << "  from status: " << GetStatusName() << "  received:  "  << "  " << p
                                                                                <<  "  last request: " << last_request()
                                                                                <<  "  last confirmed: " << last_confirmation()),
                                                                                mtk::alPriorError));
                

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
  SEND_REJECT(rq, sig_cli_rj_md, RJ_MD_LS)  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::cli_rq_cc ( const mtk::trd::msg::oms_RQ_CC_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.init__cli_rq_cc;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "init::cli_rq_cc";

      const mtk::trd::msg::RQ_XX_LS& p(rq);  (void)p; CHECK_REQUEST    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
//  inserting macro: LE

                    mtk::AlarmMsg(mtk::Alarm(MTK_HERE, method_name, MTK_SS("ERROR: " << serrors  << "Errors on " << method_name << "  from status: " << GetStatusName() << "  received:  "  << "  " << p
                                                                                <<  "  last request: " << last_request()
                                                                                <<  "  last confirmed: " << last_confirmation()),
                                                                                mtk::alPriorError));
                

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqcc
  SEND_REJECT(rq, sig_cli_rj_cc, RJ_CC_LS)  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void init::mkt_cf_ex ( const mtk::trd::msg::CF_EX_LS&   ex            )
{
    //  coverage
    ++status_common_info::coverage.init__mkt_cf_ex;

    //  remove unused warning
    (void) ex;

    
	static const char* method_name = "init::mkt_cf_ex";

    
                                const mtk::trd::msg::CF_XX_LS& p(ex);  (void)p;
                                const mtk::trd::msg::CF_XX_LS& cf(ex);
                                CHECK_CONFIRM
                                CHECK_EXEC
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
//  inserting macro: LE

                    mtk::AlarmMsg(mtk::Alarm(MTK_HERE, method_name, MTK_SS("ERROR: " << serrors  << "Errors on " << method_name << "  from status: " << GetStatusName() << "  received:  "  << "  " << p
                                                                                <<  "  last request: " << last_request()
                                                                                <<  "  last confirmed: " << last_confirmation()),
                                                                                mtk::alPriorError));
                

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::cli_rq_nw ( const mtk::trd::msg::oms_RQ_NW_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.market__cli_rq_nw;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "market::cli_rq_nw";

      const mtk::trd::msg::RQ_XX_LS& p(rq);  (void)p; CHECK_REQUEST    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
//  inserting macro: LE

                    mtk::AlarmMsg(mtk::Alarm(MTK_HERE, method_name, MTK_SS("ERROR: " << serrors  << "Errors on " << method_name << "  from status: " << GetStatusName() << "  received:  "  << "  " << p
                                                                                <<  "  last request: " << last_request()
                                                                                <<  "  last confirmed: " << last_confirmation()),
                                                                                mtk::alPriorError));
                
//  inserting macro: del_queue

                    if (last_confirmation().HasValue())
                        ci->sig_ob_del_order.emit(last_confirmation().Get());
                    else
                        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, method_name, MTK_SS("Error mising last confirmation trying to add queue. Errors on "
                                                                << method_name << "  received:  "  << "  " << rq
                                                                <<  "  last request: " << last_request()
                                                                <<  "  last confirmed: " << last_confirmation()),
                                                                mtk::alPriorError));
                

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
  SEND_REJECT(rq, sig_cli_rj_nw, RJ_NW_LS)  
//  inserting macro: cf_cc

                    if (last_confirmation().HasValue())
                        ci->sig_cli_cf_cc.emit(mtk::trd::msg::CF_CC_LS(last_confirmation().Get()));
                    else
                        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, method_name, MTK_SS("Error mising last confirmation trying to send confirm cancelation. Errors on "
                                                                << method_name << "  received:  "  << "  " << rq
                                                                <<  "  last request: " << last_request()
                                                                <<  "  last confirmed: " << last_confirmation()),
                                                                mtk::alPriorError));
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::cli_rq_md ( const mtk::trd::msg::oms_RQ_MD_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.market__cli_rq_md;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "market::cli_rq_md";

      const mtk::trd::msg::RQ_XX_LS& p(rq);  (void)p; CHECK_REQUEST    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_rq

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
  SEND_REJECT(rq, sig_cli_rj_md, RJ_MD_LS)  

        }
    else 
        if (true ) {
//  inserting macro: wcf

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::CF_XX_LS lc = last_confirmation().Get();
                        lc.req_id  =   rq.request_info.req_id;
                        lc.market_pos = rq.request_pos;
                        lc.total_execs.remaining_qty.SetDouble(rq.request_pos.quantity.GetDouble() - lc.total_execs.acc_quantity.GetDouble());
                        if (lc.total_execs.remaining_qty.GetIntCode() <= 0)
                            throw mtk::Alarm(MTK_HERE, method_name, MTK_SS("pending quantity lower than executed quantity "
                                                                    << method_name << "  received:  "  << "  " << rq
                                                                    <<  "  last request: " << last_request()
                                                                    <<  "  last confirmed: " << last_confirmation()),
                                                                    mtk::alPriorError);
                        lc.description = MTK_SS("pr:" << last_request());
                        lc.orig_control_fluct = mtk::msg::sub_control_fluct("EMARKET.TRD", mtk::dtNowLocal());
                        ci->set_last_confirmation(mtk::make_nullable(lc));
                    }
                    else
                    {
                        static  int  market_order_id=0;
                        mtk::trd::msg::sub_total_executions  total_execs (
                                          0.
                                        , mtk::FixedNumber(mtk::fnDouble(0) ,  mtk::fnDec(0),  mtk::fnInc(1))
                                        , rq.request_pos.quantity);
                        mtk::trd::msg::CF_XX    cfxx (rq.invariant, MTK_SS("moid::" << ++market_order_id), rq.request_info.req_id, total_execs, MTK_SS("pr:" << rq.request_info.req_id), mtk::msg::sub_control_fluct("EMARKET.TRD", mtk::dtNowLocal()));
                        mtk::trd::msg::CF_XX_LS lc   (cfxx, rq.request_pos);
                        ci->set_last_confirmation(mtk::make_nullable(lc));
                    }
                
//  inserting macro: modif_queue

                    if (last_confirmation().HasValue())
                        ci->sig_ob_modif_order.emit(last_confirmation().Get());
                    else
                        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, method_name, MTK_SS("Error mising last confirmation trying to add queue. Errors on "
                                                                << method_name << "  received:  "  << "  " << rq
                                                                <<  "  last request: " << last_request()
                                                                <<  "  last confirmed: " << last_confirmation()),
                                                                mtk::alPriorError));
                

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_md

                    if (last_confirmation().HasValue())
                        ci->sig_cli_cf_md.emit(mtk::trd::msg::CF_MD_LS(last_confirmation().Get()));
                    else
                        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, method_name, MTK_SS("Error mising last confirmation trying to send confirm modification. Errors on "
                                                                << method_name << "  received:  "  << "  " << rq
                                                                <<  "  last request: " << last_request()
                                                                <<  "  last confirmed: " << last_confirmation()),
                                                                mtk::alPriorError));
                
//  inserting macro: check_ex

                    if (last_confirmation().HasValue())
                        ci->sig_ob_check_execs.emit(mtk::trd::msg::CF_NW_LS(last_confirmation().Get()));
                    else
                        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, method_name, MTK_SS("Error mising last confirmation trying to check executions. Errors on "
                                                                << method_name << "  received:  "  << "  " << rq
                                                                <<  "  last request: " << last_request()
                                                                <<  "  last confirmed: " << last_confirmation()),
                                                                mtk::alPriorError));
                
//  inserting macro: upd_pr

                    if (last_confirmation().HasValue())
                        ci->sig_ob_update_prices.emit(last_confirmation().Get());
                    else
                        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, method_name, MTK_SS("Error mising last confirmation trying to check executions. Errors on "
                                                                << method_name << "  received:  "  << "  " << rq
                                                                <<  "  last request: " << last_request()
                                                                <<  "  last confirmed: " << last_confirmation()),
                                                                mtk::alPriorError));
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::cli_rq_cc ( const mtk::trd::msg::oms_RQ_CC_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.market__cli_rq_cc;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "market::cli_rq_cc";

      const mtk::trd::msg::RQ_XX_LS& p(rq);  (void)p; CHECK_REQUEST    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: invalid_rq

                    nerrors > 0
                 ) {

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqcc
  SEND_REJECT(rq, sig_cli_rj_cc, RJ_CC_LS)  

        }
    else 
        if (true ) {
//  inserting macro: wcf

                    if (last_confirmation().HasValue())
                    {
                        mtk::trd::msg::CF_XX_LS lc = last_confirmation().Get();
                        lc.req_id  =   rq.request_info.req_id;
                        lc.market_pos = rq.request_pos;
                        lc.total_execs.remaining_qty.SetDouble(rq.request_pos.quantity.GetDouble() - lc.total_execs.acc_quantity.GetDouble());
                        if (lc.total_execs.remaining_qty.GetIntCode() <= 0)
                            throw mtk::Alarm(MTK_HERE, method_name, MTK_SS("pending quantity lower than executed quantity "
                                                                    << method_name << "  received:  "  << "  " << rq
                                                                    <<  "  last request: " << last_request()
                                                                    <<  "  last confirmed: " << last_confirmation()),
                                                                    mtk::alPriorError);
                        lc.description = MTK_SS("pr:" << last_request());
                        lc.orig_control_fluct = mtk::msg::sub_control_fluct("EMARKET.TRD", mtk::dtNowLocal());
                        ci->set_last_confirmation(mtk::make_nullable(lc));
                    }
                    else
                    {
                        static  int  market_order_id=0;
                        mtk::trd::msg::sub_total_executions  total_execs (
                                          0.
                                        , mtk::FixedNumber(mtk::fnDouble(0) ,  mtk::fnDec(0),  mtk::fnInc(1))
                                        , rq.request_pos.quantity);
                        mtk::trd::msg::CF_XX    cfxx (rq.invariant, MTK_SS("moid::" << ++market_order_id), rq.request_info.req_id, total_execs, MTK_SS("pr:" << rq.request_info.req_id), mtk::msg::sub_control_fluct("EMARKET.TRD", mtk::dtNowLocal()));
                        mtk::trd::msg::CF_XX_LS lc   (cfxx, rq.request_pos);
                        ci->set_last_confirmation(mtk::make_nullable(lc));
                    }
                
//  inserting macro: del_queue

                    if (last_confirmation().HasValue())
                        ci->sig_ob_del_order.emit(last_confirmation().Get());
                    else
                        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, method_name, MTK_SS("Error mising last confirmation trying to add queue. Errors on "
                                                                << method_name << "  received:  "  << "  " << rq
                                                                <<  "  last request: " << last_request()
                                                                <<  "  last confirmed: " << last_confirmation()),
                                                                mtk::alPriorError));
                

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_cc

                    if (last_confirmation().HasValue())
                        ci->sig_cli_cf_cc.emit(mtk::trd::msg::CF_CC_LS(last_confirmation().Get()));
                    else
                        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, method_name, MTK_SS("Error mising last confirmation trying to send confirm cancelation. Errors on "
                                                                << method_name << "  received:  "  << "  " << rq
                                                                <<  "  last request: " << last_request()
                                                                <<  "  last confirmed: " << last_confirmation()),
                                                                mtk::alPriorError));
                
//  inserting macro: upd_pr

                    if (last_confirmation().HasValue())
                        ci->sig_ob_update_prices.emit(last_confirmation().Get());
                    else
                        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, method_name, MTK_SS("Error mising last confirmation trying to check executions. Errors on "
                                                                << method_name << "  received:  "  << "  " << rq
                                                                <<  "  last request: " << last_request()
                                                                <<  "  last confirmed: " << last_confirmation()),
                                                                mtk::alPriorError));
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void market::mkt_cf_ex ( const mtk::trd::msg::CF_EX_LS&   ex            )
{
    //  coverage
    ++status_common_info::coverage.market__mkt_cf_ex;

    //  remove unused warning
    (void) ex;

    
	static const char* method_name = "market::mkt_cf_ex";

    
                                const mtk::trd::msg::CF_XX_LS& p(ex);  (void)p;
                                const mtk::trd::msg::CF_XX_LS& cf(ex);
                                CHECK_CONFIRM
                                CHECK_EXEC
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (//  inserting macro: full_exec

                    last_confirmation().HasValue() == true
                    &&  last_confirmation().Get().total_execs.acc_quantity
                        == last_confirmation().Get().market_pos.quantity
                    /*last_confirmation().HasValue() == true  && last_confirmation().Get().total_execs.remaining_qty.GetIntCode() == 0*/
                 ) {
//  inserting macro: wex

                    ci->set_last_confirmation(mtk::make_nullable(static_cast<const mtk::trd::msg::CF_XX_LS&>(ex)));
                

            new_status = mtk::make_cptr(new executed (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_ex

                    if (last_confirmation().HasValue())
                    {
                        ci->sig_cli_cf_ex.emit(ex);
                        mtk::trd::msg::CF_EXLK   exlk(ex, ex.executed_pos);
                        exlk.invariant.product_code.product = MTK_SS("LK_" <<  exlk.invariant.product_code.product);
                        exlk.req_id.session_id = std::string("lk_") + exlk.req_id.session_id;
                        if(exlk.invariant.side == mtk::trd::msg::buy)
                            exlk.invariant.side = mtk::trd::msg::sell;
                        else
                            exlk.invariant.side = mtk::trd::msg::buy;
                        exlk.executed_pos.price = ++exlk.executed_pos.price;
                        exlk.total_execs.acc_quantity.SetIntCode(0);
                        exlk.total_execs.sum_price_by_qty = 0;
                        ci->sig_cli_cf_exlk.emit(exlk);
                    }
                    else
                        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, method_name, MTK_SS("Error mising last confirmation trying to send confirm cancelation. Errors on "
                                                                << method_name << "  received:  "  << "  " << ex
                                                                <<  "  last request: " << last_request()
                                                                <<  "  last confirmed: " << last_confirmation()),
                                                                mtk::alPriorError));
                

        }
    else 
        if (true ) {
//  inserting macro: wex

                    ci->set_last_confirmation(mtk::make_nullable(static_cast<const mtk::trd::msg::CF_XX_LS&>(ex)));
                

            new_status = mtk::make_cptr(new market (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: cf_ex

                    if (last_confirmation().HasValue())
                    {
                        ci->sig_cli_cf_ex.emit(ex);
                        mtk::trd::msg::CF_EXLK   exlk(ex, ex.executed_pos);
                        exlk.invariant.product_code.product = MTK_SS("LK_" <<  exlk.invariant.product_code.product);
                        exlk.req_id.session_id = std::string("lk_") + exlk.req_id.session_id;
                        if(exlk.invariant.side == mtk::trd::msg::buy)
                            exlk.invariant.side = mtk::trd::msg::sell;
                        else
                            exlk.invariant.side = mtk::trd::msg::buy;
                        exlk.executed_pos.price = ++exlk.executed_pos.price;
                        exlk.total_execs.acc_quantity.SetIntCode(0);
                        exlk.total_execs.sum_price_by_qty = 0;
                        ci->sig_cli_cf_exlk.emit(exlk);
                    }
                    else
                        mtk::AlarmMsg(mtk::Alarm(MTK_HERE, method_name, MTK_SS("Error mising last confirmation trying to send confirm cancelation. Errors on "
                                                                << method_name << "  received:  "  << "  " << ex
                                                                <<  "  last request: " << last_request()
                                                                <<  "  last confirmed: " << last_confirmation()),
                                                                mtk::alPriorError));
                

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::cli_rq_nw ( const mtk::trd::msg::oms_RQ_NW_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.canceled__cli_rq_nw;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "canceled::cli_rq_nw";

      const mtk::trd::msg::RQ_XX_LS& p(rq);  (void)p; CHECK_REQUEST    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
//  inserting macro: LE

                    mtk::AlarmMsg(mtk::Alarm(MTK_HERE, method_name, MTK_SS("ERROR: " << serrors  << "Errors on " << method_name << "  from status: " << GetStatusName() << "  received:  "  << "  " << p
                                                                                <<  "  last request: " << last_request()
                                                                                <<  "  last confirmed: " << last_confirmation()),
                                                                                mtk::alPriorError));
                

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
  SEND_REJECT(rq, sig_cli_rj_nw, RJ_NW_LS)  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::cli_rq_md ( const mtk::trd::msg::oms_RQ_MD_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.canceled__cli_rq_md;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "canceled::cli_rq_md";

      const mtk::trd::msg::RQ_XX_LS& p(rq);  (void)p; CHECK_REQUEST    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
//  inserting macro: LE

                    mtk::AlarmMsg(mtk::Alarm(MTK_HERE, method_name, MTK_SS("ERROR: " << serrors  << "Errors on " << method_name << "  from status: " << GetStatusName() << "  received:  "  << "  " << p
                                                                                <<  "  last request: " << last_request()
                                                                                <<  "  last confirmed: " << last_confirmation()),
                                                                                mtk::alPriorError));
                

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
  SEND_REJECT(rq, sig_cli_rj_md, RJ_MD_LS)  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::cli_rq_cc ( const mtk::trd::msg::oms_RQ_CC_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.canceled__cli_rq_cc;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "canceled::cli_rq_cc";

      const mtk::trd::msg::RQ_XX_LS& p(rq);  (void)p; CHECK_REQUEST    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
//  inserting macro: LE

                    mtk::AlarmMsg(mtk::Alarm(MTK_HERE, method_name, MTK_SS("ERROR: " << serrors  << "Errors on " << method_name << "  from status: " << GetStatusName() << "  received:  "  << "  " << p
                                                                                <<  "  last request: " << last_request()
                                                                                <<  "  last confirmed: " << last_confirmation()),
                                                                                mtk::alPriorError));
                

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqcc
  SEND_REJECT(rq, sig_cli_rj_cc, RJ_CC_LS)  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void canceled::mkt_cf_ex ( const mtk::trd::msg::CF_EX_LS&   ex            )
{
    //  coverage
    ++status_common_info::coverage.canceled__mkt_cf_ex;

    //  remove unused warning
    (void) ex;

    
	static const char* method_name = "canceled::mkt_cf_ex";

    
                                const mtk::trd::msg::CF_XX_LS& p(ex);  (void)p;
                                const mtk::trd::msg::CF_XX_LS& cf(ex);
                                CHECK_CONFIRM
                                CHECK_EXEC
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
//  inserting macro: LE

                    mtk::AlarmMsg(mtk::Alarm(MTK_HERE, method_name, MTK_SS("ERROR: " << serrors  << "Errors on " << method_name << "  from status: " << GetStatusName() << "  received:  "  << "  " << p
                                                                                <<  "  last request: " << last_request()
                                                                                <<  "  last confirmed: " << last_confirmation()),
                                                                                mtk::alPriorError));
                

            new_status = mtk::make_cptr(new canceled (ci));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void executed::cli_rq_nw ( const mtk::trd::msg::oms_RQ_NW_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.executed__cli_rq_nw;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "executed::cli_rq_nw";

      const mtk::trd::msg::RQ_XX_LS& p(rq);  (void)p; CHECK_REQUEST    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
//  inserting macro: LE

                    mtk::AlarmMsg(mtk::Alarm(MTK_HERE, method_name, MTK_SS("ERROR: " << serrors  << "Errors on " << method_name << "  from status: " << GetStatusName() << "  received:  "  << "  " << p
                                                                                <<  "  last request: " << last_request()
                                                                                <<  "  last confirmed: " << last_confirmation()),
                                                                                mtk::alPriorError));
                

            new_status = mtk::make_cptr(new executed (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqnw
  SEND_REJECT(rq, sig_cli_rj_nw, RJ_NW_LS)  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void executed::cli_rq_md ( const mtk::trd::msg::oms_RQ_MD_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.executed__cli_rq_md;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "executed::cli_rq_md";

      const mtk::trd::msg::RQ_XX_LS& p(rq);  (void)p; CHECK_REQUEST    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
//  inserting macro: LE

                    mtk::AlarmMsg(mtk::Alarm(MTK_HERE, method_name, MTK_SS("ERROR: " << serrors  << "Errors on " << method_name << "  from status: " << GetStatusName() << "  received:  "  << "  " << p
                                                                                <<  "  last request: " << last_request()
                                                                                <<  "  last confirmed: " << last_confirmation()),
                                                                                mtk::alPriorError));
                

            new_status = mtk::make_cptr(new executed (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqmd
  SEND_REJECT(rq, sig_cli_rj_md, RJ_MD_LS)  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void executed::cli_rq_cc ( const mtk::trd::msg::oms_RQ_CC_LS&   rq            )
{
    //  coverage
    ++status_common_info::coverage.executed__cli_rq_cc;

    //  remove unused warning
    (void) rq;

    
	static const char* method_name = "executed::cli_rq_cc";

      const mtk::trd::msg::RQ_XX_LS& p(rq);  (void)p; CHECK_REQUEST    

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
//  inserting macro: LE

                    mtk::AlarmMsg(mtk::Alarm(MTK_HERE, method_name, MTK_SS("ERROR: " << serrors  << "Errors on " << method_name << "  from status: " << GetStatusName() << "  received:  "  << "  " << p
                                                                                <<  "  last request: " << last_request()
                                                                                <<  "  last confirmed: " << last_confirmation()),
                                                                                mtk::alPriorError));
                

            new_status = mtk::make_cptr(new executed (ci));
            ci->signal_new_status.emit(new_status);
//  inserting macro: rj_rqcc
  SEND_REJECT(rq, sig_cli_rj_cc, RJ_CC_LS)  

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}

void executed::mkt_cf_ex ( const mtk::trd::msg::CF_EX_LS&   ex            )
{
    //  coverage
    ++status_common_info::coverage.executed__mkt_cf_ex;

    //  remove unused warning
    (void) ex;

    
	static const char* method_name = "executed::mkt_cf_ex";

    
                                const mtk::trd::msg::CF_XX_LS& p(ex);  (void)p;
                                const mtk::trd::msg::CF_XX_LS& cf(ex);
                                CHECK_CONFIRM
                                CHECK_EXEC
                        

    mtk::CountPtr<abstract_status> new_status;
    ci->signal_keep_temp_status();    
    try
    {
        
        if (true ) {
//  inserting macro: LE

                    mtk::AlarmMsg(mtk::Alarm(MTK_HERE, method_name, MTK_SS("ERROR: " << serrors  << "Errors on " << method_name << "  from status: " << GetStatusName() << "  received:  "  << "  " << p
                                                                                <<  "  last request: " << last_request()
                                                                                <<  "  last confirmed: " << last_confirmation()),
                                                                                mtk::alPriorError));
                

            new_status = mtk::make_cptr(new executed (ci));
            ci->signal_new_status.emit(new_status);

        }
    
    }
    MTK_CATCH_RETHROW(method_name, "exception fsm, rethrowed")
    ci->signal_remove_temp_status();
}


};  // end   namespace fsmgen_ord_ls {

ord_ls_dangerous_signals_not_warped::ord_ls_dangerous_signals_not_warped()
{
    mtk::CountPtr<fsmgen_ord_ls::status_common_info> ci = mtk::make_cptr(
                            new fsmgen_ord_ls::status_common_info ( sig_ob_add_order,sig_ob_del_order,sig_ob_modif_order,sig_ob_check_execs,sig_ob_update_prices,sig_cli_cf_nw,sig_cli_cf_md,sig_cli_cf_cc,sig_cli_rj_nw,sig_cli_rj_md,sig_cli_rj_cc,sig_cli_cf_ex,sig_cli_cf_exlk));

    current_status = mtk::make_cptr(new fsmgen_ord_ls::init(ci ) );
    MTK_CONNECT_THIS(ci->signal_new_status, on_new_status)
    MTK_CONNECT_THIS(ci->signal_keep_temp_status, on_keep_temp_status)
    MTK_CONNECT_THIS(ci->signal_remove_temp_status, on_remove_temp_status)
}


ord_ls_dangerous_signals_not_warped::~ord_ls_dangerous_signals_not_warped()
{
}

void ord_ls_dangerous_signals_not_warped::on_new_status (mtk::CountPtr<fsmgen_ord_ls::abstract_status>  new_status)
{
    current_status = new_status;
}

void ord_ls_dangerous_signals_not_warped::on_keep_temp_status (void)
{
    queue_temp_status.push_back(current_status);
}
void ord_ls_dangerous_signals_not_warped::on_remove_temp_status (void)
{
    queue_temp_status.pop_front();
}


std::string  ord_ls_dangerous_signals_not_warped::get_coverage_string(void)
{
    return current_status->get_coverage_string();
}

void ord_ls_dangerous_signals_not_warped::cli_rq_nw (const mtk::trd::msg::oms_RQ_NW_LS&   rq           )
{
    mtk::CountPtr<fsmgen_ord_ls::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->cli_rq_nw(rq);
}
void ord_ls_dangerous_signals_not_warped::cli_rq_md (const mtk::trd::msg::oms_RQ_MD_LS&   rq           )
{
    mtk::CountPtr<fsmgen_ord_ls::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->cli_rq_md(rq);
}
void ord_ls_dangerous_signals_not_warped::cli_rq_cc (const mtk::trd::msg::oms_RQ_CC_LS&   rq           )
{
    mtk::CountPtr<fsmgen_ord_ls::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->cli_rq_cc(rq);
}
void ord_ls_dangerous_signals_not_warped::mkt_cf_ex (const mtk::trd::msg::CF_EX_LS&   ex           )
{
    mtk::CountPtr<fsmgen_ord_ls::abstract_status>  current_status_to_keep_alive_on_scope = current_status;
    current_status_to_keep_alive_on_scope->mkt_cf_ex(ex);
}
const mtk::nullable<mtk::trd::msg::CF_XX_LS>       & ord_ls_dangerous_signals_not_warped::last_confirmation (void) const
{
    return current_status->last_confirmation();
}
const mtk::nullable<mtk::trd::msg::RQ_XX_LS>       & ord_ls_dangerous_signals_not_warped::last_request (void) const
{
    return current_status->last_request();
}
const int                                          & ord_ls_dangerous_signals_not_warped::sequence (void) const
{
    return current_status->sequence();
}

//  warper RAII with signals and repository
ord_ls::ord_ls (void)
    : ptr (new ord_ls_dangerous_signals_not_warped())
{
    ptr->sig_ob_add_order.connect(&sig_ob_add_order);
    ptr->sig_ob_del_order.connect(&sig_ob_del_order);
    ptr->sig_ob_modif_order.connect(&sig_ob_modif_order);
    ptr->sig_ob_check_execs.connect(&sig_ob_check_execs);
    ptr->sig_ob_update_prices.connect(&sig_ob_update_prices);
    ptr->sig_cli_cf_nw.connect(&sig_cli_cf_nw);
    ptr->sig_cli_cf_md.connect(&sig_cli_cf_md);
    ptr->sig_cli_cf_cc.connect(&sig_cli_cf_cc);
    ptr->sig_cli_rj_nw.connect(&sig_cli_rj_nw);
    ptr->sig_cli_rj_md.connect(&sig_cli_rj_md);
    ptr->sig_cli_rj_cc.connect(&sig_cli_rj_cc);
    ptr->sig_cli_cf_ex.connect(&sig_cli_cf_ex);
    ptr->sig_cli_cf_exlk.connect(&sig_cli_cf_exlk);
}
ord_ls::ord_ls (const mtk::CountPtr<ord_ls_dangerous_signals_not_warped>& _ptr)
    :   ptr(_ptr)
{
    try
    {
    ptr->sig_ob_add_order.connect(&sig_ob_add_order);
    ptr->sig_ob_del_order.connect(&sig_ob_del_order);
    ptr->sig_ob_modif_order.connect(&sig_ob_modif_order);
    ptr->sig_ob_check_execs.connect(&sig_ob_check_execs);
    ptr->sig_ob_update_prices.connect(&sig_ob_update_prices);
    ptr->sig_cli_cf_nw.connect(&sig_cli_cf_nw);
    ptr->sig_cli_cf_md.connect(&sig_cli_cf_md);
    ptr->sig_cli_cf_cc.connect(&sig_cli_cf_cc);
    ptr->sig_cli_rj_nw.connect(&sig_cli_rj_nw);
    ptr->sig_cli_rj_md.connect(&sig_cli_rj_md);
    ptr->sig_cli_rj_cc.connect(&sig_cli_rj_cc);
    ptr->sig_cli_cf_ex.connect(&sig_cli_cf_ex);
    ptr->sig_cli_cf_exlk.connect(&sig_cli_cf_exlk);
    } MTK_CATCH_RETHROW("ord_ls","connecting signals")
}

void ord_ls::set (const mtk::CountPtr<ord_ls_dangerous_signals_not_warped>& _ptr)
{
ptr = _ptr;
    ptr->sig_ob_add_order.connect(&sig_ob_add_order);
    ptr->sig_ob_del_order.connect(&sig_ob_del_order);
    ptr->sig_ob_modif_order.connect(&sig_ob_modif_order);
    ptr->sig_ob_check_execs.connect(&sig_ob_check_execs);
    ptr->sig_ob_update_prices.connect(&sig_ob_update_prices);
    ptr->sig_cli_cf_nw.connect(&sig_cli_cf_nw);
    ptr->sig_cli_cf_md.connect(&sig_cli_cf_md);
    ptr->sig_cli_cf_cc.connect(&sig_cli_cf_cc);
    ptr->sig_cli_rj_nw.connect(&sig_cli_rj_nw);
    ptr->sig_cli_rj_md.connect(&sig_cli_rj_md);
    ptr->sig_cli_rj_cc.connect(&sig_cli_rj_cc);
    ptr->sig_cli_cf_ex.connect(&sig_cli_cf_ex);
    ptr->sig_cli_cf_exlk.connect(&sig_cli_cf_exlk);
}


void ord_ls::cli_rq_nw (const mtk::trd::msg::oms_RQ_NW_LS&   rq           )
{
    ptr->cli_rq_nw(rq);
}
void ord_ls::cli_rq_md (const mtk::trd::msg::oms_RQ_MD_LS&   rq           )
{
    ptr->cli_rq_md(rq);
}
void ord_ls::cli_rq_cc (const mtk::trd::msg::oms_RQ_CC_LS&   rq           )
{
    ptr->cli_rq_cc(rq);
}
void ord_ls::mkt_cf_ex (const mtk::trd::msg::CF_EX_LS&   ex           )
{
    ptr->mkt_cf_ex(ex);
}
const mtk::nullable<mtk::trd::msg::CF_XX_LS>       & ord_ls::last_confirmation (void) const
{
    return  ptr->last_confirmation();
}
const mtk::nullable<mtk::trd::msg::RQ_XX_LS>       & ord_ls::last_request (void) const
{
    return  ptr->last_request();
}
const int                                          & ord_ls::sequence (void) const
{
    return  ptr->sequence();
}
std::string  ord_ls::get_coverage_string (void)
{
    return ptr->get_coverage_string();
}
